отрицание - not()
конъюнкция - and
дизъюнкция - or
импликация - <=
эквиваленция - ==

Приоритеты логических операций: 

	- not
	- and
	- or
	- <=
	- ==

В Python конструкция for i in используется для итерации по различным итерируемым объектам. Это могут быть списки, строки, кортежи, словари, множества.

Изменяемые типы данных:

	- списки
	- словари
	- множества

Неизменяемые типы данных:

	- целые числа
	- строки
	- кортежи
	- логические значения

Типы коллекций python: 

	- списки 

	- кортежи 

	- множества

	- словари

	- строки

Списки (тип list)

	- Упорядоченность: элементы имеют индекс, начиная с 0, и сохраняют порядок добавления.
	- Изменяемость: можно добавлять, удалять и изменять элементы.
	- Допускает разные типы данных.

	arr = [] - объявление пустого списка.
	arr = list() - объявление пустого списка.

	arr = [0, 1, 2, 3, 4, 5] - объявление не пустого списка.

	arr = []
	for i in range(6):
	    arr.append(i)
	print(arr) - альтернативный способ объявления не пустого списка.

	Задача: вывести элемент 4 из списка:

		arr = ['mother', 'father', [1, 2, 3, 4]]
		print(arr[2][3]) // 4

	Сложение списков:

		arr1 = [1, 2, 3, 4, 5]
		arr2 = [6, 7, 8]
		arrRes = arr1 + arr2
		print(arrRes) // [1, 2, 3, 4, 5, 6, 7, 8]

	Срез - способ получить часть последовательности с помощью специального синтаксиса в квадратных скобках:

		sequence[start:stop:step]

		- start - индекс первого элемента среза (включительно). Если не указан, берётся с начала последовательности.

		- stop - индекс, на котором срез заканчивается (не включается в результат). Если не указан, берётся до конца последовательности.

		- step - шаг, с которым выбираются элементы (по умолчанию 1). Можно использовать отрицательные значения для обратного порядка.

		В Python конструкция [::-1] используется для обратного среза последовательностей, таких как списки и строки. Она позволяет получить все элементы последовательности в обратном порядке.

	1) list() - создаёт новый список на основе переданного ему итерируемого объекта (или создаёт пустой список, если аргумент не указан) 

		list([iterable]) - iterable - любой итерируемый объект.

		arr = list() - создание пустого списка

		arr = list('deftones') // ['d', 'e', 'f', 't', 'o', 'n', 'e', 's']

		arr = list(range(1, 11)) // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

	2) append() - встроенный метод списков в Python, который добавляет один элемент в конец существующего списка.

		list.append(someElement)

	3) extend() - встроенный метод списков в Python, который используется для расширения списка, добавляя в его конец все элементы из переданного итерируемого объекта (например, другого списка, кортежа, множества, строки и т.д.).

		list.extend(someElements)

	4) insert() - используется для вставки элемента в список на указанную позицию.

		list.insert(index, element)

		- index - позиция (целое число), на которую нужно вставить элемент. 

		- element - элемент любого типа, который нужно вставить.

	5) remove() - используется для удаления первого вхождения указанного элемента из списка по его значению.

		list.remove(element)

		- element - обязательный параметр, значение элемента, которое нужно удалить из списка.

	6) pop() - используется для удаления элемента из списка по указанному индексу и возвращению этого удалённого элемента.

		list.pop([index])

		- index - позиция элемента, который нужно удалить. Если индекс не указан, удаляется и возвращается последний элемент списка.

	7) clear() - используется для удаления всех элементов из изменяемых контейнеров/

		arr = [1, 2, 3, 4, 5]
		arr.clear()
		print(arr) // []

	8) index() - используется для поиска позиции (индекса) первого вхождения указанного элемента в списке.

		arr = [1, 2, 3, 4, 5]
		print(arr.index(4)) // 3

		- element - обязательный параметр. Элемент, индекс которого нужно найти.

		- start - необязательный параметр. Индекс, с которого начинается поиск (по умолчанию 0).

		- end - необязательный параметр. Индекс, на котором заканчивается поиск (по умолчанию - до конца списка).

	9) count() - используется для подсчёта количества вхождений указанного элемента в список.

		arr = [1, 2, 4, 4, 4]
		print(arr.count(4)) // 3

	10) copy() - используется для создания поверхностной копии списка. 

		arr = [1, 2, 3, 4, 5]
		arrCopy = arr.copy() 
		print(arrCopy) // [1, 2, 3, 4, 5]

	11) sort() - используется для сортировки элементов списка на месте, то есть изменяет исходный список без создания нового.

		arr = [14, 5623, 236, 234, 262, 112, 36]
		arr.sort()
		print(arr) // [14, 36, 112, 234, 236, 262, 5623]

		- reverse - необязательный параметр. Если True, сортирует список в порядке убывания (по умолчанию False - сортировка по возрастанию).

	12) sorted() - абсолютно тоже самое, что и sort(), но возвращает новый отсортированный список, при этом исходный объект остаётся без изменений. 

	12) reverse() - используется для обратного порядка элементов списка. ИЗМЕНЯЕТ СПИСОК НА МЕСТЕ! ОН НИЧЕГО НЕ ВОЗВРАЩАЕТ.rever

		arr = [234, 262, 112, 36]
		arr.reverse()
		print(arr) // [36, 112, 262, 234]	

	15) функции len(), min(), max() и sum().

del - оператор, использующийся для удаления элементов из списка, переменных, срезов, атрибутов и других объектов. Он удаляет объект или элемент по индексу, срезу или имени, освобождая соответствующую память и изменяя структуру данных.

	Удаление элемента по индексу:

		arr = [1, 2, 3, 'emma', 4, 5]
		del arr
		print(arr) // [1, 2, 3, 'emma', 5]

Кортежи (тип tuple)

	- Упорядоченность: элементы кортежа располагаются в определённом порядке, к ним можно обращаться по индексу, начиная с 0.
	- Неизменяемость: после создания кортежа его элементы нельзя менять, добавлять или удалять.
	- Допускает разные типы данных.

	tuple = () - объявление пустого кортежа.
	x = tuple() - объявление пустого кортежа.

	Заполнение:

		x = (1243, 23, 82, 0, 'hi')

	x = (12) - не кортеж.
	x = (12, ) - кортеж.

	x = tuple('hello')
	print(x)  // ('h', 'e', 'l', 'l', 'o')

	del x - удалить кортеж.

	x = 5
	y = 10
	x, y = y, x - !
	print(x, y) // 10, 5

Множества (тип set)

	- Неупорядоченность: элементы множества не имеют индексов и порядка, поэтому доступ по индексу невозможен.

	- Изменяемость: можно добавлять и удалять элементы (для типа set).

	- Уникальность элементов: в множестве не может быть повторяющихся значений. При добавлении дубликата он игнорируется.

	- Типы элементов: в множество можно добавлять только неизменяемые типы данных - числа, строки, кортежи. Изменяемые типы (списки, словари, другие множества) нельзя.

	mn = set() - объявление пустого множества. Нельзя использовать пустые фигурные скобки {}, так как они создают пустой словарь.

	1) len(mn) - возвращает количество элементов в множестве.

	2) min(mn) - возвращает минимальный элемент множества.

	3) man(mn) - возвращает максимальный элемент множества.

	4) sorted(s) - возвращает отсортированный список элементов множества (само множество не меняется).

	5) s.add(elem) - добавляет элемент elem в множество.

	6) s.remove(elem) - удаляет элемент elem, вызывает ошибку, если элемента нет.

	7) s.discard(elem) - удалить элемент, если он есть.

	8) s.clear() - очистить множество

	9) s.update(other) - объединение с множеством other.

	10) s.issubset(other) - является ли s подмножеством other или нет.

	11)	s.issuperset(other) - является ли s надмножеством other или нет.

	12) s.union(other) - объединение.

	13) s.intersection(other) - пересечение.

	14) s.difference(other) - разность.

Словари (тип dict)

	Структура данных, хранящая пары ключ -> значение.

	- Изменяемость: можно изменять значения, добавлять и удалять пары.
	- Ключи уникальны: два одинаковых ключа не могут быть.
	- Ключи должны представлять неизменяемые типы данных.

	Пример:

		d = {
		    'dripchik': 'racknut',
		    'perci': 'v puzike',
		    'Z': 'V',
		     96: 69,
		    'EGE': 'Nahuy'
		}

		d = {'a': 1, 'b': 2}

		d = dict(a = 1, b = 2)

	d = {} - пустой словарь

	dict() - встроенная функция для создания словарей.

	Генератор словарей - способ создать словарь из выражения, аналогичный списочным выражениям.

		{ключ: значение for ... if ...}

		Синтаксис: {key_expr: value_expr for item in iterable if condition}

		Пример: d = {x: x*x for x in range(5)}

	zip() - объединяет элементы из нескольких последовательностей попарно.

		d = dict(zip([1, 2, 3, 4], ['one', 'two', 'three', 'four']))

		// {1: 'one', 2: 'two', 3: 'three', 4: 'four'}

	dict.fromkeys() - метод класса dict, который создает новый словарь с заданными ключами, и всем ключам присваивает одно и то же значение (по умолчанию None).

		dict.fromkeys(iterable, value=None)

		- iterable - итерируемый объект (список, кортеж, строка и т.д.) с ключами словаря.
		- value - значение, которое будет присвоено каждому ключу (по умолчанию None).

	Возвращает новый словарь, не изменяя существующий.

	Методы словарей:

		- d.pop(key[, default]) - удаляет ключ и возвращает его значение; если ключа нет и default не указан -> KeyError.
		 -d.popitem() - удаляет и возвращает последнюю пару (ключ, значение).
		- d.clear() - очищает словарь.
		- d.copy - создает копию словаря.
		- d.get(key, default=None) - возвращает значение по ключу или default, если ключа нет.
		- d.setdefault(key, default=None) - возвращает значение ключа; если ключа нет, создаёт его с default.
		- d.update(other) - обновляет словарь парами из другого словаря или итерируемого объекта.
		- d.keys() - возвращает view-объект всех ключей.
		- d.values() - возвращает view-объект всех значений.
		- d.items() - возвращает view-объект всех пар (ключ, значение).

Строки (тип str)

	В Python строки можно сравнивать с помощью операторов <, <=, >, >= — лексикографически, то есть по алфавиту (посимвольно).

	/n - переход на новую строку.
	/t - табуляция (отступ).

	Строки можно складывать(конкатенация) и умножать на число.

	.upper() - переводит все символы в верхний регистр.
	.lower() - переводит все символы в нижний регистр.
	.title() - каждое слово с заглавной буквы.

	.find(substring) - находит индекс первого вхождения подстроки (или -1, если не найдено).
	.rfind(substring) - то же, но ищет справа налево.
	.index(substring) - как find(), но вызывает ошибку если не найдено.

	replace() - функция, использующаяся для замены подстрок в строке. Она возвращает новую строку, в которой все вхождения указанной подстроки заменяются на другую подстроку. 

	строка.replace(old, new, [count])

		- old: Подстрока, которую нужно заменить
		- new: Подстрока, на которую нужно заменить old
		- count (необязательный параметр): Количество замен, которые необходимо выполнить. Если этот параметр не указан, заменяются все вхождения old.

			txt = 'one one one one'
			txt = txt.replace('one', '1234', 3)
			print(txt) // 1234 1234 1234 one

	count() - функция, которая позволяет подсчитывать количество вхождений определенного элемента в списке или подстроки в строке.

	s = [1,1,1,1,1,5,5,2,6,3,2,2,3,2,52]
	print(s.count(1)) // 5

	.startswith(substring) - начинается ли строка с подстроки.
	.endswith - заканчивается ли строка подстрокой.

	.isdigit() - содержит ли только цифры.
	.isalpha() - содержит ли только буквы.

	.split() - разбивает строку на список подстрок, используя разделитель. По умолчанию - любой пробел, табуляция или перевод строки.

	.strip() - удаляет пробелы и другие указанные символы в начале и в конце строки.

	len()

Аргументы функции print():

	- sep - строка, вставляемая между элементами при выводе. Например:

		sep = ' # '

	- end - строка, добавляемая в конце ввода. По умолчанию завершает вывод переводом строки (\n). Но можно изменить поведение:

		end = ' '

	f - f-строка - позволяет вставлять значения переменных прямо в текст через {}.

	r - raw-строка - не обрабатывает спецсимволы (\n, \t)

Файлы

	open() - функция, позволяющая открывать файлы, чтобы читать, записывать и создавать их.

	.close() - метод, использующийся для закрытия файла, который был открыт с помощью функции open().

	.readline() - метод, использующийся для чтения одной строки из файла.	

input()

	input() - функция для получения данных от пользователя. 

	name = input()
	print(name) - простой ввод строки.

	name = input("write your name pls: ")
	print(name) - ввод с подсказкой.

	age = int(input("write you age: "))
	print(age) - ввод целого числа.

range() - функция, использующаяся для генерации последоватености целых чисел в определенном диапазоне. 

	Агрументы:

		- start: Начальное значение последовательности (0 по умолчанию)

		- stop: Конечное значение последовательности.

		- stop: Шаг изменения значения (по умолчанию 1)

		arr = []
		for i in range(5, 40, 2):
    		arr.append(i)
		print(arr) // [5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39]

Списочные выражения - мощный инструмент Python для создания списков с помощью компактного и читаемого синтаксиса. Они позволяют пользователю быстро и эффективно генерировать списки с применением преобразований или фильтрации.

	Синтаксис: 

		[выражение for элемент in итерируемый объект if условие] 

	    - выражение - значение, которое мы добавляем в список.

	    - for элемент in итерируемый объект - цикл, который проходит по каждому элементу в итерируемом объекте (например, списке, строке, диапазоне). Под итерируемым объектом подразумеваются структуры в Python, которые можно перебрать циклом for (строки, множества, списки, результат работы функции range() и т.д.)

	    - if условие (опционально, т.е. не обязательно) — фильтр, который определяет, нужно ли включать элемент в новый список.


	arr = [i for i in range(20)] 
	print(arr) // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19] - простой способ

	arr = [i for i in range(1, 82) if i % 3 == 0]
	print(arr) // [3, 6, 9, 12, 15, 18, 21, 24, 27] - c условием

	arr = [i**2 if i % 2 == 0 else i**3 for i in range(1, 100)] - условие: вывод чисел от 1 до 100 в квадрате, если число четне, а если нет - в кубе.

min() - функция Python, которая возвращает наименьший элемент из переданных ей аргументов или из элементов итерируемого объекта (список, кортеж, строка и др.).

	Аргументы:

		- iterable - итерируемый объект (обязательный, если передан только один аргумент).

		- arg1, arg2, ... - два и более позиционных аргумента (обязательны, если не передан iterable).

		- key - функция для вычисления критерия сравнения (необязательный).

		- default - значение по умолчанию, возвращается если iterable пуст (необязательный, только для iterable).

	a = [1, 2, 3, 4, 5, 16, 0.5]
	print(min(a)) # 0.5 - минимальное число.

	a = ['hello', 'python', 'java', 'timetable']
	print(min(a, key=len)) # java - минимальный элемент строки по длине.

	a = ['hello', 'python', 'java', 'timetable']
	print(min(a)) # hello - минимальная строка по алфавиту.

	a = []
	print(min(a, default = 'zero')) # zero - использование default для пустого списка.

max() - аналогично min().

/ - оператор деления.
// - оператор целочисленного деления.
//= - оператор присваивания с целочисленным делением.

Возведение в степень: 
	
	- оператор ** | result = 2 ** 3 // 8
	- функция pow() | result = pow(2, 3) // 8
	- функция math.pow() - возвращает результат в виде вещественного числа (необходимо импортировать библиотеку) | result = math.pow(2, 3) // 8.0

import math:

	math.round() - используется для округления чисел до заданного количества десятичных знаков или до ближайшего целого числа, если количество знаков не указано.

		- number -  число, которое нужно округлить (float или int).

		- digits - количество знаков после запятой, до которого нужно округлить. По умолчанию - 0.

	math.ceil() - округление вверх.

	math.floor() - округление вниз.

	math.trunc() - отбрасывает дробную часть.

	math.prod() - функция для нахождения произведения элементов итерируемого объекта.

	math.sqrt() - функция, которая возвращает квадратный корень числа.

	math.log2() - вычисляет логарифм числа по основанию 2.

sum() - встроенная функция, предназначенная для вычисления суммы всех элементов в итерируемом объекте, таком как список или кортеж.

str() - используется для преобразования объекта в его строковое представление. Она может работать с различными типами данных, такими как целые числа, числа с плавающей точкой, строки и даже байтовые объекты.

int() - используется для преобразования объекта в целое число. Она может принимать один или два аргумента.

	int(value, base)

	- value - обязательный аргумент, который может быть числом, строкой или байтовым объектом.

	- base - Необязательный аргумент, указывающий систему счисления, в которой находится значение. По умолчанию — 10. Поддерживаются основания от 2 до 36 включительно. Это позволяет преобразовывать строки из различных систем счисления в десятичные целые числа.

bin() - используется для преобразования целого числа в его двоичное (бинарное) представление в виде строки.

	1- выведет 0b1001. Префикс 0b указывает на то, что далее число идет в двоичной системе. Чтобы избавится от префикса, необходимо использовать срез: [2:].

Перевести число в двоичную систему счисления можно и с помощью f-строк:

	n = 13
	binary = f"{n:b}"
	print(binary)  # 1101

	Формат :b означает «вывести число в двоичной системе».

	binary = f"{n:08b}" - перевод в двоичную систему счисления с ведущими нулями (8 бит в данном случае).

oct() - используется для перевода числа в восьмеричную систему счисления (представление в виде строки). Выводит значение с префиксом, как и в случае с bin().

hex() - используется для перевода числа в шестнадтатеричную систему счисления (представление в виде строки). Выводит значение с префиксом, как и в случае с bin().

abs() - функция, возвращающая модуль (абсолютное значение) числа - число без учета знака.

replace() - функция, использующаяся для замены подстрок в строке. Она возвращает новую строку, в которой все вхождения указанной подстроки заменяются на другую подстроку. 

	строка.replace(old, new, [count])

		- old: Подстрока, которую нужно заменить
		- new: Подстрока, на которую нужно заменить old
		- count (необязательный параметр): Количество замен, которые необходимо выполнить. Если этот параметр не указан, заменяются все вхождения old.

			txt = 'one one one one'
			txt = txt.replace('one', '1234', 3)
			print(txt) // 1234 1234 1234 one

count() - функция, которая позволяет подсчитывать количество вхождений определенного элемента в списке или подстроки в строке.

	s = [1,1,1,1,1,5,5,2,6,3,2,2,3,2,52]
	print(s.count(1)) // 5

join(i) - используется для объединения элементов итерируемого объекта (например, списка, кортежа или строки) в одну строку, используя заданный разделитель. Этот метод вызывается на строке-разделителе, а в качестве аргумента передается итерируемый объект.

	separator.join(iterable)

	- separator: строка, которая будет использоваться в качестве разделителя между элементами.

	- iterable: итерируемый объект, элементы которого будут объединены.

	m = '27589362185729125'
	d = " = ".join(m)
	print(d) // 2 = 7 = 5 = 8 = 9 = 3 = 6 = 2 = 1 = 8 = 5 = 7 = 2 = 9 = 1 = 2 = 5

	r = ''.join(r) - объединение (склеивание) всех элементов последовательности r в одну строку.

	! Все элементы итерируемого объекта должны быть строками.

	! Метод join() возвращает новую строку, не изменяя исходные данные.

all() - возвращает True, если все элементы переданного ей итерируемого объекта являются истинными. Если хотя бы один элемент ложен, возвращается False.

		a = [True, True, True, False]
		print(all(a)) // False

bool(someValue) - функция, приводящая переменные разных типов к булевому значению. 

		a = [1, 1.5, 13541, 0, "", "45", [], {}]
		b = [1, 1.5, 13541, 5, "124", "45", [2], {''}]
		print(all(a), all(b)) // False True

any() - возвращает True, если хотя бы один элемент переданного ей итерируемого объекта является истинным. Если все элементы ложны, возвращается False.

		a = [1, 1.5, 13541, 0, "", "45", [], {}]
		print(any(a)) // True

print(*range(1, 11)) - выведет числа от 1 до 10 через пробел: 1 2 3 4 5 6 7 8 9 10.

	- range(1, 11) - последовательность чисел от 1 до 10.
	- * - распаковывает элементы последовательности в отдельные аргументы для функции print()
	Без звёздочки код print(range(1, 11)) вывел бы сам объект range: range(1, 11).

from itertools import *

	Модуль itertools в Python предоставляет набор высокоэффективных функций для работы с итераторами и создания сложных схем перебора данных. Импортировать все функции модуля можно через конструкцию: from itertools import *

itertools.product() - функция, которая вычисляет декартово произведение переданных последовательностей (все возможные комбинации элементов из нескольких последовательностей).

	- iterables — один или несколько итерируемых объектов (например, списки, строки, кортежи).

	- repeat (по умолчанию 1) - сколько раз повторять каждый итерируемый объект.

	import itertools
	numbers = [0, 1]
	for i in itertools.product(numbers, repeat = 3): print(i)

	Вывод:
		(0, 0, 0)
		(0, 0, 1)
		(0, 0, 1)
		(0, 1, 0)
		(0, 1, 1)
		(0, 1, 1)
		(0, 1, 0)
		(0, 1, 1)
		(0, 1, 1)
		(1, 0, 0)
		...

	В данном случае переменная i - кортеж, содержащий одну комбинацию.

	- элементы повторяются.
	- порядок важен.

itertools.permutations() - предназначена для генерации всех возможных перестановок (пермутаций) элементов заданного итерируемого объекта. Перестановка - это упорядоченное размещение элементов, где важен порядок и не допускаются повторения в рамках одной перестановки.

	import itertools
	numbers = [0, 1, 1]
	for i in itertools.permutations(numbers): print(i)

	Вывод:
		(0, 1, 1)
		(0, 1, 1)
		(1, 0, 1)
		(1, 1, 0)
		(1, 0, 1)
		(1, 1, 0)
 
	Аргументы:

		1) сама последовательность (список, строка, кортеж).
		2) длина перестановки.

	- элементы не повторяются.
	- порядок важен.

itertools.combinations() - функция, которая генерирует все возможные сочетания указанной длины из элементов последовательности без повторений и без учёта порядка.

	Сочетания (combinations) — это выбор k элементов из n без учёта порядка.

		- порядок не важен.
		- элементы не повторяются.
		- (1, 2) и (2, 1) считаются одним и тем же сочетанием.

	from itertools import combinations
	list(combinations([1, 2, 3], 2))

	результат: [(1, 2), (1, 3), (2, 3)]

	- (1, 2) и (2, 1) считаются одинаковым набором → оставляют только (1, 2).

	- Повторы элементов отсутствуют.

fnmatch() - функция из модуля fnmatch, позволяющая сравнивать строки с шаблонами.

	Функция fnmatch(string, pattern) сравнивает строку string с заданным шаблоном pattern и возвращает True при совпадении и False в противном случае. 

	При написании шаблона можно использовать следующие метасимволы:

		- * - задает любую последовательность символов.
		- ? - задает ровно один символ.
		- [] - задает любой символ из данного набора.

random - стандартный модуль Python для генерации псевдослучайных чисел и выбора случайных элементов из коллекций.

	Основные функции модуля random:

		- random() -  возвращает случайное число с плавающей точкой в диапазоне [0.0, 1.0).
		- randint(a, b) - возвращает случайное целое число N, a <= N <= b.
		- randrange(start, stop, step) - возвращает случайное целое из заданного диапазона с указанным шагом.
		- choice(seq) - выбирает случайный элемент из непустой последовательности (списка, строки и т.п.).
		- shuffle(x) - перемешивает элементы списка на месте.

map() - используется для применения заданной функции к каждому элементу итерируемого объекта (например, списка) и возвращает итератор с результатами.

	map(function, iterable)

		- function - функция, которую нужно применить к элементам.
		- iterable - один или несколько итерируемых объектов (списки, кортежи и т.д.).

	В Python3 map() возвращает не список, а итерируемый объект (итератор). Чтобы получить список, нужно обернуть результат в list().

* - распаковка с помощью * (звёздочки) позволяет развернуть набор данных - список, кортеж, множество или другую итерируемую последовательность - в отдельные элементы.

0.1 - число с плавающей точкой (float).
0,1 - кортеж из двух целых чисел (tuple: 0 и 1).

is_integer() - это метод объекта типа float. Он возвращает True, если значение числа с плавающей точкой (float) является целым (то есть дробная часть равна нулю), и False - если нет.

isinstance() - встроенная функция Python, которая позволяет определить, относится ли объект к определенному типу (или кортежу типов).

	Синтаксис: isinstance(obj, type)
	Или: isinstance(obj, (type1, type2, ...))

В Python True и False ведут себя как числа:
	
	True = 1
	False = 0

	True + True = 2

Распаковка переменных в цикле for

	Распаковывать можно любой итерируемый объект, у которого есть несколько элементов:

		- кортеж (a, b)
		- список [x, y]
		- строку "AB"
		- пары, приходящие из .items() и т. д.

	Python ожидает, что каждая итерация возвращает ровно столько элементов, сколько переменных указано.

	Общий синтаксис:

		for x, y in iterable: 
			...

	Это значит: на каждой итерации берётся элемент из iterable и разбивается на две части, которые сохраняются в x и y.

Функция - это отдельная процедура, которую можно вызвать "сама по себе", независимо от объектов.
Она существует сама по себе и не привязана к конкретному объекту.

Метод - инструмент (умение) самого объекта.

Функция - блок кода, который выполняет определённое действие и может быть вызван много раз без повторения самого кода.

	return - оператор в Python, который возвращает результат из функции и завершает её выполнение.

	Параметры - имена переменных внутри объявления функции. То, что функция ожидает получить. 
	Параметры - как пустые слоты, куда потом вставляют значения.

	Аргументы - конкретные значения, которые мы передаем функции при вызове.
	Аргументы - реальные значения, которые попадают в параметры.

Рекурсивная функция - функция, которая вызывает сама себя, пока не достигнет базового случая (условия остановки). Рекурсия используется, когда задача естественно делится на более маленькие подзадачи.	

	def f(x, y):
		d = x + y;
		if x % 2 == 0:
		    return d
		else:
			return f(x + 1, y * 3)
	print(f(3 , 4))	

Значение максимальной глубины рекурсии по умолчанию установлено на уровне 10001000, поэтому при попытке вызова рекурсивной функции с глубиной больше, чем 10001000 (иногда 10241024), на экран выведется соответствующая ошибка.

import sys
sys.setrecursionlimit(10**6) - строка кода используется для установки максимальной глубины рекурсии в программе.
						       Устанавливает максимальную глубину рекурсии на 106106 (1 миллион) вызовов. Это означает, что рекурсивные функции в программе могут вызывать себя до 1 миллиона раз, прежде чем будет сгенерировано исключение. По умолчанию Python имеет ограничение на глубину рекурсии, обычно около 1000 вызовов.

@lru_cache - декоратор из модуля functools, который запоминает результаты вызовов функции. Он позволяет ускорять рукурсивные функции, чтобы они не пересчитывали одно и то же много раз.

Модуль ipaddress - стандартная библиотека Python. Позволяет работать с ipv4/ipv6 адресами, сетями и интерфейсами: парсить, сравнивать, выполнять арифметику, проверять принадлежность и пр.

	ip_network() - функция, которая создает объект сети (ipv4 или ipv6). Она парсит строку вида "адрес/маска" и возвращает IPv4Network или IPv6Network.

		Аргументы:

			- address - строка или число.
			- strict (по умолчанию True) - строгий режим.

			Строгий режим (strict = True) - адрес должен быть адресом сети, иначе будет ошибка.
			Нестрогий режим (strict - False) - любой IP приводится к адресу сети автоматически.

		Атрибуты:

			- .network_address - адрес сети
			- .broadcast_address - широковещательный адрес (ipv4)
			- .netmask - маска сети.
			- .prefixlen - длина префикса.
			- .num_addresses - общее количество ip в сети.

		.hosts() - возвращает все допустимые адреса хостов сети, исключая адрес сети и широковещательный адрес.

	Структуры данных в ipaddress:

		- IPv4Address - один IPv4-адрес.
		- IPv6Address - аналогично, но для IPv6.

		- IPv4Network - описывает подсаеть IPv4.



---------------------------------------------------------------------------------

a, b, c =  1, 2, 3 - множественное присваивание.

a = b = c = 5 - каскадное присваивание.

/ - оператор деления.
// - оператор целочисленного деления.
//= - оператор присваивания с целочисленным делением.

elif - сокращение от else if, и используется в условных конструкциях, чтобы проверить дополнительные условия, если предыдущие оказались ложными.

type() - возвращает объект класса type, который описывает тип данных переданного значения.  

is - оператор, который используется для проверки тождественности объектов, то есть - указывают ли две пероеменные на один и тот же объект в памяти.

	Разница между is и ==:

		- == сравнивает значения объектов (содержимое).
		- is сравнивает идентичность объектов (адрес в памяти).

is not - оператор не идентичности.

in - элемент находится в последовательности.

not in - элемент не находится в последовательности.

if else в одну строку: x if условие else y

elif (else if) - оператор ветвления когда нужно проверить несколько условий подряд.
	
	Как работает:

		- сначала проверяется if.
		- если он ложный, проверяется первый elif.
		- если и он ложный - следующий elif и так далее.
		- если ни одно условие не выполнилось - выполняется else (если он есть).

Атрибуты - данные или методы, которые принадлежат объекту (экземпляру класса, самому классу или модулю) и доступны через точку.

	объект.атриубут