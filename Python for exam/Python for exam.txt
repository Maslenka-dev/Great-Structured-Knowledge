2 

	print ('x y z w')
	for x in 0,1:
	    for y in 0,1:
	        for z in 0,1:
	            for w in 0,1:
	                if (x or (not y)) and (not(x == z) and (not w)) == 1:
	                    print(x, y, z, w)

    x y z w
	0 0 1 0
	1 0 0 0
	1 1 0 0	


	print ('x y z w')
	for x in 0,1:
	    for y in 0,1:
	        for z in 0,1:
	            for w in 0,1:
	                if (((x and w) or (w and z)) == ((z <= y) and (y <= x))) == 1:
	                    print(x, y, z, w)

	x y z w
	0 0 1 0
	0 1 0 0
	0 1 0 1
	0 1 1 0
	1 0 0 1
	1 0 1 0
	1 1 0 1
	1 1 1 1   


	print ('x y z w')
	for x in 0,1:
	    for y in 0,1:
	        for z in 0,1:
	            for w in 0,1:
	                if ((y <= w) == (x <= (not z)) and (x or w)) == 1:
	                    print(x, y, z, w)      

	print ('x y z w')
	for x in 0,1:
	    for y in 0,1:
	        for z in 0,1:
	            for w in 0,1:
	                if ((y <= w) == (x <= (not z)) and (x or w)) == 0:
	                    print(x, y, z, w)          
    
	x y z w     0
	0 0 0 0
	0 0 1 0
	0 1 0 0
	0 1 1 0 
	1 0 1 0
	1 0 1 1
	1 1 0 0
	1 1 1 1

	x y z w     1
	0 0 0 1
	0 0 1 1
	0 1 0 1
	0 1 1 1
	1 0 0 0
	1 0 0 1
	1 1 0 1
	1 1 1 0

13 (сложный вариант)

		import itertools
		count = 0
		s = itertools.product([0, 1], repeat = 20)
		for i in s:
		    if (5 + sum(i)) % 5 != 0:
		        count += 1
		print(count)

	количество единиц в двоичной записи IP-адреса не кратно 5

	Использование функции itertools.product() с параметром repeat=20 для списка [0, 1] создаст все возможные комбинации длиной 20, состоящие из элементов 0 и 1. Это эквивалентно генерации всех двоичных чисел от 00000000000000000000 до 11111111111111111111.


		import itertools
		count = 0
		s = itertools.product([0, 1], repeat = 13)
		for i in s:
		    if i[12] == 1 and i[11] == 1:
		        if(10 + sum(i)) % 3 == 0:
		            count += 1
		print(count)

	количество единиц в двоичной записи IP-адреса кратно 3, а сама двоичная запись оканчивается на 11

16

	Условие: F(1) = 1 | F(2) = 1 | если n > 2, то F(n-1) * n - 2 * F(n-2)

		def F(n):
	    if n == 1:
	        return 1
	    if n == 2:
	        return 1
	    if n > 2:
	        return F(n-1) * n - 2 * F(n-2)
		print(F(6))

	Условие: F(n) = 1 если n = 1 | F(n) = n + F(n - 1) если n нечетно | F(n) = 2 * F(n - 2) если n > 1 и n нечетно

		def F(n):
	    if n == 1:
	        return 1
	    if n % 2 == 0:
	        return n + F(n - 1)
	    if n > 1 and n % 2 != 0:
	        return 2 * F(n - 2)
		print(F(26)) 


	F(n div 10) + (n mod 10) - функция, расчитывающая сумму цифр числа n.

	Условие: F(0) = 0 | F(n) = F(n div 10) + (n mod 10) | Укажите количество таких чисел n из интервала 765432019 <= n <= 1542613239 для которых F(n) > F(n + 1).

		Решение: Данная функция считает сумму цифр числа n. Необходимо определить в каких случаях сумма цифр в числе больше у меньшего числа. Это возможно только в одном случае, когда число оканчивается на цифру 9. В таком случае разряд увеличивается и сумма цифр следующего числа будет меньше суммы чисел предыдущего (Пример: число 239, сумма цифр 14, следующее число 240, сумма цифр 6). Первое такое число в данном интервале 765432019, далее можно посчитать все остальные числа с шагом 10. Таких чисел будет:

			s = 0
			for i in range(765432019, 1542613239 + 1, 10):
			    s += 1
			print(s) # 77718123

	Условие: 

		F(0) = 0;
		F(n) = F(n / 2), если n > 0 и при этом n чётно; 
		F(n) = 1 + F(n − 1), если n нечётно.
		Назовите минимальное значение n, для которого F(n) = 12.

			def f(n):
			    if n == 0: return 0
			    if n % 2 == 0 and n > 0: return f(n / 2)
			    if n % 2 != 0: return 1 + f(n - 1)
			i = 0
			while f(i) != 12: i += 1
			print(i)		

	Условие:

		F(0) = 0;
		F(n) = F(n / 2), если n > 0 и при этом чётно;
		F(n) = 1 + F(n − 1), если n нечётно.

		Сколько существует таких чисел n, что 1 <= n <= 1000 и F(n) = 3?

			def f(n):
			    if n == 0: return 0
			    if n > 0 and n % 2 == 0: return f(n / 2)
			    if n % 2 != 0: return 1 + f(n - 1)
			k = 0
			for n in range(1, 1001):
			    if f(n) == 3: k += 1
			print(k)		

	Условие: F(n) = 1 если n <= 5 | F(n) = n + F(n - 2) если n > 5.

		import sys
		sys.setrecursionlimit(10**8)
		def f(n):
		    if n <= 5: return 1
		    if n > 5: return n + f(n - 2)
		print(f(2126) - f(2122))  // 4250

	Альтернативный вариант решения 16 задания:

		Условие: F(n) = 1 если n <= 5 | F(n) = n + F(n - 2) если n > 5.

			f = {}
			for n in range(1, 2200, 1):
			    if n <= 5: f[n] = 1
			    if n > 5: f[n] = n + f[n - 2]
			print(f[2126] - f[2122])  // 4250		

14

	Условие: 4 * 343 ** 5 + 6 * 49 ** 8 - 50 | Система счисления: 7. Сколько цифр 6 содержится в записи?

		x = 4 * 343 ** 5 + 6 * 49 ** 8 - 50
		s = ''
		while x != 0: 
		    s += str(x % 7) // остаток от деления на 7 прибавляется к s (перевод x в семеричную систему)
		    x //= 7 // целочисленное деление на 7 (перевод x в семеричную систему)
		s = s[::-1] // разворот строки 
		print(s.count('6')) // подсчет цифр 6

    Операции в одной СС

		Условие: 98x79641 + 25x49 + 63x5 | основание системы - 22 | ! наименьшее x если 98x79641 + 25x49 + 63x5 кратно 21 | основание системы для x - 15

			for x in '0123456789abcde':
		    x1 = '98' + str(x) + '79641'
		    x2 = '25' + str(x) + '49'
		    x3 = '63' + str(x) + '5'
		    res = int(x1, 22) + int(x2, 22) + int(x3, 22)
		    if res % 21 == 0:
		        res = res // 21
		        print(res)
		        break

	    Условие 98x79641 + 36x14 + 73x4 | основание системы - 19 | ! наибольшее x если 98x79641 + 36x14 + 73x4 кратно 18 | основание системы для x - 10 

		    for x in '0123456789abcdefghi':
		    x1 = '98' + str(x) + '79641'
		    x2 = '36' + str(x) + '14'
		    x3 = '73' + str(x) + '4'
		    res = int(x1, 19) + int(x2, 19) + int(x3, 19)
		    if res % 18 == 0:
		        print(res // 18) // 470402599   	

	    Условие: 123xAB3 + 3CEx321 | основание системы - 31 | ! наибольшее x если 123xAB3 + 3CEx321 кратно 17 | основание системы для x - 10

		    for x in range(31):
		    x1 = 1*31**6+2*31**5+3*31**4+x*31**3+10*31**2+11*31**1+3*31**0 // перевод из 31-чной в 10-чную
		    x2 = 3*31**6+12*31**5+14*31**4+x*31**3+3*31**2+2*31**1+1*31**0
		    res = x1 + x2
		    if (res) % 17 == 0:
		        print(res // 17)

	    Условие: F29x8EAD637 * BAxDE0C1B37  | основание системы - 37 | ! наибольшее x если 123xAB3 + 3CEx321 кратно 17 | основание системы для x - 10

		    for x in range(37, 0, -1):
		    x1 = 15*37**8 + 2*37**7 + 9*37**6 + x*37**5 + 8*37**4 + 14*37**3 + 10*37**2 + 13*37 + 6
		    x2 = 11*37**8 + 10*37**7 + x*37**6 + 13*37**5 + 14*37**4 + 0*37**3 + 12*37**2 + 1*37 + 11
		    if (x1 * x2) % 36 == 0:
		        print(1*37**2 + x*37 + 2)

		    	или

		    for x in range(37):
		    x1 = 15*37**8 + 2*37**7 + 9*37**6 + x*37**5 + 8*37**4 + 14*37**3 + 10*37**2 + 13*37 + 6
		    x2 = 11*37**8 + 10*37**7 + x*37**6 + 13*37**5 + 14*37**4 + 0*37**3 + 12*37**2 + 1*37 + 11
		    if (x1 * x2) % 36 == 0:
		        print(1*37**2 + x*37 + 2)

	   	Условие: AB267D1 + F024A89 | основание системы - p | ! наименьшее p при котором AB267D1 + F024A89 будет делиться на p - 1 | основание системы для x - 10

		    for p in range(16, 1000):		// Так как F - 15, p > 15
		    x1 = 10*p**6 + 11*p**5 + 2*p**4 + 6*p**3 + 7*p**2 + 13*p**1 + 1
		    x2 = 15*p**6 + 0*p**5 + 2*p**4 + 4*p**3 + 10*p**2 + 8*p**1 + 9
		    if(x1 + x2) % (p - 1) == 0:
		        print(p) 

	    Условие: zxyx4 + xy658 = wzx73 | основание системы - p | ! Определить значение xyzw в десятичной системе

			for p in range(9, 100):			// Так как в выражении xy658 есть цифра 8, p > 8
			    for x in range(1, p):
			        for y in range(1, p):
			            for z in range(1, p):
			                for w in range(1, p):
			                    x1 = z*p**4+x*p**3+y*p**2+x*p**1+4
			                    x2 = x*p**4+y*p**3+6*p**2+5*p**1+8
			                    x3 = w*p**4+z*p**3+x*p**2+7*p**1+3
			                    if (x1 + x2) == x3:
			                        print(x*p**3 + y*p**2 + z*p**1 + w)  

	Операции в одной СС с разными переменными

		Условие: В числе 57x692y1940 x и y обозначают некоторые цифры из алфавита системы счисления с основанием 40. Определите такие значения x и y, при которых приведённое число кратно 39, а число yx40 является полным квадратом. В ответе запишите значение числа yx40 в десятичной системе счисления.
	
			for x in range(40):
			    for y in range(40):
			        s = 5*40**8 + 7*40**7 + x*40**6 + 6*40**5 + 9*40**4 + 2*40**3 + y*40**2 + 1*40**1 + 9
			        if s % 39 == 0 and (y*40**1 + x) ** 0.5 == round((y*40**1 + x) ** 0.5): print(y*40**1 + x)

	Операции в разных СС с одной переменной

		Условие: 2x84(19) + 2B3x(16) | ! Определить наименьшее значение x при котором значение 2x8419(19) + 2B3x16(16) кратно 88 | Для найденного x вычислите частное от деления на 88 в десятичной системе

			for x in range(16):
			    x1 = 2*19**3 + x*19**2 + 8*19**1 + 4
			    x2 = 2*16**3 + 11*16**2 + 3*16**1 + x
			    if (x1 + x2) % 88 == 0:
			        print((x1 + x2) // 88)		

		Условие: 8x71(13) + 3xDF(17) | ! Определить наименьшее значение x при котором значение 8x71(13) + 3xDF(17) кратно 197 | Для найденного x вычислите частное от деления на 197 в десятичной системе

			for x in range(10):
			    x1 = 8*13**3 + x*13**2 + 7*13 + 1
			    x2 = 3*17**3 + x*17**2 + 13*17 + 15
			    if (x1 + x2) % 197 == 0:
			        print((x1 + x2) // 197)

    Операции в разных СС с двумя переменными

    	Условие: x231y(12) + 78x98y(14) | ! Определить наименьшее значение x и y при котором значение x231y(12) + 78x98y(14) кратно 99 | Для найденного x и y вычислите частное от деления на 99 в десятичной системе

	    	for x in range(12):
			    for y in range(12):
			        x1 = x*12**4 + 2*12**3 + 3*12**2 + 1*12 + y  
			        x2 = 7*14**5 + 8*14**4 + x*14**3 + 9*14**2 + 8*14 + y
			        if (x1 + x2) % 99 == 0:
			            print((x1 + x2) // 99)

7

	Условие: Книгу объёмом 1 Мбайт записали как аудиокнигу. Запись велась в формате стерео (2 канала) с частотой 48 кГц и разрешением 24 бит. За одну минуту записывалось в среднем 1,5 Кбайт текста. Сжатие данных позволило сократить размер полученного звукового файла на 84%. Для удобства использования запись разделили на фрагменты со средним размером 15 Мбайт. Определите количество полученных фрагментов.

		x = 1 * 1024 * 1024 * 8
		x2 = 1.5 * 1024 * 8
		i = 2
		f = 48 * 1000
		l = 24
		m = (x / x2) * 60
		res = m * l * f * i
		res2 = res * 0.16
		print(res2 / (15 * 1024 * 1024 * 8))	// 120

19, 20, 21

	!!Строчка [s for s in range(1, 57) if f(s, 2)] - эта конструкция называется "генератор". Это способ в одну строку создать список (массив), наполненный значениями. Двоеточия нет именно потому, что это не цикл for, а генератор.

	ЗАПОМНИТЬ! Поменять all(moves) на any(moves) в случае если в 19 задании спрашивают (после неудачного хода пети), но для 20 и 21 меняем обратно на all(moves).




	19) Условие: одна куча | stop 56 | + 1 | +2 | *2| петя даун. Ваня выиграл своим первым ходом после неудачного первого хода Пети

		def f(x, h):
		    if x >= 56:
		        return h % 2 == 0
		    if h == 0:
		        return False 
		    moves = [f(x + 1, h - 1), f(x + 2, h - 1), f(x * 2, h - 1)]
		    if h % 2 != 0:
		        return any(moves)  
		    else:
		        return any(moves)  

		print([s for s in range(1, 57) if f(s, 2)]) // [14]

		Если в 19 задании спрашивается победа Вани или Пети после НЕУДАЧНОГО ХОДА противника, необходимо в 10 строчке поменять all на any. В 20 и 21 заданиях не трогаем эту строку.

	55815) Условие: одна куча | stop 78 | + 1 | +4 | * 4 |  

		def f(x, h): 
		    if x >= 78: 
		        return h % 2 == 0 
		    if h == 0: 
		        return 0 
		    moves = [f(x + 1, h - 1), f(x + 4, h - 1), f(x * 4, h - 1)] 
		    if h % 2 != 0: 
		        return any (moves) 
		    if h % 2 == 0: 
		        return all(moves) 
		print([s for s in range(1, 79) if f(s, 2)]) 
		print([s for s in range(1, 79) if not f(s, 1) and f(s, 3)]) 
		print([s for s in range(1, 79) if (f(s, 2) or f(s, 4)) and not f(s, 2)]) 

		// [19, 78]
		   [15, 18]
		   [14, 17]

	27780) Условие: две кучи | stop 74 | 1 <= s <= 61 | + 1 | * 2 | 

		def f(x, y, h):
		    if x + y >= 74:
		        return h % 2 == 0
		    if h == 0:
		        return 0
		    moves = [f(x + 1, y, h - 1), f(x * 2, y, h - 1), f(x, y + 1, h - 1), f(x, y * 2, h - 1)]
		    if h % 2 != 0:
		        return any(moves)
		    else:
		        return all(moves) // с заменой
		print([s for s in range(1, 62) if f(12, s, 2)])
		print([s for s in range(1, 62) if not f(12, s, 1) and f(12, s, 3)])
		print([s for s in range(1, 62) if (f(12, s, 2) or f(12, s, 4)) and not f(12, s, 2)])

		// [16] // с заменой all(moves) на any(moves)
		   [24, 30]
		   [29]

	Если есть условие добавления камней в МЕНЬШУЮ кучу:

		def f(x, y, h):
			if x + y >= 61: return h % 2 == 0
			if h == 0: return 0
			if y > x: // если x - меньшая куча
				moves = [
				f(x + 1, y, h - 1),
				f(x + 2, y, h - 1),
				f(x * 2, y, h - 1)
				]
			else: moves = [ // соответственно, если y - меньшая куча 
				f(x, y + 1, h - 1),
		        f(x, y + 2, h - 1),
				f(x, y * 2, h - 1)
		        ]
			if h % 2 != 0: return any(moves)
			else: return all(moves) 

		print([s for s in range(1, 53) if not f(8, s, 1) and f(8, s, 2)])
		print([s for s in range(1, 53) if not f(8, s, 1) and f(8, s, 3)])
		print([s for s in range(1, 53) if (f(8, s, 2) or f(8, s, 4)) and not f(8, s, 2)])	

	Условие: За один ход игрок может добавить в большую кучу любое количество камней от одного до трёх или удвоить количество камней в меньшей куче. Если кучи содержат равное количество камней, можно добавить в любую из них от одного до трёх камней, удвоение в этой ситуации запрещено.

		def f(x, y, h):
			if x + y >= 41: return h % 2 == 0
			if h == 0: return 0
			if y > x:
				moves = [
		 		f(x, y + 1, h - 1),
				f(x, y + 2, h - 1),
				f(x, y + 3, h - 1),
				f(x * 2, y, h - 1)
					]
			else: moves = [
				f(x + 1, y, h - 1),
		        f(x + 2, y, h - 1),
				f(x + 3, y, h - 1),
				f(x, y * 2, h - 1),
		        ]
			if x == y: moves = [
				f(x + 1, y, h - 1),
		        f(x + 2, y, h - 1),
				f(x + 3, y, h - 1),
		        ]
			if h % 2 != 0: return any(moves)
			else: return all(moves) 

		print([s for s in range(1, 24) if f(17, s, 4) and not f(17, s, 2)])				 

	Условие: Известно, что Петя смог выиграть первым ходом. Какое наименьшее число камней могло быть суммарно в двух кучах?

		a = []
		for x in range(1, 20):
			for y in range(1, 20):
				if f(x, y, 1) == 1: a.append(x + y)
		print(min(a))

	Условие: За один ход игрок может: убрать из кучи два камня или убрать из кучи пять камней или уменьшить количество камней в куче в три раза (количество камней, полученное при делении, округляется до меньшего). Игра завершается, когда количество камней в куче становится не более 19. Победителем считается игрок, сделавший последний ход, то есть первым получивший кучу, в которой будет 19 или меньше камней. Петя не может выиграть за один ход, но при любом ходе Пети Ваня может выиграть своим первым ходом.

		import math
		def f(x, h):
		    if x <= 19: return h % 2 == 0
		    if h == 0: return False
		    moves = [f(x - 2, h - 1), f(x - 5, h - 1), f(math.floor(x // 3), h - 1)]
		    if h % 2 != 0: return any(moves)
		    else: return any(moves)

		print([s for s in range(20, 100) if not f(s, 1) and f(s, 2)]) // 60


Перевод числа в 12-ую систему счисления:
	
	def c(n):
	    alph = '0123456789AB'
	    res = ''
	    while n > 0:
	        res = str(alph[n % 12]) + res
	        n //= 12
	    if res[0] == '0': res = res[1::]
	    return res

Перевод числа в 3-ую систему счисления:

	def c(n):
		res = ''
		while n > 0:
			res += str(n % 3)
			n //= 3
		res = res[::-1]	
		return res

    Является ли число палиндромом:

        d = 44144
        if str(d) == str(d)[::-1]: print(True)
        else: print(False)