ИЗВЕСТНО, ЧТО ВАНЯ ВЫИГРАЛ СВОИМ ПЕРВЫМ ХОДОМ ПОСЛЕ НЕУДАЧНОГО ХОДА ПЕТИ - меняем all(h) на any(h) в 5 строчке.

x - текущее количество камней в куче.
n - сколько ходов осталось до конца анализа.

    - n уменьшаяется на 1 при каждом рекурсивном ходе.
    - четность n определяет, чей сейчас ход.

уменьшить количество камней в куче в два раза (с округлением в меньшую сторону):

    f(x // 2, n - 1)

уменьшить количество камней в куче в два раза (с округлением в большую сторону):

    from math import ceil
    f(ceil(x / 2), n - 1)

20:

    def f(x, n):
        if x >= 62: return n % 2 == 0
        if n == 0: return 0
        h = [
            f(x + 1, n - 1),
            f(x * 2, n - 1)
        ]
        if n % 2 == 0: return all(h)
        return any(h)
    print([s for s in range(1, 62) if not f(s, 1) and f(s, 3)])


    def f(x, n):
        if x >= 82: return n % 2 == 0
        if n == 0: return 0
        h = [
            f(x + 2, n - 1),
            f(x + 4, n - 1),
            f(x * 3, n - 1)
        ]
        if n % 2 == 0: return all(h)
        return any(h)
    print([s for s in range(1, 82) if f(s, 3) and not f(s, 1)])


    def f(s, n):
        if s <= 30: return n % 2 == 0
        if n == 0: return 0
        h = [
            f(s - 3, n - 1),
            f(s - 5, n - 1),
            f(s // 4, n - 1)
        ]
        if n % 2 == 0: return all(h)
        return any(h)
    print([s for s in range(31, 1000) if not f(s, 1) and f(s, 3)])


    def f(x, n):
        if x <= 19: return n % 2 == 0
        if n == 0: return 0
        h = [
            f(x - 2, n - 1),
            f(x - 5, n - 1),
            f(x // 3, n - 1)
        ]
        if n % 2 == 0: return all(h)
        return any(h)
    print([s for s in range(20, 1000) if not f(s, 1) and f(s, 3)])


    СЛОЖНАЯ!!
    За один ход игрок может добавить в кучу три камня, пять камней или увеличить количество камней в куче в три раза. Для того чтобы делать ходы, у каждого игрока есть неограниченное количество камней. Игра завершается в тот момент, когда количество камней в куче становится не менее 97. Если при этом количество камней в куче не превышает 105, победителем считается игрок, который сделал последний ход. В противном случае победителем становится его противник, при этом считается, что противник сделал ход.

        def f(x, n):
            if 97 <= x <= 105: return n % 2 == 0
            if x > 105: return n % 2 != 0
            if n == 0: return 0
            h = [
                f(x + 3, n - 1),
                f(x + 5, n - 1),
                f(x * 3, n - 1)
            ]
            if n % 2 == 0: return all(h)
            return any(h)
        print([s for s in range(1, 97) if not f(s, 1) and f(s, 3)])


    def f(x, n):
        if x <= 11: return n % 2 == 0
        if n == 0: return 0
        h = [
            f(x - 3, n - 1),
            f(x - 7, n - 1),
            f(x // 3, n - 1)
        ]
        if n % 2 == 0: return all(h)
        return any(h)
    print([s for s in range(12, 1000) if not f(s, 1) and f(s, 3)])


    СЛОЖНАЯ!!
    Перед игроками лежат две кучи камней. Игроки ходят по очереди, первый ход делает Петя. За один ход игрок может:

        - увеличить количество камней в одной куче на количество камней, которые находятся в другой куче.
        - уравнять количество камней в двух кучах, добавив в меньшую столько камней, чтобы количество камней совпало. Если в кучах уже одинаковое количество камней, то их количество не меняется.

        def f(a, b, n):
            if a + b >= 189: return n % 2 == 0
            if n == 0: return 0
            h = [
                f(a + b, b, n - 1),
                f(a, b + a, n - 1)
            ]
            if a != b:
                if a < b:
                    h.append(f(a + (b - a), b, n - 1))
                if b < a:
                    h.append(f(a, b + (a - b), n - 1))
            if a == b: 
                h.append(f(a, b, n - 1))
            if n % 2 == 0: return all(h)
            return any(h)
        print([s for s in range(1, 184) if not f(5, s, 1) and f(5, s, 3)])


    СЛОЖНАЯ!!
    Игроки ходят по очереди, первый ход делает Петя. За один ход игрок может добавить в кучу один камень, добавить два камня или увеличить количество камней в куче в два раза. Например, если в начале игры в куче 3 камня, Петя может первым ходом получить кучу из 4, 5 или 6 камней. Общий запас игроков составляет 50 камней (включая те, что уже лежат в куче). Например, если в куче уже есть 30 камней, то следующим ходом выполнять удвоение нельзя – камней не хватит.

        def f(x, n):
            if x >= 41: return n % 2 == 0
            if n == 0: return 0
            h = []
            if x + 1 <= 50: h.append(f(x + 1, n - 1))
            if x + 2 <= 50: h.append(f(x + 2, n - 1))
            if x * 2 <= 50: h.append(f(x * 2, n - 1))
            if n % 2 == 0: return all(h)
            return any(h)
        print([s for s in range(1, 41) if f(s, 6) and not f(s, 4) and not f(s, 2)])


    СЛОЖНАЯ!!
    Игроки ходят по очереди, первый ход делает Петя. За один ход игрок может убрать из одной из куч один камень или уменьшить количество камней в куче в два раза (если количество камней в куче нечётно, остаётся на 1 камень больше, чем убирается).

        from math import ceil
        def f(a, b, n):
            if a + b <= 20: return n % 2 == 0
            if n == 0: return 0
            h = [
                f(a - 1, b, n - 1),
                f(a, b - 1, n - 1)
            ]
            if a % 2 == 0: h.append(f(a / 2, b, n - 1))
            else: h.append(f(ceil(a / 2), b, n - 1))
            if b % 2 == 0: h.append(f(a, b / 2, n - 1))
            else: h.append(f(a, ceil(b / 2), n - 1))
            if n % 2 == 0: return all(h)
            return any(h)
        print([s for s in range(11, 1000) if not f(10, s, 1) and f(10, s, 3)])


    def f(x, n):
        if x <= 27: return n % 2 == 0
        if n == 0: return 0
        h = [
            f(x - 3, n - 1),
            f(x - 6, n - 1),
            f(x // 3, n - 1)
        ]
        if n % 2 == 0: return all(h)
        return any(h)
    print([s for s in range(28, 1000) if not f(s, 1) and f(s, 3)])


    def f(x, n):
        if x <= 15: return n % 2 == 0
        if n == 0: return 0
        h = [
            f(x - 3, n - 1),
            f(x - 4, n - 1),
            f(x // 2, n - 1)
        ]
        if n % 2 == 0: return all(h)
        return any(h)
    print([s for s in range(16, 1000) if not f(s, 1) and f(s, 3)])


    СЛОЖНАЯ!!
    Игроки ходят по очереди, первый ход делает Петя. За один ход игрок может добавить в кучу один камень или три камня или одиннадцать камней. Для того чтобы делать ходы, у каждого игрока есть неограниченное количество камней. Игра завершается в тот момент, когда количество камней в куче становится числом, оканчивающимся на ноль. Победителем считается игрок, сделавший последний ход, т. е. первым получивший кучу, количество камней в которой оканчивается на ноль. К примеру, игра заканчивается, когда в куче стало 10, 200, 6800 камней.В начальный момент в куче было S камней. S — двузначное число, не оканчивающиеся на ноль.

        def f(x, n):
            if x % 10 == 0: return n % 2 == 0
            if n == 0: return 0
            h = [
                f(x + 1, n - 1),
                f(x + 3, n - 1),
                f(x + 11, n - 1)
            ]
            if n % 2 == 0: return all(h)
            return any(h)
        print(len([s for s in range(10, 100) if s % 10 != 0 and not f(s, 1) and f(s, 3)]))


    СЛОЖНАЯ!!
    Игроки ходят по очереди, первый ход делает Петя. За один ход игрок может добавить 3 камня, добавить 6 камней или увеличить количество камней в 2 раза, при этом нельзя повторять последний ход соперника. 

        def f(x, n, last):
            if x > 40: return n % 2 == 0
            if n == 0: return 0
            h = []
            if last != 3: h.append(f(x + 3, n - 1, 3))
            if last != 6: h.append(f(x + 6, n - 1, 6))
            if last != 2: h.append(f(x * 2, n - 1, 2))
            if n % 2 == 0: return all(h)
            return any(h)
        print([s for s in range(2, 37) if not f(s, 1, 0) and f(s, 3, 0)])


    def f(x, n):
        if x <= 10: return n % 2 == 0
        if n == 0: return 0
        h = [
            f(x // 3, n - 1),
            f(x - 10, n - 1)
        ]
        if n % 2 == 0: return all(h)
        return any(h)
    print([s for s in range(11, 201) if not f(s, 1) and f(s, 3)])

21:

    def f(x, n):
        if x >= 52: return n % 2 == 0
        if n == 0: return 0
        h = [
            f(x + 1, n - 1),
            f(x * 2, n - 1)
        ]
        if n % 2 == 0: return all(h)
        return any(h)
    print([s for s in range(1, 52) if not f(s, 1) and f(s, 3)])


    СЛОЖНАЯ!!
    Игрок может либо увеличить количество камней в любой из куч на 3, либо увеличить количество вдвое. Игра завершается, когда хотя бы в одной из куч количество камней становится не менее 21. Известно, что Петя имеет выигрышную стратегию при игре из позиции (3, S); 1 ≤ S ≤ 18. Найдите все возможные значения S, если известно. Что Петя не может выиграть своим первым ходом? Запишите найденные значения в порядке возрастания без разделителей.

        def f(a, b, n):
            if a >= 21 or b >= 21: return n % 2 == 0
            if n == 0: return 0
            h = [
                f(a + 3, b, n - 1),
                f(a, b + 3, n - 1),
                f(a * 2, b, n - 1),
                f(a, b * 2, n - 1)
            ]
            if n % 2 == 0: return all(h)
            return any(h)
        print([s for s in range(1, 19) if not f(3, s, 1) and (f(3, s, 3) or f(3, s, 5) or f(3, s, 7) or f(3, s, 9))])

        ОЧЕНЬ ВНИМАТЕЛЬНО НА ПОСЛЕДНЮЮ СТРОКУ.


    def f(x, n):
        if x <= 15: return n % 2 == 0
        if n == 0: return 0
        h = [
            f(x - 3, n - 1),
            f(x - 4, n - 1),
            f(x // 2, n - 1)
        ]
        if n % 2 == 0: return all(h)
        return any(h)
    print([s for s in range(16, 1000) if (f(s, 2) or f(s, 4)) and not f(s, 2)])


    def f(a, b, n):
        if a * b >= 123: return n % 2 == 0
        if n == 0: return 0
        h = [
            f(a + 2, b, n - 1),
            f(a, b + 2, n - 1),
            f(a * 2, b, n - 1),
            f(a, b * 2, n - 1)
        ]
        if n % 2 == 0: return all(h)
        return any(h)
    print([s for s in range(1, 41) if (f(3, s, 2) or f(3, s, 4)) and not f(3, s, 2)])


    def f(a, b, n):
        if a + b >= 59: return n % 2 == 0
        if n == 0: return 0
        h = [
            f(a + 1, b, n - 1),
            f(a, b + 1, n - 1),
            f(a * 2, b, n - 1),
            f(a, b * 2, n - 1)
        ]
        if n % 2 == 0: return all(h)
        return any(h)
    print([s for s in range(2, 53) if (f(5, s, 2) or f(5, s, 4)) and not f(5, s, 2)])


    def f(a, b, n):
        if a + b >= 159: return n % 2 == 0
        if n == 0: return 0
        h = [
            f(a + 1, b, n - 1),
            f(a, b + 1, n - 1),
            f(a + 3, b, n - 1),
            f(a, b + 3, n - 1),
            f(a * 2, b, n - 1),
            f(a, b * 2, n - 1)
        ]
        if n % 2 == 0: return all(h)
        return any(h)
    print([s for s in range(1, 131) if (f(7, s, 2) or f(7, s, 4)) and not f(7, s, 2)])


    СЛОЖНАЯ!!
    Игроки ходят по очереди, первый ход делает Петя. За один ход игрок может убрать из одной из куч один камень или уменьшить количество камней в куче в два раза (если количество камней в куче нечётно, остаётся на 1 камень больше, чем убирается).

        from math import ceil
        def f(a, b, n):
            if a + b <= 20: return n % 2 == 0
            if n == 0: return 0
            h = [
                f(a - 1, b, n - 1),
                f(a, b - 1, n - 1)
            ]
            if a % 2 != 0: h.append(f(ceil(a / 2), b, n - 1))
            else: h.append(f(a / 2, b, n - 1))
            if b % 2 != 0: h.append(f(a, ceil(b / 2), n - 1))
            else: h.append(f(a, b / 2, n - 1))
            if n % 2 == 0: return all(h)
            return any(h)
        print([s for s in range(11, 1000) if (f(10, s, 2) or f(10, s, 4))


    Игроки ходят по очереди, первый ход делает Петя. За один ход игрок может добавить в кучу один камень, добавить два камня или увеличить количество камней в куче в два раза. При этом удвоение разрешено выполнять, только если в куче в данный момент нечётное число камней. Найдите наименьшее значение S, при котором у Пети есть выигрышная стратегия, позволяющая ему выиграть третьим ходом при любой игре Вани, но у Пети нет стратегии, которая позволяла бы ему гарантированно выиграть первым или вторым ходом. 

        def f(x, n):
            if x >= 22: return n % 2 == 0
            if n == 0: return 0
            h = [
                f(x + 1, n - 1),
                f(x + 2, n - 1),
            ]
            if x % 2 != 0: h.append(f(x * 2, n - 1))
            if n % 2 == 0: return all(h)
            return any(h)
        print([s for s in range(1, 22) if f(s, 5) and not f(s, 3) and not f(s, 1)])\
    

    За один ход игрок может добавить в большую кучу любое количество камней от одного до трёх или удвоить количество камней в меньшей куче. Если кучи содержат равное количество камней, можно добавить в любую из них от одного до трёх камней, удвоение в этой ситуации запрещено. За один ход игрок может добавить в большую кучу любое количество камней от одного до трёх или удвоить количество камней в меньшей куче. Если кучи содержат равное количество камней, можно добавить в любую из них от одного до трёх камней, удвоение в этой ситуации запрещено. 


        def f(a, b, n):
            if (a >= 40 and b < 40) or (b >= 40 and a < 40): return n % 2 == 0
            if n == 0: return 0
            h = []
            if a > b:
                h.append(f(a + 1, b, n - 1))
                h.append(f(a + 2, b, n - 1))
                h.append(f(a + 3, b, n - 1))
                h.append(f(a, b * 2, n - 1))
            if a == b:
                h.append(f(a + 1, b, n - 1))
                h.append(f(a + 2, b, n - 1))
                h.append(f(a + 3, b, n - 1))
                h.append(f(a, b + 1, n - 1))
                h.append(f(a, b + 2, n - 1))
                h.append(f(a, b + 3, n - 1))
            if b > a:
                h.append(f(a, b + 1, n - 1))
                h.append(f(a, b + 2, n - 1))
                h.append(f(a, b + 3, n - 1))
                h.append(f(a * 2, b, n - 1))
            if n % 2 == 0: return all(h)
            return any(h)
        print([s for s in range(1, 40) if f(31, s, 4) and not f(31, s, 2)])
        

    from math import ceil
    def f(x, n):
        if x <= 35: return n % 2 == 0
        if n == 0: return 0
        h = [
            f(x - 2, n - 1),
            f(x - 4, n - 1),
            f(ceil(x / 2), n - 1)
        ]
        if n % 2 == 0: return all(h)
        return any(h)
    print([s for s in range(36, 1000) if (f(s, 2) or f(s, 4)) and not f(s, 2)])


    from math import ceil
    def f(a, b, n):
        if a + b <= 46: return n % 2 == 0
        if n == 0: return 0
        h = [
            f(a - 2, b, n - 1),
            f(a, b - 2, n - 1)
        ]
        if a % 2 != 0: h.append(f(ceil(a / 2), b, n - 1))
        else: h.append(f(a / 2, b, n - 1))
        if b % 2 != 0: h.append(f(a, ceil(b / 2), n - 1))
        else: h.append(f(a, b / 2, n - 1))
        if n % 2 == 0: return all(h)
        return any(h)
    print([s for s in range(27, 1000) if (f(20, s, 2) or f(20, s, 4)) and not f(20, s, 2)])


    def f(x, n):
        if x <= 12: return n % 2 == 0
        if n == 0: return 0
        h = [
            f(x // 3, n - 1),
            f(x - 12, n - 1)
        ]
        if n % 2 == 0: return all(h)
        return any(h)
    print(len([s for s in range(13, 1000) if (f(s, 2) or f(s, 4)) and not f(s, 2)]))