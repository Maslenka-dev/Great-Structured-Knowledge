x - текущее количество камней в куче.
n - сколько сыграно ходов.

ИЗВЕСТНО, ЧТО ПЕТЯ ВЫИГРАЛ СВОИМ ВТОРЫМ ХОДОМ ПОСЛЕ НЕУДАЧНОГО ХОДА ВАНИ: меняем код для ходов:

	if n % 2 == 0: return any(h) # ход Пети
	return any(h) # ход Вани

уменьшить количество камней в куче в два раза (с округлением в меньшую сторону):

	f(x // 2, n + 1)

уменьшить количество камней в куче в два раза (с округлением в большую сторону):

	from math import ceil
	f(ceil(x / 2), n + 1)

Два игрока, Петя и Ваня, играют в следующую игру. Перед игроками лежит куча камней. Игроки ходят по очереди, первый ход делает Петя. За один ход игрок может добавить в кучу один камень или увеличить количество камней в куче в два раза. Для того чтобы делать ходы, у каждого игрока есть неограниченное количество камней.
Игра завершается в тот момент, когда количество камней в куче становится не менее 165. Победителем считается игрок, сделавший
последний ход, т.е. первым получивший кучу из 165 или больше камней. В
начальный момент в куче было Ѕ камней, 1≤5 ≤ 164.
Будем говорить, что игрок имеет выигрышную стратегию, если он может выиграть при любых ходах противника.
Укажите такое значение Ѕ, при котором Петя не может выиграть за один ход, но при любом ходе Пети Ваня может выиграть своим первым ходом.

	def f(x, n):
	    if x >= 165 or n > 2: return n == 2
	    h = [
	        f(x + 1, n + 1),
	        f(x * 2, n + 1)
	    ]
	    if n % 2 == 0: return all(h) # ходит Петя 
	    return any(h) # ходит Ваня
	print([s for s in range(1, 165) if f(s, 0)])

Так как Ваня выигрывает вторым ходом, во второй строчке указываем условие выхода при n > 2.


Для игры, описанной в задании 19, найдите два наименьших значения Ѕ, при которых у Пети есть выигрышная стратегия, причём одновременно
выполняются два условия:
- Петя не может выиграть за один ход;
- Петя может выиграть своим вторым ходом независимо от того, как будет ходить Ваня.
Найденные значения запишите в ответе в порядке возрастания.

Так как Петя выигрывает третьим ходом, во второй строчке указываем условие выхода при n > 3.

	def f(x, n):
	    if x >= 165 or n > 3: return n == 3
	    h = [
	        f(x + 1, n + 1),
	        f(x * 2, n + 1)
	    ]
	    if n % 2 != 0: return all(h) # ходит Ваня
	    return any(h) # ходит Петя
	print([s for s in range(1, 165) if f(s, 0)])

	ИЛИ

	def f(x, n):
	    if x >= 165 or n > 3: return n == 3
	    h = [
	        f(x + 1, n + 1),
	        f(x * 2, n + 1)
	    ]
	    if n % 2 == 0: return any(h) # ходит Петя
	    return all(h) # ходит Ваня
	print([s for s in range(1, 165) if f(s, 0)])

	ПРОВЕРКА ПЕРВОГО УСЛОВИЯ:

		def f(x, n):
		    if x >= 165 or n > 1: return n == 1
		    h = [
		        f(x + 1, n + 1),
		        f(x * 2, n + 1)
		    ]
		    if n % 2 == 0: return any(h)
		    return all(h)
		print([s for s in range(1, 165) if f(s, 0)])	

		НЕЛЬЗЯ ПИСАТЬ В ОТВЕТ ЗНАЧЕНИЯ, ПОЛУЧЕННЫЕ В ПРОВЕРКЕ.


	Для игры, описанной в задании 19, найдите минимальное значение Ѕ, при котором одновременно выполняются два условия:
	- у Вани есть выигрышная стратегия, позволяющая ему выиграть первым или вторым ходом при любой игре Пети;
	- у Вани нет стратегии, которая позволит ему гарантированно выиграть первым ходом.

	Так как Ваня может выиграть как на второй, так и на четвертых ход, условие выхода рекурсии ставим n > 4 и возвращаем n == 2 or n == 4.

		def f(x, n):
		    if x >= 165 or n > 4: return n == 2 or n == 4
		    h = [
		        f(x + 1, n + 1),
		        f(x * 2, n + 1)
		    ]
		    if n % 2 == 0: return all(h)
		    return any(h)
		print([s for s in range(1, 165) if f(s, 0)])

	ПРОВЕРКА:

		def f(x, n):
		    if x >= 165 or n > 2: return n == 2 
		    h = [
		        f(x + 1, n + 1),
		        f(x * 2, n + 1)
		    ]
		    if n % 2 == 0: return all(h)
		    return any(h)
		print([s for s in range(1, 165) if f(s, 0)])

		- одно значение не подошло, его и не включаем в ответ. 

Практика:

	19:

		def f(x, n):
		    if x >= 301 or n > 2: return n == 2
		    h = [
		        f(x + 3, n + 1),
		        f(x * 5, n + 1)
		    ]
		    if n % 2 == 0: return all(h)
		    return any(h)
		print([s for s in range(1, 301) if f(s, 0)])


		def f(x, n):
		    if x >= 67 or n > 2: return n == 2
		    h = [
		        f(x + 1, n + 1),
		        f(x + 4, n + 1),
		        f(x * 3, n + 1)
		    ]
		    if n % 2 == 0: return all(h)
		    return any(h)
		print([s for s in range(1, 67) if f(s, 0)])


		Петя и Ваня решили поиграть. Перед ними лежат две кучи камней. Ребята ходят по очереди, первый ход делает Петя. За один ход игрок может убрать из любой кучи два камня или уменьшить количество камней в большей куче в два раза (с округлением в большую сторону).
		Известно, что Ваня выиграл своим первым ходом после неудачного первого хода Пети.
		Укажите максимальное значение S, при котором такая ситуация возможна.

			from math import ceil
			def f(a, b, n):
			    if a + b <= 33 or n > 2: return n == 2
			    if a > b:
			        h = [
			            f(a - 2, b, n + 1),
			            f(a, b - 2, n + 1),
			            f(ceil(a / 2), b, n + 1)
			        ]
			    else:
			        h = [
			            f(a - 2, b, n + 1),
			            f(a, b - 2, n + 1),
			            f(a, ceil(b / 2), n + 1)
			        ]
			    if n % 2 == 0: return any(h)
			    return any(h)
			print([s for s in range(10, 1000) if f(23, s, 0)])


		def f(a, b, n):
		    if a + b >= 245 or n > 2: return n == 2
		    h = [
		        f(a + 1, b, n + 1),
		        f(a, b + 1, n + 1),
		        f(a * 2, b, n + 1),
		        f(a, b * 2, n + 1)
		    ]
		    if n % 2 == 0: return any(h)
		    return any(h)
		print([s for s in range(1, 225) if f(15, s, 0)])


		За один ход игрок может добавить в кучу один камень, добавить два камня или увеличить количество камней в куче в два раза. Например, если в начале игры в куче 3 камня, Петя может первым ходом получить кучу из 4, 5 или 6 камней. Общий запас игроков составляет 50 камней (включая те, что уже лежат в куче). Укажите такое значение S, при котором у Вани есть выигрышная стратегия, позволяющая ему выиграть вторым ходом при любой игре Пети, но у Вани нет стратегии, которая позволяла бы ему гарантированно выиграть первым ходом.

			def f(x, n):
			    if x >= 41 or n > 4: return n == 4 or n == 2
			    h = []
			    if x + 1 <= 50: h.append(f(x + 1, n + 1))
			    if x + 2 <= 50: h.append(f(x + 2, n + 1))
			    if x * 2 <= 50: h.append(f(x * 2, n + 1))
			    if n % 2 == 0: return all(h)
			    return any(h)
			print([s for s in range(1, 41) if f(s, 0)])

			не забываем про проверку


		Укажите минимальное значение S, при котором Петя не может выиграть за один ход, но при любом ходе Пети Ваня может выиграть своим первым ходом.

			def f(x, n):
			    if x <= 19 or n > 2: return n == 2
			    h = [
			        f(x - 2, n + 1),
			        f(x - 5, n + 1),
			        f(x // 3, n + 1)
			    ]
			    if n % 2 == 0: return all(h)
			    return any(h)
			print([s for s in range(20, 1000) if f(s, 0)])


		Игра завершается в тот момент, когда количество камней в куче становится не менее 97. Если при этом количество камней в куче не превышает 105, победителем считается игрок, который сделал последний ход. В противном случае победителем становится его противник, при этом считается, что противник сделал ход. Укажите максимальное значение SS, при котором Петя не может выиграть за один ход, но при любом ходе Пети Ваня может выиграть своим первым ходом.

			def f(x, n):
			    if x >= 97 or n > 2: return n == 2
			    h = [
			        f(x + 3, n + 1),
			        f(x + 5, n + 1)
			    ]
			    if x * 3 <= 105: h.append(f(x * 3, n + 1))
			    if n % 2 == 0: return all(h)
			    return any(h)
			print([s for s in range(1, 97) if f(s, 0)])


		def f(a, b, n):
		    if a + b >= 143 or n > 2: return n == 2
		    h = [
		        f(a + 3, b, n + 1),
		        f(a * 2, b, n + 1),
		        f(a + 3, b + 3, n + 1),
		        f(a, b * 2, n + 1)
		    ]
		    if n % 2 == 0: return any(h)
		    return any(h)
		print([s for s in range(1, 124) if f(16, s, 0)])


		Укажите максимальное значение SS, при котором Петя не может выиграть за один ход, но при любом ходе Пети Ваня может выиграть своим первым ходом.

			def f(x, n):
			    if x <= 15 or n > 2: return n == 2
			    h = [
			        f(x - 3, n + 1),
			        f(x - 4, n + 1),
			        f(x // 2, n + 1)
			    ]
			    if n % 2 == 0: return all(h)
			    return any(h)
			print(max([s for s in range(16, 1000) if f(s, 0)]))


		За один ход игрок может убрать из кучи один камень, либо, если в куче 4 или больше камней, он может убрать четыре камня, либо, если количество камней в куче кратно трём, он может уменьшить количество камней в куче в три раза. Игра завершается в тот момент, когда количество камней в куче становится не более 1. Укажите минимальное значение S, при котором Петя не может выиграть за один ход, но при любом ходе Пети Ваня может выиграть своим первым ходом.

			def f(x, n):
			    if x <= 1 or n > 2: return n == 2
			    h = [f(x - 1, n + 1)]
			    if x >= 4: h.append(f(x - 4, n + 1))
			    if x % 3: h.append(f(x / 3, n + 1))
			    if n % 2 == 0: return all(h)
			    return any(h)
			print([s for s in range(4, 101) if f(s, 0)])


		def f(x, n):
		    if x <= 30 or n > 2: return n == 2
		    h = [
		        f(x - 3, n + 1),
		        f(x - 5, n + 1),
		        f(x // 4, n + 1)
		    ]
		    if n % 2 == 0: return all(h)
		    return any(h)
		print([s for s in range(31, 1000) if f(s, 0)])


		За один ход игрок может убрать из кучи один камень или уменьшить количество камней в куче в два раза (если в куче нечётное количество камней, сделать такой ход нельзя). Укажите такое максимальное допустимое значение S, при котором Петя не может выиграть за один ход, но при любом ходе Пети Ваня может выиграть своим первым ходом.

			def f(x, n):
			    if x <= 12 or n > 2: return n == 2
			    h = [f(x - 1, n + 1)]
			    if x % 2 == 0: h.append(f(x / 2, n + 1))
			    if n % 2 == 0: return all(h)
			    return any(h)
			print([s for s in range(13, 1000) if f(s, 0)])


		Перед ними лежат две кучи камней. За один ход игрок может убрать из любой кучи четыре камня (если в куче не менее четырёх камней) или уменьшить количество камней в куче в три раза (с округлением в меньшую сторону). При этом нельзя повторять предыдущий ход оппонента с той же кучей. Укажите значение S, при котором Полина не может выиграть за один ход, но при любом ходе Полины Вика может выиграть своим первым ходом.

			def f(a, b, n):
			    if a + b <= 42 or n > 2: return n == 2
			    h = [f(a // 3, b, n + 1), f(a, b // 3, n + 1)]
			    if a >= 4: h.append(f(a - 4, b, n + 1))
			    if b >= 4: h.append(f(a, b - 4, n + 1))
			    if n % 2 == 0: return all(h)
			    return any(h)
			print([s for s in range(2, 1000) if f(50, s, 0)])


		СЛОЖНАЯ!!
		Игра завершается в тот момент, когда количество камней в куче становится не меньше 55. Если при этом камней оказалось не больше 77, победителем становится игрок, который сделал последний ход. В противном случае считается, что его соперник победил своим следующим ходом. Укажите количество значений S, при которых Петя не может выиграть за один ход, но при любом ходе Пети Ваня может выиграть своим первым ходом.

			def f(x, n):
			    if 55 <= x <= 77 or n > 2: return n == 2
			    if x > 77 or n > 2: return n != 2 
			    h = [
			        f(x + 3, n + 1),
			        f(x * 2, n + 1),
			        f(x * 3, n + 1)
			    ]
			    if n % 2 == 0: return all(h)
			    return any(h)
			print([s for s in range(1, 55) if f(s, 0)])

			Если количество камней в куче больше 77, возвращаем условие победы соперника: if x > 77 or n > 2: return n != 2 


		Два игрока, Кузнец и Садовник, решили поиграть. Перед ними лежит куча камней количеством 1<S<650001<S<65000. Каждый игрок может добавить в кучу 1, 2, 4, 8, 16 или 32 камня, а также увеличить количество камней в 3, 9, или 27 раз. Первый ход совершает Кузнец. Победителем считается игрок, после хода которого в куче оказалось 65535 или более камней. Определите минимальное начальное количество камней (S) в куче при условии, что Кузнец не мог выиграть своим первым ходом, но при любом ходе Кузнеца Садовник может выиграть своим первым ходом.

			def f(x, n):
			    if x >= 65535 or n > 2: return n == 2
			    h = [
			        f(x + 1, n + 1),
			        f(x + 2, n + 1),
			        f(x + 4, n + 1),
			        f(x + 8, n + 1),
			        f(x + 16, n + 1),
			        f(x + 32, n + 1),
			        f(x * 3, n + 1),
			        f(x * 9, n + 1),
			        f(x * 27, n + 1),
			    ]
			    if n % 2 == 0: return all(h)
			    return any(h)
			print([s for s in range(1, 65001) if f(s, 0)])


		def f(a, b, n):
		    if a + b >= 131 or n > 2: return n == 2
		    h = [
		        f(a + 2, b, n + 1),
		        f(a, b + 2, n + 1),
		        f(a * 2, b, n + 1),
		        f(a, b * 2, n + 1),
		    ]
		    if n % 2 == 0: return any(h)
		    return any(h)
		print([s for s in range(1, 120) if f(11, s, 0)])


		ОЧЕНЬ СЛОЖНАЯ!!
		Два игрока, Петя и Ваня, играют в следующую игру. Перед игроками лежат две кучи камней, не меньше одного камня в каждой. Игроки ходят по очереди, первый ход делает Петя. За один ход игрок может добавить в большую кучу любое количество камней от одного до трёх или удвоить количество камней в меньшей куче. Если кучи содержат равное количество камней, можно добавить в любую из них от одного до трёх камней, удвоение в этой ситуации запрещено.
		Игра завершается в тот момент, когда количество камней в одной из куч достигает 40. Победителем считается игрок, сделавший последний ход, то есть первым получивший кучу, в которой будет 40 или больше камней.
		Известно, что Петя смог выиграть первым ходом. Какое наименьшее число камней могло быть суммарно в двух кучах

			def f(a, b, n):
			    if (a >= 40 and b < 40) or (b >= 40 and a < 40) or n > 1: return n == 1
			    if a > b:
			        h = [
			            f(a + 1, b, n + 1),
			            f(a + 2, b, n + 1),
			            f(a + 3, b, n + 1),
			            f(a, b * 2, n + 1)
			        ]
			    if a == b:
			        h = [
			            f(a, b + 1, n + 1),
			            f(a, b + 2, n + 1),
			            f(a, b + 3, n + 1),
			            f(a + 1, b, n + 1),
			            f(a + 2, b, n + 1),
			            f(a + 3, b, n + 1)
			        ]
			    if a < b:
			        h = [
			            f(a, b + 1, n + 1),
			            f(a, b + 2, n + 1),
			            f(a, b + 3, n + 1),
			            f(a * 2, b, n + 1)
			        ]
			    return any(h)
			print(min(a + b for a in range(1, 40) for b in range(1, 40) if f(a, b, 0)))

			В конце пишем просто return any(h), потому что выигрывает Петя первым ходом.


		СЛОЖНАЯ!!
		Игроки ходят по очереди, первый ход делает Петя. За один ход игрок может добавить 3 камня, добавить 6 камней или увеличить количество камней в 2 раза, при этом нельзя повторять последний ход соперника.
		Игра завершается в тот момент, когда количество камней в куче становится более 40. Победителем считается игрок, сделавший последний ход. Укажите такое максимальное допустимое значение S, при котором Петя не может выиграть за один ход, но при любом ходе Пети Ваня может выиграть своим первым ходом.

			def f(x, n, last):
			    if x > 40 or n > 2: return n == 2
			    h = []
			    if last != 3: h.append(f(x + 3, n + 1, 3))
			    if last != 6: h.append(f(x + 6, n + 1, 6))
			    if last != 2: h.append(f(x * 2, n + 1, 2))
			    if n % 2 == 0: return all(h)
			    return any(h)
			print(max([s for s in range(2, 37) if f(s, 0, 0)]))

			- last хранит последний ход соперника.

			- На каждом рекурсивном шаге он передаётся дальше, поэтому запрет повторения работает отдельно для каждой ветки.


	Игра завершается в тот момент, когда количество камней в куче становится числом, оканчивающимся на ноль. Победителем считается игрок, сделавший последний ход, т. е. первым получивший кучу, количество камней в которой оканчивается на ноль. К примеру, игра заканчивается, когда в куче стало 10, 200, 6800 камней. В начальный момент в куче было S камней. S — двузначное число, не оканчивающиеся на ноль. Укажите минимальное значение S, при котором Петя не может выиграть за один ход, но при любом ходе Пети Ваня может выиграть своим первым ходом.

		def f(x, n):
		    if x % 10 == 0 or n > 2: return n == 2
		    h = [
		        f(x + 1, n + 1),
		        f(x + 3, n + 1),
		        f(x + 11, n + 1)
		    ]
		    if n % 2 == 0: return all(h)
		    return any(h)
		print(min([s for s in range(10, 10000) if s % 10 != 0 if f(s, 0)]))


	Игроки ходят по очереди, первый ход делает Петя. За один ход игрок может добавить в меньшую кучу один или три камня. Изменять количество камней в большей куче не разрешается. Игра завершается, когда количество камней в кучах становится равным. Укажите такое минимальное значение S, при котором Петя не может выиграть за один ход, но при любом ходе Пети Ваня может выиграть своим первым ходом.

		def f(a, b, n):
		    if a == b or n > 2: return n == 2
		    if a < b:
		        h = [
		            f(a + 1, b, n + 1),
		            f(a + 3, b, n + 1),
		        ]
		    if b < a:
		        h = [
		            f(a, b + 1, n + 1),
		            f(a, b + 3, n + 1),
		        ]
		    if n % 2 == 0: return all(h)
		    return any(h)
		print(min([s for s in range(1, 24) if f(13, s, 0)]))