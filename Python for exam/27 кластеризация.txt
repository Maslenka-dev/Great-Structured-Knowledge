Нахождение уравнения прямой по двум точкам:

    def f(x1, x2, y1, y2):
        k = (y2 - y1) / (x2 - x1)
        b = y1 - k * x1 # y2 - k * x2
        return [k, b]

Запись x и y в отдельные переменные после редактирования исходных данных для корректного считывания чисел:

    a = open('27_A_18314.txt')
    clusters = [[], []]
    for s in a:
        x, y = [float(t) for t in s.split()] # заменяем , на . до выполнения программы в блокноте
        print(x, y)    

    ИЛИ

    a = open('27_A_18314.txt')
    clusters = [[], []]
    for s in a:
        x, y = [float(t) for t in s.replace(',', '.').split()] # заменяем , на . в момент выполнения программы
        print(x, y)

Пример кластеризации:

    a = open('27_B_18314.txt')
    clusters = [[], []]
    for s in a:
        x, y = [float(t) for t in s.replace(',', '.').split()]
        if x < 24: clusters[0].append([x, y])
        else: clusters[1].append([x, y])

Пример функции нахождения центра:

    def center(cl):
        l = []
        for p1 in cl: # потенциальный центр
            sm = 0
            for p2 in cl:
                sm += r(p1, p2) # увеличиваем sm на расстояние от p1 до p2
            l.append([sm, p1])
        return min(l)[1] # возвращаем точку, от которой расстояние до других минимально

    ИЛИ

    def center(cl):
        l = []
        for p1 in cl: # потенциальный центр
            sm = sum(list(r(p1, p2) for p2 in cl))
            l.append([sm, p1])
        return min(l)[1] # возвращаем точку, от которой расстояние до других минимально

    ИЛИ

    def center(cl):
        return min([sum(list(r(p1, p2) for p2 in cl)), p1] for p1 in cl)[1]


        

На складе с автоматической системой управления работают роботы, которые собирают грузы, расположенные на разных участках склада. Склад представляет собой прямоугольную сетку высотой H и шириной W. Каждый робот может перемещаться только вдоль осей сетки (вверх, вниз, влево, вправо), поэтому для оценки расстояний между объектами используется манхэттенское расстояние.
Группа инженеров решила оптимизировать работу роботов, минимизировав общее время сбора грузов. Для этого необходимо определить координаты груза в каждом участке склада, для которой сумма расстояний от неё до всех грузов на участке будет минимальной. Эта точка называется центроидом. Робот, находящийся в центроиде, сможет быстрее собрать все грузы на своём участке.
Под расстоянием между двумя точками A(x1, y1) и B(x2, y2) понимается манхэттенское расстояние, которое вычисляется по формуле:
d(A,B)=∣x2−x1∣+∣y2−y1∣d(A,B)=∣x2−x1∣+∣y2−y1∣
В файле A хранятся данные о расположении грузов на двух участках склада, где каждый участок имеет размеры H = 10 и W = 20. В каждой строке записана информация о расположении одного груза: сначала координата x, затем координата y. Количество грузов в файле не превышает 1000.
В файле B хранятся данные о грузах на трёх участках склада, где каждый участок также имеет размеры H = 10 и W = 20. Количество грузов в файле не превышает 10 000. Структура хранения информации о грузах в файле B аналогична файлу A.
Для каждого файла определите координаты центра каждого участка (центроида), а затем вычислите два числа:
    Px — среднее арифметическое абсцисс центроидов участков,
    Py — среднее арифметическое ординат центроидов участков.
В ответе запишите четыре числа: в первой строке сначала целую часть абсолютного значения произведения Px∗1000 затем целую часть абсолютного значения произведения Py∗1000 для файла A; во второй строке — аналогичные данные для файла B.
Возможные данные одного из файлов иллюстрированы графиком. 

    Манхеттенское расстояние:

        def r(p1, p2):
            x1 = p1[0]
            x2 = p2[0]
            y1 = p1[1]
            y2 = p2[1]
            return abs(x2 - x1) + abs(y2 - y1)

    Для файла А:

        def r(p1, p2):
            x1 = p1[0]
            x2 = p2[0]
            y1 = p1[1]
            y2 = p2[1]
            return abs(x2 - x1) + abs(y2 - y1)

        def center(cl):
            l = []
            for p1 in cl: # потенциальный центр
                sm = 0
                for p2 in cl:
                    sm += r(p1, p2) # увеличиваем sm на расстояние от p1 до p2
                l.append([sm, p1])
            return min(l)[1] # возвращаем точку, от которой расстояние до других минимально

        a = open('27_A_18314.txt')
        clusters = [[], []]
        for s in a:
            x, y = [float(t) for t in s.replace(',', '.').split()]
            if x < 24: clusters[0].append([x, y])
            else: clusters[1].append([x, y])

        res = list(center(t) for t in clusters)
        Px = sum(list(t[0] for t in res)) / len(res)
        Py = sum(list(t[1] for t in res)) / len(res)
        print(Px, Py)
        print(int(abs(Px * 1000)), int(abs(Py * 1000)))

    Для файла Б:

        def r(p1, p2):
            x1 = p1[0]
            x2 = p2[0]
            y1 = p1[1]
            y2 = p2[1]
            return abs(x2 - x1) + abs(y2 - y1)

        def center(cl):
            l = []
            for p1 in cl: # потенциальный центр
                sm = 0
                for p2 in cl:
                    sm += r(p1, p2) # увеличиваем sm на расстояние от p1 до p2
                l.append([sm, p1])
            return min(l)[1] # возвращаем точку, от которой расстояние до других минимально

        a = open('27_B_18314.txt')
        clusters = [[], [], []]
        for s in a:
            x, y = [float(t) for t in s.replace(',', '.').split()]
            if x < -10: clusters[0].append([x, y])
            if -10 < x < 18: clusters[1].append([x, y])
            if x > 18: clusters[2].append([x, y])
        res = list(center(t) for t in clusters)
        Px = sum(list(t[0] for t in res)) / len(res)
        Py = sum(list(t[1] for t in res)) / len(res)
        print(Px, Py)
        print(int(abs(Px * 1000)), int(abs(Py * 1000)))

Фрагмент звёздного неба спроецирован на плоскость с декартовой системой координат. Учёный решил провести кластеризацию полученных точек, являющихся изображениями звёзд, то есть разбить их множество на N непересекающихся непустых подмножеств (кластеров) так, что они будут лежать внутри сектора окружности радиуса R = 50 с центральным углом 20°. Гарантируется, что такое разбиение существует и единственно.
Будем называть центром кластера точку этого кластера, сумма расстояний от которой до всех остальных точек кластера минимальна. Для каждого кластера гарантируется единственность его центра. Расстояние между двумя точками на плоскости A(x1,y1) и B(x2,y2) вычисляется по формуле: d(A,B)= ((x2 - x1)**2 + (y2 - y1)**2) ** 0.5
((x2 - x1)**2 + (y2 - y1)**2) ** 0.5
В файле А хранятся данные о звёздах трёх кластеров, для которых центром окружности является точка C (5, –9). В каждой строке записана информация о расположении на карте одной звезды: сначала координата х, затем координата у. Значения даны в условных единицах. Известно, что количество звёзд не превышает 1000.
В файле Б хранятся данные о звёздах шести кластеров, для которых центром окружности является точка C (–10, –7). Известно, что количество звёзд не превышает 10000. Структура хранения информации о звёздах в файле Б аналогична файлу А.
Для каждого файла определите координаты центра каждого кластера, затем вычислите два числа:  Px – среднее арифметическое абсцисс центров кластеров, и  Py – среднее арифметическое ординат центров кластеров.
В ответе запишите четыре числа: в первой строке сначала целая часть абсолютного значения произведения Px×10000, затем целая часть абсолютного значения произведения Py×10000 для файла А, во второй строке – аналогичные данные для файла B.
Возможные данные одного из файлов иллюстрированы графиком. 

Евклидово расстояние:

    def rast(x1, x2, y1, y2):
        return ((x2 - x1)**2 + (y2 - y1)**2) ** 0.5

Для файла А:

    def rast(x1, x2, y1, y2):
        return ((x2 - x1)**2 + (y2 - y1)**2) ** 0.5

    def center(cl):
        l = []
        for p1 in cl:
            sm = sum(list(rast(p1[0], p2[0], p1[1], p2[1]) for p2 in cl))
            l.append([sm, p1])
        return min(l)[1]

    a = open('27_A_21599.txt')
    clusters = [[], [], []]
    for s in a:
        x, y = list(float(t) for t in s.replace(',', '.').split())
        if y < -5: clusters[0].append([x, y])
        if y > x - 12: clusters[1].append([x, y])
        if -5 < y < x - 12: clusters[2].append([x, y])

    res = list(center(t) for t in clusters)
    Px = sum(list(t[0] for t in res)) / len(res)
    Py = sum(list(t[1] for t in res)) / len(res)
    print(int(abs(Px * 10000)), int(abs(Py * 10000)))

Для файла Б:

    def f(x1, x2, y1, y2):
        k = (y2 - y1) / (x2 - x1)
        b = y1 - k * x1
        return [k, b]
    print(f(2, 6, 2, 5))
    print(f(-6, -5, 1, 3))
    print(f(-9, -10, 1, 9))
    print(f(-13, -15, 1, 4))

    # y = -5
    # y = 0.75x + 0.5
    # y = 2x + 13
    # y = -8x - 71
    # y -1.5x - 18

    def rast(x1, x2, y1, y2):
        return ((x2 - x1)**2 + (y2 - y1)**2) ** 0.5

    def center(cl):
        l = []
        for p1 in cl:
            sm = sum(list(rast(p1[0], p2[0], p1[1], p2[1]) for p2 in cl))
            l.append([sm, p1])
        return min(l)[1]

    a = open('27_B_21599.txt')
    clusters = [[], [], [], [], [], []]
    for s in a:
        x, y = list(float(t) for t in s.replace(',', '.').split())
        if y < -5: clusters[0].append([x, y])
        elif y < 0.75*x + 0.5: clusters[1].append([x, y])
        elif y < 2*x + 13: clusters[2].append([x, y])
        elif y > -8*x - 71: clusters[3].append([x, y])
        elif y > -1.5*x - 18: clusters[4].append([x, y])
        elif y > -5: clusters[5].append([x, y])    

    res = list(center(t) for t in clusters)
    Px = sum(list(t[0] for t in res)) / len(res)
    Py = sum(list(t[1] for t in res)) / len(res)
    print(int(abs(Px * 10000)), int(abs(Py * 10000)))

    ИЛИ (более краткая запись кластеризации через elif):

    def f(x1, x2, y1, y2):
        k = (y2 - y1) / (x2 - x1)
        b = y1 - k * x1
        return [k, b]
    print(f(2, 6, 2, 5))
    print(f(-6, -5, 1, 3))
    print(f(-9, -10, 1, 9))
    print(f(-13, -15, 1, 4))

    # y = -5
    # y = 0.75x + 0.5
    # y = 2x + 13
    # y = -8x - 71
    # y -1.5x - 18

    def rast(x1, x2, y1, y2):
        return ((x2 - x1)**2 + (y2 - y1)**2) ** 0.5

    def center(cl):
        l = []
        for p1 in cl:
            sm = sum(list(rast(p1[0], p2[0], p1[1], p2[1]) for p2 in cl))
            l.append([sm, p1])
        return min(l)[1]

    a = open('27_B_21599.txt')
    clusters = [[], [], [], [], [], []]
    for s in a:
        x, y = list(float(t) for t in s.replace(',', '.').split())
        if y < -5: clusters[0].append([x, y])
        elif y < 0.75*x + 0.5: clusters[1].append([x, y])
        elif y < 2*x + 13: clusters[2].append([x, y])
        elif y > -8*x - 71: clusters[3].append([x, y])
        elif y > -1.5*x - 18: clusters[4].append([x, y])
        elif y > -5: clusters[5].append([x, y])    

    res = list(center(t) for t in clusters)
    Px = sum(list(t[0] for t in res)) / len(res)
    Py = sum(list(t[1] for t in res)) / len(res)
    print(int(abs(Px * 10000)), int(abs(Py * 10000)))