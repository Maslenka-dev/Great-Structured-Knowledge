Нахождение уравнения прямой по двум точкам:

    def f(x1, x2, y1, y2):
        k = (y2 - y1) / (x2 - x1)
        b = y1 - k * x1 # y2 - k * x2
        return [k, b]

Запись x и y в отдельные переменные после редактирования исходных данных для корректного считывания чисел:

    a = open('27_A_18314.txt')
    clusters = [[], []]
    for s in a:
        x, y = [float(t) for t in s.split()] # заменяем , на . до выполнения программы в блокноте
        print(x, y)    

    ИЛИ

    a = open('27_A_18314.txt')
    clusters = [[], []]
    for s in a:
        x, y = [float(t) for t in s.replace(',', '.').split()] # заменяем , на . в момент выполнения программы
        print(x, y)

Пример кластеризации:

    a = open('27_B_18314.txt')
    clusters = [[], []]
    for s in a:
        x, y = [float(t) for t in s.replace(',', '.').split()]
        if x < 24: clusters[0].append([x, y])
        else: clusters[1].append([x, y])

Или используем функцию dist() из модуля math:

    from math import dist()

    dist(p, q)

    Вычисляет Евклидово расстояние между двумя точками в n-мерном пространстве.

Центроид:

    Будем называть центром кластера точку этого кластера, сумма расстояний от которой до всех остальных точек кластера минимальна. Для каждого кластера гарантируется единственность его центра. Расстояние между двумя точками на плоскости A(x1,y1) и B(x2,y2) вычисляется по формуле: d(A,B)= ((x2 - x1)**2 + (y2 - y1)**2) ** 0.5
    ((x2 - x1)**2 + (y2 - y1)**2) ** 0.5

    def center(cl):
        l = []
        for p1 in cl: # потенциальный центр
            sm = 0
            for p2 in cl:
                sm += r(p1, p2) # увеличиваем sm на расстояние от p1 до p2
            l.append([sm, p1])
        return min(l)[1] # возвращаем точку, от которой расстояние до других минимально

    ИЛИ

    def center(cl):
        l = []
        for p1 in cl: # потенциальный центр
            sm = sum(list(r(p1, p2) for p2 in cl))
            l.append([sm, p1])
        return min(l)[1] # возвращаем точку, от которой расстояние до других минимально

    ИЛИ

    def center(cl):
        return min([sum(list(r(p1, p2) for p2 in cl)), p1] for p1 in cl)[1]

Среднее расстояние:

    Средним расстоянием назовём среднее арифметическое расстояние между всеми парами различных точек в кластере. Расстояние между двумя точками на плоскости A(x1, y1) и B(x2, y2) вычисляется по формуле: d(A,B)=((x2 - x1)**2 + (y2 - y1)**2)**0.5.

    def sr(cl):
        l = []
        for p1 in cl:
            l.extend([rast(p1[0], p2[0], p1[1], p2[1]) for p2 in cl if p1 != p2])
        return sum(l) / len(l)

Изолированная точка:

    Изолированной точкой назовём точку, в единичном окрестности от которой находится наименьшее количество точек кластера. Если таких точек несколько, то выбирается точка с наибольшей координатой y. Расстояние между двумя точками на плоскости A(x1, y1) и B(x2, y2) вычисляется по формуле Евклида.

    def point(cl):
        l = []
        for p1 in cl:
            c = 0
            for p2 in cl: 
                if dist(p1[0], p2[0], p1[1], p2[1]) <= 1: c += 1
            l.append([c, -p1[1], p1])
        return min(l)[2]
        
Минимальное расстояние между двумя кластерами:

    Под расстоянием между двумя кластерами понимается минимальное расстояние между двумя звёздами этих кластеров, а расстояние между двумя точками A(x1, y1) и B(x2, y2) на плоскости вычисляется по формуле Евклида.

    def rr(cl1, cl2):
        l = list([rast(p1[0], p2[0], p1[1], p2[1]), p1, p2] for p1 in cl1 for p2 in cl2)
        return min(l)


На складе с автоматической системой управления работают роботы, которые собирают грузы, расположенные на разных участках склада. Склад представляет собой прямоугольную сетку высотой H и шириной W. Каждый робот может перемещаться только вдоль осей сетки (вверх, вниз, влево, вправо), поэтому для оценки расстояний между объектами используется манхэттенское расстояние.
Группа инженеров решила оптимизировать работу роботов, минимизировав общее время сбора грузов. Для этого необходимо определить координаты груза в каждом участке склада, для которой сумма расстояний от неё до всех грузов на участке будет минимальной. Эта точка называется центроидом. Робот, находящийся в центроиде, сможет быстрее собрать все грузы на своём участке.
Под расстоянием между двумя точками A(x1, y1) и B(x2, y2) понимается манхэттенское расстояние, которое вычисляется по формуле:
d(A,B)=∣x2−x1∣+∣y2−y1∣d(A,B)=∣x2−x1∣+∣y2−y1∣
В файле A хранятся данные о расположении грузов на двух участках склада, где каждый участок имеет размеры H = 10 и W = 20. В каждой строке записана информация о расположении одного груза: сначала координата x, затем координата y. Количество грузов в файле не превышает 1000.
В файле B хранятся данные о грузах на трёх участках склада, где каждый участок также имеет размеры H = 10 и W = 20. Количество грузов в файле не превышает 10 000. Структура хранения информации о грузах в файле B аналогична файлу A.
Для каждого файла определите координаты центра каждого участка (центроида), а затем вычислите два числа:
    Px — среднее арифметическое абсцисс центроидов участков,
    Py — среднее арифметическое ординат центроидов участков.
В ответе запишите четыре числа: в первой строке сначала целую часть абсолютного значения произведения Px∗1000 затем целую часть абсолютного значения произведения Py∗1000 для файла A; во второй строке — аналогичные данные для файла B.
Возможные данные одного из файлов иллюстрированы графиком. 

        Манхеттенское расстояние:

            def r(p1, p2):
                x1 = p1[0]
                x2 = p2[0]
                y1 = p1[1]
                y2 = p2[1]
                return abs(x2 - x1) + abs(y2 - y1)

        Для файла А:

            def r(p1, p2):
                x1 = p1[0]
                x2 = p2[0]
                y1 = p1[1]
                y2 = p2[1]
                return abs(x2 - x1) + abs(y2 - y1)

            def center(cl):
                l = []
                for p1 in cl: # потенциальный центр
                    sm = 0
                    for p2 in cl:
                        sm += r(p1, p2) # увеличиваем sm на расстояние от p1 до p2
                    l.append([sm, p1])
                return min(l)[1] # возвращаем точку, от которой расстояние до других минимально

            a = open('27_A_18314.txt')
            clusters = [[], []]
            for s in a:
                x, y = [float(t) for t in s.replace(',', '.').split()]
                if x < 24: clusters[0].append([x, y])
                else: clusters[1].append([x, y])

            res = list(center(t) for t in clusters)
            Px = sum(list(t[0] for t in res)) / len(res)
            Py = sum(list(t[1] for t in res)) / len(res)
            print(Px, Py)
            print(int(abs(Px * 1000)), int(abs(Py * 1000)))

        Для файла Б:

            def r(p1, p2):
                x1 = p1[0]
                x2 = p2[0]
                y1 = p1[1]
                y2 = p2[1]
                return abs(x2 - x1) + abs(y2 - y1)

            def center(cl):
                l = []
                for p1 in cl: # потенциальный центр
                    sm = 0
                    for p2 in cl:
                        sm += r(p1, p2) # увеличиваем sm на расстояние от p1 до p2
                    l.append([sm, p1])
                return min(l)[1] # возвращаем точку, от которой расстояние до других минимально

            a = open('27_B_18314.txt')
            clusters = [[], [], []]
            for s in a:
                x, y = [float(t) for t in s.replace(',', '.').split()]
                if x < -10: clusters[0].append([x, y])
                if -10 < x < 18: clusters[1].append([x, y])
                if x > 18: clusters[2].append([x, y])
            res = list(center(t) for t in clusters)
            Px = sum(list(t[0] for t in res)) / len(res)
            Py = sum(list(t[1] for t in res)) / len(res)
            print(Px, Py)
            print(int(abs(Px * 1000)), int(abs(Py * 1000)))

Фрагмент звёздного неба спроецирован на плоскость с декартовой системой координат. Учёный решил провести кластеризацию полученных точек, являющихся изображениями звёзд, то есть разбить их множество на N непересекающихся непустых подмножеств (кластеров) так, что они будут лежать внутри сектора окружности радиуса R = 50 с центральным углом 20°. Гарантируется, что такое разбиение существует и единственно.
Будем называть центром кластера точку этого кластера, сумма расстояний от которой до всех остальных точек кластера минимальна. Для каждого кластера гарантируется единственность его центра. Расстояние между двумя точками на плоскости A(x1,y1) и B(x2,y2) вычисляется по формуле: d(A,B)= ((x2 - x1)**2 + (y2 - y1)**2) ** 0.5
((x2 - x1)**2 + (y2 - y1)**2) ** 0.5
В файле А хранятся данные о звёздах трёх кластеров, для которых центром окружности является точка C (5, –9). В каждой строке записана информация о расположении на карте одной звезды: сначала координата х, затем координата у. Значения даны в условных единицах. Известно, что количество звёзд не превышает 1000.
В файле Б хранятся данные о звёздах шести кластеров, для которых центром окружности является точка C (–10, –7). Известно, что количество звёзд не превышает 10000. Структура хранения информации о звёздах в файле Б аналогична файлу А.
Для каждого файла определите координаты центра каждого кластера, затем вычислите два числа:  Px – среднее арифметическое абсцисс центров кластеров, и  Py – среднее арифметическое ординат центров кластеров.
В ответе запишите четыре числа: в первой строке сначала целая часть абсолютного значения произведения Px×10000, затем целая часть абсолютного значения произведения Py×10000 для файла А, во второй строке – аналогичные данные для файла B.
Возможные данные одного из файлов иллюстрированы графиком. 

    Евклидово расстояние:

        def rast(x1, x2, y1, y2):
            return ((x2 - x1)**2 + (y2 - y1)**2) ** 0.5

    Для файла А:

        def rast(x1, x2, y1, y2):
            return ((x2 - x1)**2 + (y2 - y1)**2) ** 0.5

        def center(cl):
            l = []
            for p1 in cl:
                sm = sum(list(rast(p1[0], p2[0], p1[1], p2[1]) for p2 in cl))
                l.append([sm, p1])
            return min(l)[1]

        a = open('27_A_21599.txt')
        clusters = [[], [], []]
        for s in a:
            x, y = list(float(t) for t in s.replace(',', '.').split())
            if y < -5: clusters[0].append([x, y])
            if y > x - 12: clusters[1].append([x, y])
            if -5 < y < x - 12: clusters[2].append([x, y])

        res = list(center(t) for t in clusters)
        Px = sum(list(t[0] for t in res)) / len(res)
        Py = sum(list(t[1] for t in res)) / len(res)
        print(int(abs(Px * 10000)), int(abs(Py * 10000)))

    Для файла Б:

        def f(x1, x2, y1, y2):
            k = (y2 - y1) / (x2 - x1)
            b = y1 - k * x1
            return [k, b]
        print(f(2, 6, 2, 5))
        print(f(-6, -5, 1, 3))
        print(f(-9, -10, 1, 9))
        print(f(-13, -15, 1, 4))

        # y = -5
        # y = 0.75x + 0.5
        # y = 2x + 13
        # y = -8x - 71
        # y -1.5x - 18

        def rast(x1, x2, y1, y2):
            return ((x2 - x1)**2 + (y2 - y1)**2) ** 0.5

        def center(cl):
            l = []
            for p1 in cl:
                sm = sum(list(rast(p1[0], p2[0], p1[1], p2[1]) for p2 in cl))
                l.append([sm, p1])
            return min(l)[1]

        a = open('27_B_21599.txt')
        clusters = [[], [], [], [], [], []]
        for s in a:
            x, y = list(float(t) for t in s.replace(',', '.').split())
            if y < -5: clusters[0].append([x, y])
            elif y < 0.75*x + 0.5: clusters[1].append([x, y])
            elif y < 2*x + 13: clusters[2].append([x, y])
            elif y > -8*x - 71: clusters[3].append([x, y])
            elif y > -1.5*x - 18: clusters[4].append([x, y])
            elif y > -5: clusters[5].append([x, y])    

        res = list(center(t) for t in clusters)
        Px = sum(list(t[0] for t in res)) / len(res)
        Py = sum(list(t[1] for t in res)) / len(res)
        print(int(abs(Px * 10000)), int(abs(Py * 10000)))

Учёный решил провести кластеризацию некоторого множества звёзд по их расположению на карте звёздного неба. Кластер звёзд – это набор звёзд (точек) на графике, лежащий внутри прямоугольника высотой H и шириной W. Каждая звезда обязательно принадлежит только одному из кластеров.
Истинный центр кластера, или центроид, – это одна из звёзд на графике, суммарное гравитационное воздействие которой на звёзды кластера минимально. Гравитационное воздействие между двумя звёздами равно произведению расстояния между ними на модуль разности гравитационного поля этих звёзд. Под расстоянием понимается расстояние Евклида между двумя точками A(x1, y1) и B(x2, y2) на плоскости, которое вычисляется по формуле: ((x2 - x1)**2 + (y2 - y1)**2)**0.5
В файле A хранятся данные о звёздах двух кластеров, где H=7, W=8 для каждого кластера. В каждой строке записана информация о расположении на карте одной звезды: сначала координата x, затем координата y, последним значением указано гравитационное поле g. Значения даны в условных единицах. Известно, что количество звёзд не превышает 1 000.
В файле B хранятся данные о звёздах трёх кластеров, где H=6, W=12 для каждого кластера. Известно, что количество звёзд не превышает 10 000. Структура хранения информации о звездах в файле B аналогична файлу А.
Для каждого файла определите координаты центроида каждого кластера, затем определите центроид гравитационное поле которого максимально.
В ответе запишите четыре числа: в первой строке сначала целую часть координаты х×1000, затем целую часть координаты y× 1000 найденного центроида для файла А, во второй строке – аналогичные данные для файла B.

    Для файла А:

        def rast(x1, x2, y1, y2):
            return ((x2 - x1)**2 + (y2 - y1)**2)**0.5

        def center(cl):
            l = []
            for p1 in cl:
                grav = sum(list(rast(p1[0], p2[0], p1[1], p2[1]) * abs(p1[2] - p2[2]) for p2 in cl))
                l.append([grav, p1])
            return min(l)[1]

        a = open('27_A_17953.txt')
        clust = [[], []]
        for s in a:
            x, y, g = list(float(t) for t in s.replace(',', '.').split())
            if y < 15: clust[0].append([x, y, g])
            else: clust[1].append([x, y, g])

        res = list(center(t) for t in clust)
        ans = max(list(center(t)[::-1] for t in clust)) 
        print(int((ans)[-1]*1000), int((ans)[-2]*1000))

    Для файла Б:

        def rast(x1, x2, y1, y2):
            return ((x2 - x1)**2 + (y2 - y1)**2)**0.5

        def center(cl):
            l = []
            for p1 in cl:
                grav = sum(list(rast(p1[0], p2[0], p1[1], p2[1]) * abs(p1[2] - p2[2]) for p2 in cl))
                l.append([grav, p1])
            return min(l)[1]

        a = open('27_B_17953.txt')
        clust = [[], [], []]
        for s in a:
            x, y, g = list(float(t) for t in s.replace(',', '.').split())
            if y < 6: clust[0].append([x, y, g])
            if y > 6 and x > 10: clust[1].append([x, y, g])
            if y > 11 and x < 10: clust[2].append([x, y, g])

        ans = max(list(center(t)[::-1] for t in clust)) 
        print(int((ans)[-1]*1000), int((ans)[-2]*1000))

Фрагмент звёздного неба спроецирован на плоскость с декартовой системой координат. Учёный решил провести кластеризацию полученных точек, являющихся изображениями звёзд, то есть разбить их множество на N непересекающихся непустых подмножеств (кластеров), таких что точки каждого подмножества лежат внутри прямоугольника со сторонами длиной H и W, причём эти прямоугольники между собой не пересекаются. Стороны прямоугольников не обязательно параллельны координатным осям. Гарантируется, что такое разбиение существует и единственно для заданных размеров прямоугольников.
Диаметром кластера назовём максимальное расстояние между двумя точками в кластере.  Расстояние между двумя точками на плоскости A(x1,y1) и B(x2,y2) вычисляется по формуле: ((x2 - x1)**2 + (y2 - y1)**2)**0.5
В файле A хранятся данные о звёздах четырёх кластеров, где H=3, W=3 для каждого кластера. В каждой строке записана информация о расположении на карте одной звезды: сначала координата x, затем координата y. Значения даны в условных единицах. Известно, что количество звёзд не превышает 1000.
В файле B хранятся данные о звёздах семи кластеров, где H=5, W=5 для каждого кластера. Известно, что количество звёзд не превышает 10 000. Структура хранения информации о звездах в файле B аналогична файлу А.
Для каждого файла определите диаметр каждого кластера, затем вычислите два числа: Dmin – минимальный диаметр кластера, и Davg – среднее арифметическое диаметров кластеров. В ответе запишите четыре числа: в первой строке сначала целую часть произведения Dmin×100000, затем целую часть произведения Davg×100000 для файла А, во второй строке – аналогичные данные для файла Б.

    Для файла А:

        def f(x1, x2, y1, y2):
            return ((x2 - x1)**2 + (y2 - y1)**2)**0.5
         
        def d(cl):
            l = []
            for p1 in cl:
                otr = max(f(p1[0], p2[0], p1[1], p2[1]) for p2 in cl)
                l.append(otr)
            return max(l)

        a = open('27A_20291.txt')
        clust = [[], [], [], []]
        for s in a:
            x, y = list(float(t) for t in s.replace(',', '.').split()) 
            if y < 0 and x < 1: clust[0].append([x, y])
            if y > 0 and x < 1: clust[1].append([x, y])
            if y < 2 and x > 3: clust[2].append([x, y])
            if y > 2 and x > 2: clust[3].append([x, y])

        Dcl = list(d(t) for t in clust)
        Davg = sum(Dcl) / len(Dcl)
        print(int(min(Dcl) * 100000), int(Davg * 100000))

    Для файла Б:

        def f(x1, x2, y1, y2):
            return ((x2 - x1)**2 + (y2 - y1)**2)**0.5
         
        def d(cl):
            l = []
            for p1 in cl:
                otr = max(f(p1[0], p2[0], p1[1], p2[1]) for p2 in cl)
                l.append(otr)
            return max(l)

        a = open('27B_20291.txt')
        clust = [[], [], [], [], [], [], []]
        for s in a:
            x, y = list(float(t) for t in s.replace(',', '.').split())
            if x < -4: clust[0].append([x, y])
            elif x < 1 and y < -4: clust[1].append([x, y])
            elif x < 1 and y > -2: clust[2].append([x, y])
            elif x > 1 and y < 1 and x < 6: clust[3].append([x, y])
            elif x > 1 and y > 1 and x < 6: clust[4].append([x, y])
            elif x > 6 and y > 3 and x < 11: clust[5].append([x, y])
            elif x > 6 and y < -1 and x < 11: clust[6].append([x, y])

        Dcl = list(d(t) for t in clust)
        Davg = sum(Dcl) / len(Dcl)
        print(int(min(Dcl) * 100000), int(Davg * 100000))

Фрагмент звёздного неба спроецирован на плоскость с декартовой системой координат. Учёный решил провести кластеризацию полученных точек, являющихся изображениями звёзд, то есть разбить их множество на N непересекающихся непустых подмножеств (кластеров), таких что точки каждого подмножества лежат внутри прямоугольника со сторонами длиной H и W, причём эти прямоугольники между собой не пересекаются. Стороны прямоугольников не обязательно параллельны координатным осям. Гарантируется, что такое разбиение существует и единственно для заданных размеров прямоугольников.
Точкой наведения назовём точку, в единичном окрестности от которой находится наибольшее количество точек кластера. Если таких точек несколько, то выбирается точка с наибольшей координатой x.  Расстояние между двумя точками на плоскости A(x1, y1) и B(x2, y2) вычисляется по формуле: d(A,B)=((x2 - x1)**2 + (y2 - y1)**2)**0.5
В файле A хранятся данные о звёздах четырёх кластеров, где H = 3, W = 3 для каждого кластера. В каждой строке записана информация о расположении на карте одной звезды: сначала координата x, затем координата y. Значения даны в условных единицах. Известно, что количество звёзд не превышает 1000.
В файле B хранятся данные о звёздах семи кластеров, где H = 5, W = 5 для каждого кластера. Известно, что количество звёзд не превышает 10 000. Структура хранения информации о звездах в файле B аналогична файлу А.
Для каждого файла определите координаты точки наведения каждого кластера, затем вычислите два числа: Px – среднее арифметическое абсцисс точек наведения кластеров, и Py –среднее арифметическое ординат точек наведения кластеров. В ответе запишите четыре числа: в первой строке сначала целую часть произведения ∣Px∣×100000, затем целую часть произведения ∣Py∣×100000 для файла А, во второй строке – аналогичные данные для файла Б.

    Для файла А:

        def rast(x1, x2, y1, y2):
            return ((x2 - x1)**2 + (y2 - y1)**2)**0.5

        def point(cl):
            l = []
            for p1 in cl:
                cnt = 0
                for p2 in cl:
                    if rast(p1[0], p2[0], p1[1], p2[1]) <= 1: cnt += 1
                l.append([cnt, p1[0], p1]) 
            return max(l)[2]

        a = open('27A_20293.txt')
        clusts = [[], [], [], []]
        for s in a:
            x, y = [float(t) for t in s.replace(',', '.').split()]
            if y < 0 and x < 1: clusts[0].append([x, y])
            elif y > 0 and x < 0: clusts[1].append([x, y])
            elif y > 2 and x > 2: clusts[2].append([x, y])
            else: clusts[3].append([x, y])

        res = [point(t) for t in clusts]
        Px = sum(t[0] for t in res) / len(res)
        Py = sum(t[1] for t in res) / len(res)
        print(int(abs(Px)*100000), int(abs(Py)*100000))

    Для файла Б:

        def rast(x1, x2, y1, y2):
            return ((x2 - x1)**2 + (y2 - y1)**2)**0.5

        def point(cl):
            l = []
            for p1 in cl:
                cnt = 0
                for p2 in cl:
                    if rast(p1[0], p2[0], p1[1], p2[1]) <= 1: cnt += 1
                l.append([cnt, p1[0], p1]) 
            return max(l)[2]

        a = open('27B_20293.txt')
        clusts = [[], [], [], [], [], [], []]
        for s in a:
            x, y = [float(t) for t in s.replace(',', '.').split()]
            if x < -4: clusts[0].append([x, y])
            elif y < -4 and x < 1: clusts[1].append([x, y])
            elif y > -2 and x < 1: clusts[2].append([x, y])
            elif x < 6 and y < 1: clusts[3].append([x, y])
            elif y > 1 and x < 6: clusts[4].append([x, y])
            elif x > 6 and y > 3: clusts[5].append([x, y])
            else: clusts[6].append([x, y])

        res = [point(t) for t in clusts]
        Px = sum(t[0] for t in res) / len(res)
        Py = sum(t[1] for t in res) / len(res)
        print(int(abs(Px)*100000), int(abs(Py)*100000))

СЛОЖНАЯ!!
Ведущие специалисты отдела бизнес-аналитики торгового маркетплейса «Ozonyol» собирают статистику и изучают предпочтения покупателей за период летних и осенних продаж. Перед ними стоит задача – проанализировать рынок и сделать выводы об уровне спроса на товары различных категорий для выделения наиболее перспективных траекторий развития площадки с привлечением инвестиционных средств. По итогам сбора информации имеется набор данных, включающий записи о товарах, каждый из которых содержит три показателя – номер сегмента товара, характеризующий его расположение на сайте, коэффициент успешных конверсий и уровень заинтересованности покупателей, выраженный в коэффициенте их активности. Общий спрос на товар вычисляется как среднее арифметическое второго и третьего показателей. На основании полученной информации строится графический отчёт, отражающий общий спрос на товар в зависимости от его номера сегмента, в котором записи, лежащие в области окружности с радиусом R, выделяются в отдельные кластеры. В итоге решено привлекать средства на продвижение товаров только из кластеров, содержащих хотя бы K записей, причем первые вложения направить в товары-медоиды. Медоидом (центром) кластера называется такая запись о товаре, суммарное расстояние от которой до других записей в кластере минимально. Метрикой расстояния между двумя записями A(x1, y1) и B(x2, y2) является формула Евклида: d(A,B)=((x2 - x1)**2 + (y2 - y1)**2)**0.5
Примечание. Гарантируется, что каждый товар принадлежит только одному из кластеров.
В файле A в первой строке записаны числа R и K. В остальных строках хранятся записи о товарах за период летних продаж, образующих 3 кластера. В каждой строке записана информация о трех показателях конкретного товара: сначала номер сегмента товара, затем коэффициент успешных конверсий и коэффициент активности. Известно, что количество записей не превышает 1100. В файле Б хранятся записи о товарах за период осенних продаж, образующих 6 кластеров, и соответствующие осенним продажам числа R и K. Известно, что количество записей не превышает 11 000. Структура хранения информации о товарах в файле Б аналогична файлу А. Возможные данные одного из файлов иллюстрированы графиком.
Для каждого файла определите координаты медоидов (центров) всех кластеров, для продвижения которых будут привлечены инвестиционные средства, а затем вычислите два числа: Sx – среднее арифметическое абсцисс центров кластеров, и Sy – среднее арифметическое ординат центров кластеров. В ответе запишите четыре числа: в первой строке сначала целую часть произведения Sx×100000, затем целую часть произведения Sy×100000 для файла А, во второй строке – аналогичные данные для файла Б.

    Для файла А:

        r, k = 2, 361

        def rast(x1, x2, y1, y2): return ((x2 - x1)**2 + (y2 - y1)**2)**0.5

        def center(cl):
            l = []
            for p1 in cl: 
                sm = sum([rast(p1[0], p2[0], p1[1], p2[1]) for p2 in cl])
                l.append([sm, p1])
            return min(l)[1]

        a = open('27_A_18585.txt')
        clusts = [[], [], []]
        for s in a:
            x, y, z = list(float(t) for t in s.replace(',', '.').split())
            os = (y + z) / 2
            if x < 4 and os < 4: clusts[0].append([x, (y + z) / 2])
            elif x > 6 and os < 4: clusts[1].append([x, (y + z) / 2])
            else: clusts[2].append([x, (y + z) / 2])

        clusts = [t for t in clusts if len(t) >= k]

        res = list(center(t) for t in clusts)
        Sx = sum(t[0] for t in res) / len(res)
        Sy = sum(t[1] for t in res) / len(res)
        print(int(Sx * 100000), int(Sy * 100000))

    Для файла Б:

        def f(x1, y1, x2, y2):
            k = (y2 - y1) / (x2 - x1)
            b = y1 - k * x1
            return [k, b]

        print(f(1, 4.5, 3, 1.5)) 
        print(f(4, 6.5, 6, 1))

        # y = -1.5x + 6
        # y = -2.75x + 17.5

        r, k = 1.37, 1706

        def rast(x1, x2, y1, y2): return ((x2 - x1)**2 + (y2 - y1)**2)**0.5

        def center(cl):
            l = []
            for p1 in cl: 
                sm = sum([rast(p1[0], p2[0], p1[1], p2[1]) for p2 in cl])
                l.append([sm, p1])
            return min(l)[1]

        a = open('27_B_18585.txt')
        clusts = [[], [], [], [], [], []]
        for s in a:
            x, y, z = list(float(t) for t in s.replace(',', '.').split())
            os = (y + z) / 2
            if os > 5 and x < 3.5: clusts[0].append([x, os])
            elif os > 9: clusts[1].append([x, os])
            elif 6 < os < 9: clusts[2].append([x, os]) 
            elif x > 5 and os < 6: clusts[3].append([x, os])
            elif os < -1.5 * x + 6: clusts[4].append([x, os])
            elif -1.5 * x + 6 < os < -2.75 * x + 17.5: clusts[5].append([x, os])

        clusts = [t for t in clusts if len(t) >= k]

        res = list(center(t) for t in clusts)
        Sx = sum(t[0] for t in res) / len(res)
        Sy = sum(t[1] for t in res) / len(res)
        print(int(Sx * 100000), int(Sy * 100000))

Океанограф проводит анализ множества островов по их расположению на карте. Каждый остров задаётся своими координатами (x, y). Два острова считаются соседними, если расстояние между ними по формуле Евклида
  d(A,B)=((x2 - x1)**2 + (y2 - y1)**2)**0.5
строго меньше 1 условной единицы.
При этом используется следующее определение архипелага и одиночного острова: острова принадлежат одному и тому же архипелагу, если между ними существует цепочка соседних островов (то есть, для любой пары островов A и B в архипелаге можно найти последовательность, тгде расстояние между соседними островами меньше 1).
Архипелагом считается только такое объединение островов, в котором общее количество островов не менее 20. Если какая-либо группа островов, связанная по вышеописанному принципу, содержит менее 20 островов, она не рассматривается как архипелаг, а все входящие в неё острова считаются одиночными и не учитываются в дальнейшем анализе.
Входные данные задаются в двух файлах: файл A и файл B. В каждой строке файлов содержатся координаты островов: сначала по оси x, затем по оси y. Количество островов не превышает 1000 для файла A и не превышает 11000 для файла B.
Антицентроидом архипелага называется такой остров, принадлежащий архипелагу, для которого сумма расстояний до всех остальных островов этого архипелага максимальна. При условии, что одиночные острова при расчётах игнорируются, требуется определить координаты Mx и My антицентроида с наибольшей суммой расстояний до других островов своего архипелага. 
В ответе запишите четыре числа: В первой строке — целые части абсолютных значений произведений Mx * 10000 и My * 10000 для файла A. Во второй строке — целые части абсолютных значений произведений Mx * 10000 и My * 10000 для файла B.

    Для файла А:

        def dist(x1, x2, y1, y2):
            return ((x2 - x1)**2 + (y2 - y1)**2)**0.5

        def anticenter(cl):
            l = []
            for p1 in cl:
                sm = sum(dist(p1[0], p2[0], p1[1], p2[1]) for p2 in cl)
                l.append([sm, p1])
            return max(l)

        a = open('27A_21223.txt')
        clusts = [[], [], []]
        for s in a:
            x, y = [float(t) for t in s.replace(',', '.').split()]
            if y > 20 and x < 0: clusts[0].append([x, y])
            if y > 20 and x > 0: clusts[1].append([x, y])
            if y < 0 and x > 20: clusts[2].append([x, y])

        m = max(anticenter(t) for t in clusts)[1]
        print(int(abs(m[0] * 10000)), int(abs(m[1] * 10000)))

    Для файла Б:

        def dist(x1, x2, y1, y2):
            return ((x2 - x1)**2 + (y2 - y1)**2)**0.5

        def anticenter(cl):
            l = []
            for p1 in cl:
                sm = sum(dist(p1[0], p2[0], p1[1], p2[1]) for p2 in cl)
                l.append([sm, p1])
            return max(l)

        a = open('27B_21223.txt')
        clusts = [[], [], [], [], []]
        for s in a:
            x, y = [float(t) for t in s.replace(',', '.').split()]
            if 9 < y < 17 and x < 0: clusts[0].append([x, y])
            elif y > 21 and -7 < x < 4: clusts[1].append([x, y])
            elif y > 23 and 11 < x < 20: clusts[2].append([x, y])
            elif y > 14 and 16 < x < 23: clusts[3].append([x, y])
            elif 0 < y < 12 and x > 23: clusts[4].append([x, y])

        m = max(anticenter(t) for t in clusts)[1]
        print(int(abs(m[0] * 10000)), int(abs(m[1] * 10000)))

 При проведении эксперимента заряженные частицы попадают на чувствительный экран размером 12 на 9 условных единиц. При попадании каждой частицы на экран в протоколе фиксируются координаты попадания в условных единицах. При анализе результатов выделяют кластеры – группы точек на экране, в которые попали частицы. Каждая точка принадлежит только одному кластеру. Минимальное (максимальное) расстояние между кластерами – это минимальное (максимальное) расстояние между двумя точками, одна из которых принадлежит одному кластеру, а вторая – другому. Расстояние между двумя точками A(x1, y1) и B(x2, y2) вычисляется по формуле d(A,B)=((x2 - x1)**2 + (y2 - y1)**2)**0.5
Назовём точками одного кластера такие точки, для которых выполняются оба условия:
    Для любой пары точек одного кластера можно найти последовательность , где расстояние между соседними точками P меньше 1, при этом в единичной окрестности точек одного кластера нет точек другого кластера или аномалий;
    Количество точек в кластере не менее 10.
Аномалии в расчётах не учитываются.
В файле A хранятся данные о частицах двух кластеров. В каждой строке записана информация о расположении на экране одной точки: сначала координата x, затем координата y (в условных единицах). Известно, что количество точек не превышает 1000. В файле Б хранятся данные о трёх кластерах. Известно, что количество точек не превышает 10 000. Структура хранения информации о точках в файле Б аналогична файлу А. Для каждого файла определите минимальное dmin и максимальное dmax расстояния между двумя кластерами. В ответ запишите 4 числа: в первой строке целую часть произведения dmin × 10000, затем целую часть произведения dmax × 10000 для файла А, во второй строке – аналогичные данные для файла Б.

    Для файла А:

        def rast(x1, x2, y1, y2): return ((x2 - x1)**2 + (y2 - y1)**2)**0.5

        def minmax(cl1, cl2):
            l = list(rast(r1[0], r2[0], r1[1], r2[1]) for r1 in cl1 for r2 in cl2)
            return [min(l), max(l)]

        a = open('27A_18052.txt')
        clusts = [[], []]
        for s in a:
            x, y = [float(t) for t in s.replace(',', '.').split()]
            if x < 6 and y < 5: clusts[0].append([x, y])
            if x > 5: clusts[1].append([x, y])

        res = minmax(clusts[0], clusts[1])
        print(res)
        print(int(res[0] * 10000), int(res[1] * 10000))

    Для файла Б:

        def rast(x1, x2, y1, y2): return ((x2 - x1)**2 + (y2 - y1)**2)**0.5

        def minmax(cl1, cl2, cl3):
            l = []
            l.extend(rast(r1[0], r2[0], r1[1], r2[1]) for r1 in cl1 for r2 in cl2)
            l.extend(rast(r1[0], r3[0], r1[1], r3[1]) for r1 in cl1 for r3 in cl3)
            l.extend(rast(r2[0], r3[0], r2[1], r3[1]) for r2 in cl2 for r3 in cl3)
            return [min(l), max(l)]

        a = open('27B_18052.txt')
        clusts = [[], [], []]
        for s in a:
            x, y = [float(t) for t in s.replace(',', '.').split()]
            if 1.5 < x < 5.5 and y < 4.5: clusts[0].append([x, y])
            elif y > 5.5 and x < 4.5: clusts[1].append([x, y])
            elif 7.5 < x < 10.5 and y < 6.5: clusts[2].append([x, y])

        res = minmax(clusts[0], clusts[1], clusts[2])
        print(res)
        print(int(res[0] * 10000), int(res[1] * 10000))

-------------------------------------

ПРАКТИКА:

Учёный решил провести кластеризацию некоторого множества звёзд по их расположению на карте звёздного неба. Кластер звёзд – это набор звёзд (точек) на графике, лежащий внутри прямоугольника высотой H и шириной W. Каждая звезда обязательно принадлежит только одному из кластеров.
Истинный центр кластера, или центроид, – это одна из звёзд на графике, сумма расстояний от которой до всех остальных звёзд кластера минимальна.
Под расстоянием понимается расстояние Евклида
В файле A хранятся данные о звёздах трёх кластеров, где H=5, W=5 для каждого кластера. В каждой строке записана информация о расположении на карте одной звезды: сначала координата x, затем координата y. Значения даны в условных единицах. Известно, что количество звёзд не превышает 1000.
В файле B хранятся данные о звёздах четырёх кластеров, где H=5, W=5 для каждого кластера. Известно, что количество звёзд не превышает 10 000. Структура хранения информации о звездах в файле B аналогична файлу А. 
Для каждого файла определите координаты центра каждого кластера, затем вычислите два числа:  Px – среднее арифметическое абсцисс центров кластеров, и  Py – среднее арифметическое ординат центров кластеров.
В ответе запишите четыре числа: в первой строке сначала целую часть произведения  Px×10000, затем целую часть произведения  Py×10000 для файла А, во второй строке – аналогичные данные для файла B.
Возможные данные одного из файлов иллюстрированы графиком. 

    Для файла А:

        def rast(x1, x2, y1, y2): return ((x2 - x1)**2 + (y2 - y1)**2)**0.5

        def center(cl): 
            l = []
            for p1 in cl:
                sm = sum(list(rast(p1[0], p2[0], p1[1], p2[1]) for p2 in cl))
                l.append([sm, p1])
            return min(l)[1]

        a = open('27_A_17915.txt')
        clusts = [[], [], []]
        for s in a:
            x, y = list(float(t) for t in s.replace(',', '.').split())
            if x < 6: clusts[0].append([x, y])
            elif x > 8 and y > 23: clusts[1].append([x, y])
            elif x > 8 and y < 23: clusts[2].append([x, y])

        res = list(center(t) for t in clusts)
        px = sum(list(t[0] for t in res)) / len(res)
        py = sum(list(t[1] for t in res)) / len(res)
        print(int(px * 10000), int(py * 10000))

    Для файла Б:

        def rast(x1, x2, y1, y2): return ((x2 - x1)**2 + (y2 - y1)**2)**0.5

        def center(cl): 
            l = []
            for p1 in cl:
                sm = sum(list(rast(p1[0], p2[0], p1[1], p2[1]) for p2 in cl))
                l.append([sm, p1])
            return min(l)[1]

        a = open('27_B_17915.txt')
        clusts = [[], [], [], []]
        for s in a:
            x, y = list(float(t) for t in s.replace(',', '.').split())
            if x > 22: clusts[0].append([x, y])
            elif y > 16 and 6 < x < 12: clusts[1].append([x, y])
            elif y < 10 and 10 < x < 15: clusts[2].append([x, y])
            elif y < 11 and 15 < x < 21: clusts[3].append([x, y])

        res = list(center(t) for t in clusts)
        print(res)
        px = sum(list(t[0] for t in res)) / len(res)
        py = sum(list(t[1] for t in res)) / len(res)
        print(int(px * 10000), int(py * 10000))

Фрагмент звёздного неба спроецирован на плоскость с декартовой системой координат. Учёный решил провести кластеризацию полученных точек, являющихся изображениями звёзд, то есть разбить их множество на N непересекающихся непустых подмножеств (кластеров), таких что точки каждого подмножества лежат внутри прямоугольника со сторонами длиной H и W, причём эти прямоугольники между собой не пересекаются. Стороны прямоугольников не обязательно параллельны координатным осям.
Гарантируется, что такое разбиение существует и единственно для заданных размеров прямоугольников.
Будем называть центром кластера точку этого кластера, сумма расстояний от которой до всех остальных точек кластера минимальна. Для каждого кластера гарантируется единственность его центра. Расстояние между двумя точками на плоскости вычисляется по формуле
В файле A хранятся данные о звёздах двух кластеров, где H=5, W=6 для каждого кластера. В каждой строке записана информация о расположении на карте одной звезды: сначала координата x, затем координата y. Значения даны в условных единицах. Известно, что количество звёзд не превышает 1000.
В файле B хранятся данные о звёздах трёх кластеров, где H=9, W=9 для каждого кластера. Известно, что количество звёзд не превышает 10 000. Структура хранения информации о звездах в файле B аналогична файлу А. 
Для каждого файла определите координаты центра каждого кластера, затем вычислите два числа:  Px – среднее арифметическое абсцисс центров кластеров, и  Py – среднее арифметическое ординат центров кластеров.
В ответе запишите четыре числа: в первой строке сначала целую часть абсолютного значения произведения Px×10000, затем целую часть абсолютного значения произведения Py×10000 для файла А, во второй строке – аналогичные данные для файла B.

Для файла А:

    def dist(x1, x2, y1, y2): return ((x2 - x1)**2 + (y2 - y1)**2)**0.5

    def center(cl):
        l = []
        for p1 in cl:
            sm = sum(list(dist(p1[0], p2[0], p1[1], p2[1]) for p2 in cl))
            l.append([sm, p1])
        return min(l)[1]

    a = open('27_A_21720.txt')
    clusts = [[], []]
    for s in a:
        x, y = list(float(t) for t in s.replace(',', '.').split())
        if y < -1.5: clusts[0].append([x, y])
        else: clusts[1].append([x, y])

    res = [center(t) for t in clusts]
    Px = sum([t[0] for t in res]) / len(res)
    Py = sum([t[1] for t in res]) / len(res)
    print(int(abs(Px * 10000)), int(abs(Py * 10000)))

Для файла Б:

    def dist(x1, x2, y1, y2): return ((x2 - x1)**2 + (y2 - y1)**2)**0.5

    def center(cl):
        l = []
        for p1 in cl:
            sm = sum(list(dist(p1[0], p2[0], p1[1], p2[1]) for p2 in cl))
            l.append([sm, p1])
        return min(l)[1]

    a = open('27_B_21720.txt')
    clusts = [[], [], []]
    for s in a:
        x, y = list(float(t) for t in s.replace(',', '.').split())
        if y > 5 and x < -6: clusts[0].append([x, y])
        elif y > 0: clusts[1].append([x, y])
        else: clusts[2].append([x, y])

    res = [center(t) for t in clusts]
    Px = sum([t[0] for t in res]) / len(res)
    Py = sum([t[1] for t in res]) / len(res)
    print(int(abs(Px * 10000)), int(abs(Py * 10000)))

Шёл 2077 год. Ученому необходимо провести кластеризацию населенных пунктов двух больших районов на картах планет Информатикус и Алгоритмикус. Район (кластер) – это группа населенных пунктов, которые находятся внутри прямоугольника высотой H и шириной W. Каждый населенный пункт обязательно принадлежит только одному району. Столица района (или центроид) – это такой населенный пункт, сумма манхэттенских расстояний от которого до всех других населённых пунктов в кластере минимальна. Манхэттенское расстояние между двумя точками A(x1, y1) и B(x2, y2) вычисляется по формуле: d(A,B)=∣x2−x1∣+∣y2−y1∣.
В файле A хранятся данные о точках двух кластеров. В каждой строке записана информация о расположении одной точки: сначала координата x, затем координата y (в условных единицах). Известно, что количество точек не превышает 1000. В файле Б той же структуры хранятся данные о точках трёх кластеров. Известно, что количество точек не превышает 10 000. Возможные данные одного из файлов иллюстрированы графиком.
Для каждого файла определите координаты центра каждого кластера, затем вычислите два числа: Px – среднее арифметическое абсцисс центров кластеров, и Py – среднее арифметическое ординат центров кластеров. В ответе запишите четыре числа: в первой строке сначала целую часть абсолютного значения произведения Px × 10000, затем целую часть абсолютного значения произведения Py × 10000 для файла А, во второй строке – аналогичные данные для файла Б.

Для файла А:

    def rast(x1, x2, y1, y2): return abs(x2 - x1) + abs(y2 - y1)

    def center(cl): 
        l = []
        for p1 in cl:
            l.append([sum(rast(p1[0], p2[0], p1[1], p2[1]) for p2 in cl), p1])
        return min(l)[1]

    a = open('27A_18053.txt')
    clusts = [[], []]
    for s in a:
        x, y = list(float(t) for t in s.replace(',', '.').split())
        if x < 0: clusts[0].append([x, y])
        else: clusts[1].append([x, y])

    res = list(center(t) for t in clusts)
    px = sum(list(t[0] for t in res)) / len(res)
    py = sum(list(t[1] for t in res)) / len(res)
    print(int(abs(px * 10000)), int(abs(py * 10000)))

Для файла Б:

    def rast(x1, x2, y1, y2): return abs(x2 - x1) + abs(y2 - y1)

    def center(cl): 
        l = []
        for p1 in cl:
            l.append([sum(rast(p1[0], p2[0], p1[1], p2[1]) for p2 in cl), p1])
        return min(l)[1]

    a = open('27B_18053.txt')
    clusts = [[], [], []]
    for s in a:
        x, y = list(float(t) for t in s.replace(',', '.').split())
        if y > -2: clusts[0].append([x, y])
        elif x > -3: clusts[1].append([x, y])
        else: clusts[2].append([x, y])

    res = list(center(t) for t in clusts)
    px = sum(list(t[0] for t in res)) / len(res)
    py = sum(list(t[1] for t in res)) / len(res)
    print(int(abs(px * 10000)), int(abs(py * 10000)))

 городе X тестируется проект по оптимизации размещения кранов на складах. Оптимальное местоположение для крана (или центроид) будет таким, при котором сумма расстояний Чебышева от этого места до всех других точек на складе была минимальной. Расстояние Чебышева между двумя точками вычисляется по формуле max(abs(x2 - x1), abs(y2 - y1))
В файле A хранятся данные о двух складских комплексах (кластерах). Каждый комплекс имеет форму прямоугольника размером H = 3 и W = 5. Каждая строка файла содержит координаты одной точки на складе: сначала x, затем y. Количество точек в каждом комплексе не превышает 1000. В файле Б той же структуры хранятся данные о трёх кластерах, каждый из которых имеет вид прямоугольника размером H = 6 и W = 8. Количество точек в каждом комплексе не превышает 10 000.
Для каждого файла определите координаты центра каждого кластера, затем вычислите два числа: Px – среднее арифметическое абсцисс центров кластеров, и Py – среднее арифметическое ординат центров кластеров. В ответе запишите четыре числа: в первой строке сначала целую часть абсолютного значения произведения Px × 10000, затем целую часть абсолютного значения произведения Py × 10000 для файла А, во второй строке – аналогичные данные для файла Б.

    Для файла А:

        def rast(x1, x2, y1, y2): return max(abs(x2 - x1), abs(y2 - y1))

        def center(cl):
            l = []
            for p1 in cl:
                l.append([sum(rast(p1[0], p2[0], p1[1], p2[1]) for p2 in cl), p1])
            return min(l)[1]

        a = open('27A_18054.txt')
        clusts = [[], []]
        for s in a:
            x, y = list(float(t) for t in s.replace(',', '.').split())
            if x < 2: clusts[0].append([x, y])
            else: clusts[1].append([x, y])

        res = [center(t) for t in clusts]
        px = sum(t[0] for t in res) / len(res)
        py = sum(t[1] for t in res) / len(res)
        print(int(abs(px * 10000)), int(abs(py * 10000)))

    Для файла Б:

        def rast(x1, x2, y1, y2): return max(abs(x2 - x1), abs(y2 - y1))

        def center(cl):
            l = []
            for p1 in cl:
                l.append([sum(rast(p1[0], p2[0], p1[1], p2[1]) for p2 in cl), p1])
            return min(l)[1]

        a = open('27B_18054.txt')
        clusts = [[], [], []]
        for s in a:
            x, y = list(float(t) for t in s.replace(',', '.').split())
            if x > 3: clusts[0].append([x, y])
            elif y > -2.5: clusts[1].append([x, y])
            else: clusts[2].append([x, y])

        res = [center(t) for t in clusts]
        print(res)
        px = sum(t[0] for t in res) / len(res)
        py = sum(t[1] for t in res) / len(res)
        print(int(abs(px * 10000)), int(abs(py * 10000)))

Фрагмент звёздного неба спроецирован на плоскость с декартовой системой координат. Учёный решил провести кластеризацию полученных точек, являющихся изображениями звёзд, то есть разбить их множество на N непересекающихся непустых подмножеств (кластеров), таких что точки каждого подмножества лежат внутри внутри сектора круга радиусом R и центральным углом H градусов, причём эти сектора между собой не пересекаются. Гарантируется, что такое разбиение существует и единственно для заданных размеров секторов. 
Будем называть центром кластера точку этого кластера, сумма расстояний от которой до всех остальных точек кластера минимальна. Для каждого кластера гарантируется единственность его центра. Расстояние между двумя точками на плоскости A(x1, y1) и B(x2, y2) вычисляется по формуле: d(A,B)=(x2 - x1)**2 + (y2 - y1)**2)**0.5
В файле A хранятся данные о звёздах о звёздах трёх кластеров с параметрами R=5 и H=30. В каждой строке записана информация о расположении на карте одной звезды: сначала координата x, затем координата y. Значения даны в условных единицах. Известно, что количество звёзд не превышает 1000.
В файле B хранятся данные о звёздах пяти кластеров с параметрами R=10 и H=45. Известно, что количество звёзд не превышает 10 000. Структура хранения информации о звездах в файле B аналогична файлу А. 
Для каждого файла определите координаты центра каждого кластера, затем вычислите два числа:  Px – среднее арифметическое абсцисс центров кластеров, и  Py – среднее арифметическое ординат центров кластеров.
В ответе запишите четыре числа: в первой строке сначала целая часть абсолютного значения произведения Px × 100000, затем целая часть абсолютного значения произведения Py × 100000 для файла А, во второй строке – аналогичные данные для файла B.

Для файла А:

    def f(x1, y1, x2, y2):
        k = (y2 - y1) / (x2 - x1)
        b = y1 - k * x1
        return [k, b]
    print(f(3, 7.5, 4.5, 8.25))

    # y = 0.5 * x + 6

    def rast(x1, x2, y1, y2): return ((x2 - x1)**2 + (y2 - y1)**2)**0.5

    def center(cl): 
        l = []
        for p1 in cl:
            l.append([sum(rast(p1[0], p2[0], p1[1], p2[1]) for p2 in cl), p1])
        return min(l)[1]

    a = open('27A_23297.txt')
    clusts = [[], []]
    for s in a:
        x, y = list(float(t) for t in s.replace(',', '.').split())
        if y > 0.5 * x + 6: clusts[0].append([x, y])
        else: clusts[1].append([x, y])
        
    res = [center(t) for t in clusts]
    px = sum(t[0] for t in res) / len(res)
    py = sum(t[1] for t in res) / len(res)
    print(int(abs(px * 100)), int(abs(py * 100)))

Для файла Б:

    def f(x1, y1, x2, y2):
        k = (y2 - y1) / (x2 - x1)
        b = y1 - k * x1
        return [k, b]
    print(f(1, 4, 3.5, 1))
    print(f(1, -2.5, 3, 0))
    print(f(-4, -1, -0.5, -4.5))

    # y = -1.2 * x + 5.2
    # y = 1.25 * x -3.75
    # y = -1 * x - 5

    def rast(x1, x2, y1, y2): return ((x2 - x1)**2 + (y2 - y1)**2)**0.5

    def center(cl): 
        l = []
        for p1 in cl:
            l.append([sum(rast(p1[0], p2[0], p1[1], p2[1]) for p2 in cl), p1])
        return min(l)[1]

    a = open('27B_23297.txt')
    clusts = [[], [], [], []]
    for s in a:
        x, y = list(float(t) for t in s.replace(',', '.').split())
        if y > -1.2 * x + 5.2: clusts[0].append([x, y])
        elif y < 1.25 * x -3.75: clusts[1].append([x, y])
        elif y < -1 * x - 5: clusts[2].append([x, y])
        else: clusts[3].append([x, y])

    res = [center(t) for t in clusts]
    print(res)
    px = sum(t[0] for t in res) / len(res)
    py = sum(t[1] for t in res) / len(res)
    print(int(abs(px * 100)), int(abs(py * 100)))

Фрагмент звёздного неба спроецирован на плоскость с декартовой системой координат. Учёный решил провести кластеризацию полученных точек, являющихся изображениями звёзд, то есть разбить их множество на N непересекающихся непустых подмножеств (кластеров), таких что точки каждого подмножества лежат внутри внутри сектора круга радиусом R и центральным углом H градусов, причём эти сектора между собой не пересекаются. Гарантируется, что такое разбиение существует и единственно для заданных размеров секторов. 
Будем называть центром кластера точку этого кластера, сумма расстояний от которой до всех остальных точек кластера минимальна. Для каждого кластера гарантируется единственность его центра. Расстояние между двумя точками на плоскости A(x1, y1) и B(x2, y2) вычисляется по формуле: 
В файле A хранятся данные о звёздах о звёздах трёх кластеров с параметрами R=5 и H=30. В каждой строке записана информация о расположении на карте одной звезды: сначала координата x, затем координата y. Значения даны в условных единицах. Известно, что количество звёзд не превышает 1000.
В файле B хранятся данные о звёздах пяти кластеров с параметрами R=10 и H=45. Известно, что количество звёзд не превышает 10 000. Структура хранения информации о звездах в файле B аналогична файлу А. 
Для каждого файла определите координаты центра каждого кластера, затем вычислите два числа:  Px​ – среднее арифметическое абсцисс центров кластеров, и  Py – среднее арифметическое ординат центров кластеров.
В ответе запишите четыре числа: в первой строке сначала целая часть абсолютного значения произведения Px​ × 100000, затем целая часть абсолютного значения произведения Py × 100000 для файла А, во второй строке – аналогичные данные для файла B.

Для файла А:
    
    def f(x1, x2, y1, y2): 
        k = (y2 - y1) / (x2 - x1)
        b = y1 - k * x1
        return [k, b]
    print(f(2, 3, 2, 3))

    # y = x

    def rast(x1, x2, y1, y2): return ((x2 - x1)**2 + (y2 - y1)**2)**0.5

    def center(cl):
        l = []
        for p1 in cl:
            l.append([sum(rast(p1[0], p2[0], p1[1], p2[1]) for p2 in cl), p1])
        return min(l)[1]

    a = open('27A_19747.txt')
    clusts = [[], [], []]
    for s in a:
        x, y = [float(t) for t in s.replace(',', '.').split()]
        if x < 5: clusts[0].append([x, y])
        elif y > 5: clusts[1].append([x, y])
        else: clusts[2].append([x, y])

    res = [center(t) for t in clusts]
    print(res)
    px = sum(t[0] for t in res) / len(res)
    py = sum(t[1] for t in res) / len(res)
    print(int(abs(px * 100000)), int(abs(py * 100000)))

Для файла Б:

    def rast(x1, x2, y1, y2): return ((x2 - x1)**2 + (y2 - y1)**2)**0.5

    def center(cl):
        l = []
        for p1 in cl:
            l.append([sum(rast(p1[0], p2[0], p1[1], p2[1]) for p2 in cl), p1])
        return min(l)[1]

    a = open('27B_19747.txt')
    clusts = [[], [], [], [], []]
    for s in a:
        x, y = [float(t) for t in s.replace(',', '.').split()]
        if y < 10 and x > 10: clusts[0].append([x, y])
        elif x > 10 and y < x: clusts[1].append([x, y])
        elif x > 10: clusts[2].append([x, y])
        elif x < 10 and y > x: clusts[3].append([x, y])
        else: clusts[4].append([x, y])

    res = [center(t) for t in clusts]
    print(res)
    px = sum(t[0] for t in res) / len(res)
    py = sum(t[1] for t in res) / len(res)
    print(int(abs(px * 100000)), int(abs(py * 100000)))

СЛОЖНАЯ!! 
Фрагмент звёздного неба спроецирован на плоскость с декартовой системой координат. Учёный решил провести кластеризацию полученных точек, являющихся изображениями звёзд, то есть разбить их множество на N непересекающихся непустых подмножеств (кластеров), таких что точки каждого подмножества лежат внутри прямоугольника со сторонами длиной H и W, причём эти прямоугольники между собой не пересекаются. Стороны прямоугольников не обязательно параллельны координатным осям. Гарантируется, что такое разбиение существует и единственно для заданных размеров прямоугольников.
Средним расстоянием назовём среднее арифметическое расстояние между всеми парами различных точек в кластере. Расстояние между двумя точками на плоскости A(x1, y1) и B(x2, y2) вычисляется по формуле: d(A,B)=((x2 - x1)**2 + (y2 - y1)**2)**0.5.
В файле A хранятся данные о звёздах четырёх кластеров, где H = 3, W = 3 для каждого кластера. В каждой строке записана информация о расположении на карте одной звезды: сначала координата x, затем координата y. Значения даны в условных единицах. Известно, что количество звёзд не превышает 1000.
В файле B хранятся данные о звёздах семи кластеров, где H = 5, W = 5 для каждого кластера. Известно, что количество звёзд не превышает 10 000. Структура хранения информации о звездах в файле B аналогична файлу А.
Для каждого файла определите среднее расстояние в каждом кластере, затем вычислите два числа: Smin – минимальное среднее расстояние кластера, и Smax – максимальное среднее расстояние кластера. В ответе запишите четыре числа: в первой строке сначала целую часть произведения Smin × 100000, затем целую часть произведения Smax × 100000 для файла А, во второй строке – аналогичные данные для файла Б.

Для файла А:

    def rast(x1, x2, y1, y2): return ((x2 - x1)**2 + (y2 - y1)**2)**0.5

    def sr(cl):
        l = []
        for p1 in cl:
            l.extend([rast(p1[0], p2[0], p1[1], p2[1]) for p2 in cl if p1 != p2])
        return sum(l) / len(l)

    a = open('27A_20292.txt')
    clusts = [[], [], [], []]
    for s in a:
        x, y = list(float(t) for t in s.replace(',', '.').split())
        if x < 0 and y > 0: clusts[0].append([x, y])
        elif y < 0 and x < 1: clusts[1].append([x, y])
        elif y > 2: clusts[2].append([x, y])
        else: clusts[3].append([x, y])

    res = [sr(t) for t in clusts]
    smin = min(res)
    smax = max(res)
    print(int(smin * 100000), int(smax * 100000))

Для файла Б:

    def rast(x1, x2, y1, y2): return ((x2 - x1)**2 + (y2 - y1)**2)**0.5

    def sr(cl):
        l = []
        for p1 in cl:
            l.extend([rast(p1[0], p2[0], p1[1], p2[1]) for p2 in cl if p1 != p2])
        return sum(l) / len(l)

    a = open('27B_20292.txt')
    clusts = [[], [], [], [], [], [], []]
    for s in a:
        x, y = list(float(t) for t in s.replace(',', '.').split())
        if x < -4: clusts[0].append([x, y])
        elif y < -4 and x < 1: clusts[1].append([x, y])
        elif y > -2 and x < 1: clusts[2].append([x, y])
        elif y > 1 and x < 6: clusts[3].append([x, y])
        elif y < 1 and x < 6: clusts[4].append([x, y])
        elif y > 3: clusts[5].append([x, y])
        else: clusts[6].append([x, y])

    res = [sr(t) for t in clusts]
    print(res)
    smin = min(res)
    smax = max(res)
    print(int(smin * 100000), int(smax * 100000))

СЛОЖНАЯ!!
Фрагмент звёздного неба спроецирован на плоскость с декартовой системой координат. Учёный решил провести кластеризацию полученных точек, являющихся изображениями звёзд, то есть разбить их множество на N непересекающихся непустых подмножеств (кластеров), таких что точки каждого подмножества лежат внутри прямоугольника со сторонами длиной H и W, причём эти прямоугольники между собой не пересекаются. Стороны прямоугольников не обязательно параллельны координатным осям. Гарантируется, что такое разбиение существует и единственно для заданных размеров прямоугольников.
Изолированной точкой назовём точку, в единичном окрестности от которой находится наименьшее количество точек кластера. Если таких точек несколько, то выбирается точка с наибольшей координатой y. Расстояние между двумя точками на плоскости A(x1, y1) и B(x2, y2) вычисляется по формуле Евклида.
В файле A хранятся данные о звёздах четырёх кластеров, где H = 3, W = 3 для каждого кластера. В каждой строке записана информация о расположении на карте одной звезды: сначала координата x, затем координата y. Значения даны в условных единицах. Известно, что количество звёзд не превышает 1000.
В файле B хранятся данные о звёздах семи кластеров, где H = 5, W = 5 для каждого кластера. Известно, что количество звёзд не превышает 10 000. Структура хранения информации о звездах в файле B аналогична файлу А.
Для каждого файла определите координаты изолированной точки каждого кластера, затем вычислите два числа: Px – среднее арифметическое абсцисс изолированных точек  кластеров, и Py –среднее арифметическое ординат изолированных точек  кластеров. В ответе запишите четыре числа: в первой строке сначала целую часть произведения ∣Px∣ × 100000, затем целую часть произведения ∣Py∣ × 100000 для файла А, во второй строке – аналогичные данные для файла Б.

    Для файла А:

        def dist(x1, x2, y1, y2): return ((x2 - x1)**2 + (y2 - y1)**2)**0.5

        def point(cl):
            l = []
            for p1 in cl:
                c = 0
                for p2 in cl: 
                    if dist(p1[0], p2[0], p1[1], p2[1]) <= 1: c += 1
                l.append([c, -p1[1], p1])
            return min(l)[2]

        a = open('27A_20294.txt')
        clusts = [[], [], [], []]
        for s in a:
            x, y = list(float(t) for t in s.replace(',', '.').split())
            if y > 0 and x < 0: clusts[0].append([x, y])
            elif y < 0 and x < 1: clusts[1].append([x, y])
            elif y > 2: clusts[2].append([x, y])
            else: clusts[3].append([x, y])

        res = [point(t) for t in clusts]
        print(res)
        px = sum(t[0] for t in res) / len(res)
        py = sum(t[1] for t in res) / len(res)
        print(int(abs(px) * 100000), int(abs(py) * 100000))

    Для файла Б:

        def dist(x1, x2, y1, y2): return ((x2 - x1)**2 + (y2 - y1)**2)**0.5

        def point(cl):
            l = []
            for p1 in cl:
                c = 0
                for p2 in cl: 
                    if dist(p1[0], p2[0], p1[1], p2[1]) <= 1: c += 1
                l.append([c, -p1[1], p1])
            return min(l)[2]

        a = open('27B_20294.txt')
        clusts = [[], [], [], [], [], [], []]
        for s in a:
            x, y = list(float(t) for t in s.replace(',', '.').split())
            if x < -4: clusts[0].append([x, y])
            elif y < -4 and x < 1: clusts[1].append([x, y])
            elif y > -2 and x < 1: clusts[2].append([x, y])
            elif y > 1 and x < 6: clusts[3].append([x, y])
            elif y < 1 and x < 6: clusts[4].append([x, y])
            elif y > 3: clusts[5].append([x, y])
            else: clusts[6].append([x, y])

        res = [point(t) for t in clusts]
        print(res)
        px = sum(t[0] for t in res) / len(res)
        py = sum(t[1] for t in res) / len(res)
        print(px, py)
        print(int(abs(px) * 100000), int(abs(py) * 100000))

Учёный решил провести кластеризацию некоторого множества звёзд по их расположению на карте звёздного неба. Кластер звёзд – это набор звёзд (точек) на  графике, лежащий внутри прямоугольника высотой H и шириной W. Каждая  звезда обязательно принадлежит  только одному  из кластеров. Под расстоянием между двумя кластерами понимается минимальное расстояние между двумя звёздами этих кластеров, а расстояние между двумя точками A(x1, y1) и B(x2, y2) на плоскости вычисляется по формуле Евклида.
В файле A хранятся данные о звёздах двух кластеров, где H = W = 3 для каждого кластера. В каждой строке записана информация о расположении на карте  одной  звезды:  сначала  координата  x,  затем  координата  y. Значения даны в условных единицах, которые представлены вещественными числами. Известно, что количество звёзд не превышает 1000.  В файле Б хранятся данные о звёздах пяти кластеров, где H = W = 2 для каждого кластера. Известно, что количество  звёзд  не превышает 10 000. Структура хранения информации о звездах в файле Б аналогична файлу А. 
Для каждого файла определите два кластера, расстояние между которыми минимально, и затем вычислите два числа: Sx – сумму координат абсцисс точек, образующих минимальное расстояние между этими кластерами, и Sy – сумму координат ординат этих точек. 
В  ответе  запишите четыре  числа:  в  первой  строке  сначала целую часть произведения Sx × 1000, затем целую часть произведения Sy × 1000 для файла А, во второй строке – аналогичные данные для файла Б.

    Для файла А:

        def rast(x1, x2, y1, y2): return ((x2 - x1)**2 + (y2 - y1)**2)**0.5

        def rr(cl1, cl2):
            l = list([rast(p1[0], p2[0], p1[1], p2[1]), p1, p2] for p1 in cl1 for p2 in cl2)
            return min(l)

        a = open('27A_18031.txt')
        clusts = [[], []]
        for s in a:
            x, y = [float(t) for t in s.replace(',', '.').split()]
            if x < 1: clusts[0].append([x, y])
            else: clusts[1].append([x, y])

        res = rr(clusts[0], clusts[1])
        sx = res[1][0] + res[2][0]
        sy = res[1][1] + res[2][1]
        print(int(sx * 1000), int(sy * 1000))

    Для файла Б:

        def rast(x1, x2, y1, y2): return ((x2 - x1)**2 + (y2 - y1)**2)**0.5

        def rr(cl1, cl2):
            l = list([rast(p1[0], p2[0], p1[1], p2[1]), p1, p2] for p1 in cl1 for p2 in cl2)
            return min(l)

        a = open('27B_18031.txt')
        clusts = [[], [], [], [], []]
        for s in a:
            x, y = [float(t) for t in s.replace(',', '.').split()]
            if x > 13: clusts[0].append([x, y])
            elif y > 14: clusts[1].append([x, y])
            elif y > 10: clusts[2].append([x, y])
            elif y > 6: clusts[3].append([x, y])
            else: clusts[4].append([x, y])

        res = []
        for i in range(len(clusts) - 1):
            for j in range(i + 1, len(clusts)):
                res.append(rr(clusts[i], clusts[j]))
        mr = min(res)
        sx = mr[1][0] + mr[2][0]
        sy = mr[1][1] + mr[2][1]
        print(int(sx * 1000), int(sy * 1000))

Океанограф проводит анализ множества островов по их расположению на карте. Каждый остров задаётся своими координатами (x, y). Два острова считаются соседними, если расстояние между ними по формуле Евклида
При этом используется следующее определение архипелага и одиночного острова: острова принадлежат одному и тому же архипелагу, если между ними существует цепочка соседних островов (то есть, для любой пары островов A и B в архипелаге можно найти последовательность,
где расстояние между соседними островами меньше 1).
Архипелагом считается только такое объединение островов, в котором общее количество островов не менее 20. Если какая-либо группа островов, связанная по вышеописанному принципу, содержит менее 20 островов, она не рассматривается как архипелаг, а все входящие в неё острова считаются одиночными и не учитываются в дальнейшем анализе.
Входные данные задаются в двух файлах: файл A и файл B. В каждой строке файлов содержатся координаты островов: сначала по оси x, затем по оси y. Количество островов не превышает 1000 для файла A и не превышает 11000 для файла B.
Антицентроидом архипелага называется такой остров, принадлежащий архипелагу, для которого сумма расстояний до всех остальных островов этого архипелага максимальна. При условии, что одиночные острова при расчётах игнорируются, требуется определить координаты Mx и My антицентроида с наименьшей суммой расстояний до других островов своего архипелага. 
В ответе запишите четыре числа: В первой строке — целые части абсолютных значений произведений Mx * 10000 и My * 10000 для файла A. Во второй строке — целые части абсолютных значений произведений Mx * 10000 и My * 10000 для файла B.

    Для файла А:

        def dist(x1, x2, y1, y2): return ((x2 - x1)**2 + (y2 - y1)**2)**0.5

        def anticenter(cl):
            l = []
            for p1 in cl:
                l.append([sum(dist(p1[0], p2[0], p1[1], p2[1]) for p2 in cl), p1])
            return max(l)

        a = open('27A_21224.txt')
        clusts = [[], [], []]
        for s in a:
            x, y = [float(t) for t in s.replace(',', '.').split()]
            if y < 0 and x > 20: clusts[0].append([x, y])
            elif y > 20 and x > 0: clusts[1].append([x, y])
            elif y > 20 and x < 0: clusts[2].append([x, y])

        clusts = [t for t in clusts if len(t) > 20]
        res = [anticenter(t) for t in clusts]
        point = min(res)
        print(int(abs(point[1][0] * 10000)), int(abs(point[1][1] * 10000)))

    Для файла Б:

        def dist(x1, x2, y1, y2): return ((x2 - x1)**2 + (y2 - y1)**2)**0.5

        def anticenter(cl):
            l = []
            for p1 in cl:
                l.append([sum(dist(p1[0], p2[0], p1[1], p2[1]) for p2 in cl), p1])
            return max(l)

        a = open('27B_21224.txt')
        clusts = [[], [], [], [], []]
        for s in a:
            x, y = [float(t) for t in s.replace(',', '.').split()]
            if x < -20 and -10 < y < 20: clusts[0].append([x, y])
            elif y > 20 and -10 < x < 10: clusts[1].append([x, y])
            elif y > 22 and 10 < x < 20: clusts[2].append([x, y])
            elif y > 14 and 16 < x < 24: clusts[3].append([x, y])
            elif 0 < y < 12 and x > 24: clusts[4].append([x, y])

        clusts = [t for t in clusts if len(t) > 20]
        res = [anticenter(t) for t in clusts]
        point = min(res)
        print(int(abs(point[1][0] * 10000)), int(abs(point[1][1] * 10000)))

В лесу выделено несколько мест (кластеров), где растёт много деревьев, предназначенных для вырубки. После спиливания дерева его нужно доставить в точку сбора, которая совпадает с одним из деревьев кластера. Стоимость доставки определяется как расстояние от дерева до точки сбора, умноженное на высоту дерева. Расстояние между двумя точками A(x1, y1) и B(x2, y2)вычисляется по формуле Евклида.
В каждом кластере нужно найти оптимальную точку сбора (центр), такую что суммарная стоимость доставки в это место всех спиленных деревьев данного кластера минимальна. Аномалиями назовём совокупности из не более чем 10 точек, каждая из которых находится на расстоянии более 30 м от точек кластеров. Аномалии в расчётах не учитываются.
В файле A хранятся данные о двух кластерах. Каждый кластер имеет форму прямоугольника размером 100×100 м. Каждая строка файла содержит три характеристики одного дерева: координату x, затем координату y и затем высоту дерева. Количество деревьев в каждом кластере не превышает 1000. В файле Б той же структуры хранятся данные о трёх кластерах, каждый из которых имеет вид прямоугольника размером не более 100 × 200 м. Количество точек в каждом кластере не превышает 10 000.
Для каждого файла определите координаты центра каждого кластера, затем вычислите два числа: Px – среднее арифметическое абсцисс центров кластеров, и Py – среднее арифметическое ординат центров кластеров. В ответе запишите четыре числа: в первой строке сначала целую часть абсолютного значения произведения Px × 100000, затем целую часть абсолютного значения произведения Py × 100000 для файла А, во второй строке – аналогичные данные для файла Б.

    Для файла А:

        def rast(x1, x2, y1, y2): return ((x2 - x1)**2 + (y2 - y1)**2)**0.5

        def center(cl):
            l = []
            for p1 in cl:
                l.append([sum(rast(p1[0], p2[0], p1[1], p2[1]) * p2[2] for p2 in cl), p1])
            return min(l)[1]

        a = open('27A_18055.txt')
        clusts = [[], []]
        for s in a:
            x, y, z = [float(t) for t in s.replace(',', '.').split()]
            if x < 175: clusts[0].append([x, y, z])
            if x > 325: clusts[1].append([x, y, z])

        res = [center(t) for t in clusts]
        px = sum(t[0] for t in res) / len(res)
        py = sum(t[1] for t in res) / len(res)
        print(int(abs(px * 100000)), int(abs(py * 100000)))

    Для файла Б:

        def rast(x1, x2, y1, y2): return ((x2 - x1)**2 + (y2 - y1)**2)**0.5

        def center(cl):
            l = []
            for p1 in cl:
                l.append([sum(rast(p1[0], p2[0], p1[1], p2[1]) * p2[2] for p2 in cl), p1])
            return min(l)[1]

        a = open('27B_18055.txt')
        clusts = [[], [], []]
        for s in a:
            x, y, z = [float(t) for t in s.replace(',', '.').split()]
            if y > -25 and -125 < x < 25: clusts[0].append([x, y, z])
            elif y < 0 and x < 0: clusts[1].append([x, y, z])
            elif 75 < x < 225: clusts[2].append([x, y, z])

        res = [center(t) for t in clusts]
        print(res)
        px = sum(t[0] for t in res) / len(res)
        py = sum(t[1] for t in res) / len(res)
        print(int(abs(px * 100000)), int(abs(py * 100000)))

ОЧЕНЬ СЛОЖНАЯ!!!

Фрагмент звёздного неба спроецирован на плоскость с декартовой системой координат. Учёный решил провести кластеризацию полученных точек, являющихся изображениями звёзд, то есть разбить их множество на N непересекающихся непустых подмножеств (кластеров), таких что точки каждого подмножества лежат внутри прямоугольника со сторонами длиной H и W, причём эти прямоугольники между собой не пересекаются. Стороны прямоугольников не обязательно параллельны координатным осям. Гарантируется, что такое разбиение существует и единственно для заданных размеров прямоугольников.
Будем называть центром кластера точку этого кластера, сумма расстояний от которой до всех остальных точек кластера минимальна. Для каждого кластера гарантируется единственность его центра. Расстояние между двумя точками на плоскости A(x1, y1) и B(x2, y2) вычисляется по формуле Евклида.
Аномалиями назовём звёзды, находящиеся на расстоянии более одной условной единицы от звёзд кластеров. При расчётах аномалии учитывать не нужно.
В файле А хранятся данные о звёздах двух кластеров, где H = 16, W = 16 для каждого кластера. В каждой строке записана информация о расположение на карте одной звезды: сначала координата х, затем координата у. Значения даны в условных единицах. Известно, что количество точек не превышает 1000.
В файле Б хранятся данные о звёздах трёх кластеров, где H = 12, W = 12 для каждого кластера. Известно, что количество точек не превышает 10 000. Структура хранения информации о звездах в файле Б аналогична файлу А.
Известно, что в файле Б имеются координаты ровно трёх «лишних» точек, являющихся аномалиями, возникшими в результате помех при передаче данных. Эти три точки не относятся ни к одному из кластеров, их учитывать не нужно.
Для файла А определите координаты центра каждого кластера, затем вычислите два числа: Px - среднее арифметическое абсцисс центров кластеров, и Ру - среднее арифметическое ординат центров кластеров.
Для файла Б определите координаты центра каждого кластера, затем вычислите два числа: Q1 - расстояние между центрами кластеров с минимальным и максимальным количеством точек, Q2 - максимальное расстояние между центром и точкой кластера с минимальным или максимальным количеством точек.
Гарантируется, что во всех кластерах количество точек различно.
В ответе запишите четыре числа: в первой строке - сначала целую часть абсолютного значения произведения Рx х 10 000, затем целую часть абсолютного значения произведения Ру х 10 000; во второй строке - сначала целую часть абсолютного значения произведения Q1 x 10 000, затем целую часть абсолютного значения произведения Q2 x 10 000.

    Для файла А:

        def dist(x1, x2, y1, y2): return ((x2 - x1)**2 + (y2 - y1)**2)**0.5

        def center(cl):
            l = []
            for p1 in cl:
                l.append([sum(dist(p1[0], p2[0], p1[1], p2[1]) for p2 in cl), p1])
            return min(l)[1]

        a = open('27A_23226.txt')
        clusts = [[], []]
        for s in a:
            x, y = [float(t) for t in s.replace(',', '.').split()]
            if y > 3: clusts[0].append([x, y])
            else: clusts[1].append([x, y])

        res = [center(t) for t in clusts]
        px = sum(t[0] for t in res) / len(res)
        py = sum(t[1] for t in res) / len(res)
        print(int(abs(px * 10000)), int(abs(py * 10000)))

    Для файла Б:

        def dist(x1, x2, y1, y2): return ((x2 - x1)**2 + (y2 - y1)**2)**0.5

        def center(cl):
            l = []
            for p1 in cl:
                l.append([sum(dist(p1[0], p2[0], p1[1], p2[1]) for p2 in cl), p1])
            return min(l)[1]

        a = open('27B_23226.txt')
        clusts = [[], [], []]
        for s in a:
            x, y = [float(t) for t in s.replace(',', '.').split()]
            if x > 0 and y > 4: clusts[0].append([x, y])
            elif x > 0 and y < 2: clusts[1].append([x, y])
            elif y < 0 and -4 < x < 0: clusts[2].append([x, y])

        minCL = clusts[0]
        maxCL = clusts[1]
        minCENTER = center(minCL)
        maxCENTER = center(maxCL)

        q1 = dist(minCENTER[0], maxCENTER[0], minCENTER[1], maxCENTER[1])

        def maxRast(cntr, cl):
            l = [dist(cntr[0], p[0], cntr[1], p[1]) for p in cl]
            return max(l)
        m1 = maxRast(minCENTER, minCL)
        m2 = maxRast(maxCENTER, maxCL)
        q2 = max(m1, m2)

        print(int(abs(q1 * 10000)), int(abs(q2 * 10000)))