Пример кластеризации:

	data = []
	for s in f:
	    x, y = [float(t) for t in s.replace(',', '.').split()]
	    data.append([x, y])
	clusts = []
	eps = 0.5 # эпсилон
	while data: # до тех пор, пока есть неизученные точки
	    clusts.append([data.pop()]) # мы собираем из них новые кластеры
	    for p1 in clusts[-1]: # перебираем точки из текущего кластера
	        nb = [p2 for p2 in data if rast(p1[0], p2[0], p1[1], p2[1]) <= eps] # создаем список соседних точек (по eps) 
	        clusts[-1].extend(nb) # добавляем в текущий кластер список соседних точек
	        for p in nb: data.remove(p) # удаляем все уже изученные точки из набора данных

Сокращённый вариант:

	data = [[float(t) for t in s.replace(',', '.').split()] for s in open('27B_20295.txt')]
	clusts = []
	while data:
	    clusts.append([data.pop()])
	    for p1 in clusts[-1]:
	        nb = [p2 for p2 in data if dist(p1, p2) < 0.4]
	        clusts[-1].extend(nb)
	        for p in nb: data.remove(p)

Учёный решил провести кластеризацию некоторого множества звёзд по их расположению на карте звёздного неба. Кластер звёзд – это набор звёзд (точек) на графике, лежащий внутри прямоугольника высотой H и шириной W. Каждая звезда обязательно принадлежит только одному из кластеров.
Истинный центр кластера, или центроид, – это одна из звёзд на графике, сумма расстояний от которой до всех остальных звёзд кластера минимальна.
Под расстоянием понимается расстояние Евклида между двумя точками A(x1,y1) и B(x2,y2) на плоскости, которое вычисляется по формуле Евклида о звёздах трёх кластеров, где H=5, W=5 для каждого кластера. В каждой строке записана информация о расположении на карте одной звезды: сначала координата x, затем координата y. Значения даны в условных единицах. Известно, что количество звёзд не превышает 1000.
В файле B хранятся данные о звёздах четырёх кластеров, где H=5, W=5 для каждого кластера. Известно, что количество звёзд не превышает 10 000. Структура хранения информации о звездах в файле B аналогична файлу А. 
Для каждого файла определите координаты центра каждого кластера, затем вычислите два числа:  Px – среднее арифметическое абсцисс центров кластеров, и  Py – среднее арифметическое ординат центров кластеров.
В ответе запишите четыре числа: в первой строке сначала целую часть произведения  Px×10000, затем целую часть произведения  Py×10000 для файла А, во второй строке – аналогичные данные для файла B.
Возможные данные одного из файлов иллюстрированы графиком. 

	Для файла А:

		def rast(x1, x2, y1, y2): return ((x2 - x1)**2 + (y2 - y1)**2)**0.5

		def center(cl):
		    l = []
		    for p1 in cl:
		        l.append([sum(rast(p1[0], p2[0], p1[1], p2[1]) for p2 in cl), p1])
		    return min(l)[1]

		f = open('27_A_17915.txt')
		data = []
		for s in f:
		    x, y = [float(t) for t in s.replace(',', '.').split()]
		    data.append([x, y])
		clusts = []
		eps = 0.5
		while data:
		    clusts.append([data.pop()])
		    for p1 in clusts[-1]:
		        nb = [p2 for p2 in data if rast(p1[0], p2[0], p1[1], p2[1]) <= eps]
		        clusts[-1].extend(nb)
		        for p in nb: data.remove(p)
		res = [center(t) for t in clusts]
		px = sum(t[0] for t in res) / len(res)
		py = sum(t[1] for t in res) / len(res)
		print(int(px * 10000), int(py * 10000))

	Для файла Б: аналогично.

На складе с автоматической системой управления работают роботы, которые собирают грузы, расположенные на разных участках склада. Склад представляет собой прямоугольную сетку высотой H и шириной W. Каждый робот может перемещаться только вдоль осей сетки (вверх, вниз, влево, вправо), поэтому для оценки расстояний между объектами используется манхэттенское расстояние.
Группа инженеров решила оптимизировать работу роботов, минимизировав общее время сбора грузов. Для этого необходимо определить координаты груза в каждом участке склада, для которой сумма расстояний от неё до всех грузов на участке будет минимальной. Эта точка называется центроидом. Робот, находящийся в центроиде, сможет быстрее собрать все грузы на своём участке.
Под расстоянием между двумя точками A(x1,y1) и B(x2,y2) понимается манхэттенское расстояние, которое вычисляется по формуле:
d(A,B)=∣x2−x1∣+∣y2−y1∣d(A,B)=∣x2−x1∣+∣y2−y1∣
В файле A хранятся данные о расположении грузов на двух участках склада, где каждый участок имеет размеры H=10 и W=20. В каждой строке записана информация о расположении одного груза: сначала координата xx, затем координата yy. Количество грузов в файле не превышает 1000.
В файле B хранятся данные о грузах на трёх участках склада, где каждый участок также имеет размеры H=10 и W=20. Количество грузов в файле не превышает 10 000. Структура хранения информации о грузах в файле B аналогична файлу A.
Для каждого файла определите координаты центра каждого участка (центроида), а затем вычислите два числа:
    Px — среднее арифметическое абсцисс центроидов участков,
    Py — среднее арифметическое ординат центроидов участков.
В ответе запишите четыре числа: в первой строке сначала целую часть абсолютного значения произведения Px∗1000 затем целую часть абсолютного значения произведения Py∗1000 для файла A; во второй строке — аналогичные данные для файла B.
Возможные данные одного из файлов иллюстрированы графиком. 

	Для файла А:

		def rast(x1, x2, y1, y2): return abs(x2 - x1) + abs(y2 - y1)

		def center(cl):
		    l = []
		    for p1 in cl:
		        l.append([sum(rast(p1[0], p2[0], p1[1], p2[1]) for p2 in cl), p1])
		    return min(l)[1]

		a = open('27_A_18314.txt')
		data = [[float(t) for t in s.replace(',', '.').split()] for s in a]
		clusts = []
		while data:
		    clusts.append([data.pop()])
		    for p1 in clusts[-1]:
		        nb = [p2 for p2 in data if rast(p1[0], p2[0], p1[1], p2[1]) <= 2]
		        clusts[-1].extend(nb)
		        for p in nb: data.remove(p)

		res = [center(t) for t in clusts]
		px = sum(t[0] for t in res) / len(res)
		py = sum(t[1] for t in res) / len(res)
		print(int(abs(px * 1000)), int(abs(py * 1000)))

	Для файла Б: аналогично.

Учёный решил провести кластеризацию некоторого множества звёзд по их расположению на карте звёздного неба.  Каждая звезда обязательно принадлежит только одному из кластеров или является аномалией. Центр кластера, или центроид, – это одна из звёзд на графике, сумма расстояний от которой до всех остальных звёзд кластера минимальна. Расстояние между двумя точками A(x1,y1) и B(x2,y2) вычисляется по формуле Евклида.
Назовём точками одного кластера такие точки, для которых выполняются оба условия:
Для любой пары точек одного кластера можно найти последовательность, где расстояние между соседними сигналами Pi и Pi+1 меньше 1, при этом в единичной окрестности точек одного кластера нет точек другого кластера или аномалий;
Количество точек в кластере не менее 30.
В файле A хранятся данные о звёздах двух кластеров. В каждой строке записана информация о расположении на карте одной звезды: сначала координата x, затем координата y (в условных единицах). Известно, что количество звёзд не превышает 1000. В файле Б хранятся данные о звёздах трёх кластеров. Известно, что количество звёзд не превышает 10 000. Структура хранения информации о звездах в файле Б аналогична файлу А. Возможные данные одного из файлов иллюстрированы графиком.
Для каждого файла определите координаты центра каждого кластера, затем вычислите два числа: Px – среднее арифметическое абсцисс центров кластеров, и Py – среднее арифметическое ординат центров кластеров. В ответе запишите четыре числа: в первой строке сначала целую часть произведения Px×100000, затем целую часть произведения Py×100000 для файла А, во второй строке – аналогичные данные для файла Б.

	Для файла А:

		def rast(x1, x2, y1, y2): return ((x2 - x1)**2 + (y2 - y1)**2)**0.5

		def center(cl):
		    l = []
		    for p1 in cl:
		        l.append([sum(rast(p1[0], p2[0], p1[1], p2[1]) for p2 in cl), p1])
		    return min(l)[1]

		a = open('27B_18630.txt')
		data = [[float(t) for t in s.replace(',', '.').split()] for s in a]
		clusts = []
		while data:
		    clusts.append([data.pop()])
		    for p1 in clusts[-1]:
		        nb = [p2 for p2 in data if rast(p1[0], p2[0], p1[1], p2[1]) < 1]
		        clusts[-1].extend(nb)
		        for p in nb: data.remove(p)

		clusts = [t for t in clusts if len(t) >= 30]
		res = [center(t) for t in clusts]
		px = sum(t[0] for t in res) / len(res)
		py = sum(t[1] for t in res) / len(res)
		print(int(px * 100000), int(py * 100000))

	Для файла Б: аналогично.

ОЧЕНЬ СЛОЖНАЯ!!
Популярная компания по доставке продуктов «Быстрокат» расширяется и хочет открыть новые филиалы в двух густонаселенных районах города. Для открытия отдела логистам необходимо выбрать самую подходящую геолокацию для оптимизации организации процессов по координации и доставке товаров,  для чего им нужно проанализировать множество жилых единиц (геопозиций). Каждый район состоит из нескольких микрорайонов, включающих в себя некоторое количество геопозиций. Известно, что каждый микрорайон характеризуется тем, что любая из его геопозиций удалена от любой геопозиции из других микрорайонов хотя бы на R у.е. (условных единиц). Для анализа данных используется предоставленный набор вещественных точек (геопозиций), размещенных на декартовой оси координат. Они характеризуют все геопозиции конкретного района, который представляет собой квадрат размером 10 у.е. (условных единиц). С целью определить оптимальную геолокацию для открытия филиала логисты вычисляют медоид (райцентр) каждого микрорайона, который определяется как такая геопозиция внутри одного микрорайона, суммарное расстояние от которой до всех других геопозиций этого же микрорайона минимально. Затем специалисты определяют конечный медоид, опираясь на данные о расположении ранее найденных медоидов, – такую геопозицию, суммарное расстояние от которой до всех медоидов минимально. Именно в этой геопозиции и будет затем открыт новый филиал. При проведении расчетов также исключаются аномальные геопозиции, случайно попавшие в представленный набор данных. Они определяются как точки, расстояние от которых до любой другой точки в наборе данных превышает K у.е. (условных единиц). Метрикой расстояния между двумя геопозициями (точками) A(x1,y1) и B(x2,y2) на плоскости является формула Евклида.
В файле A хранятся данные обо всех геопозициях первого района. В первой строке записаны значения R и K для этого района. В каждой из следующих строк записана информация о расположении в районе одной геопозиции:  сначала  координата  x,  затем  координата  y. Значения даны в условных единицах, которые представлены вещественными числами. Известно, что количество геопозиций не превышает 2000. В файле Б хранятся данные обо всех геопозициях второго района. В первой строке записаны значения R и K для этого района. Известно, что количество геопозиций не превышает 30 000. Структура хранения информации о звездах в файле Б аналогична файлу А. 
Для каждого файла определите геопозицию, в которой будет открыт филиал. В ответе запишите четыре числа: в первой строке сначала целую часть произведения координаты x этой геопозиции на 10000, затем целую часть произведения координаты y этой геопозиции на 10000 для файла А, во второй строке – аналогичные данные для файла Б.

	Для файла А:

		def rast(x1, x2, y1, y2): return ((x2 - x1)**2 + (y2 - y1)**2)**0.5

		def center(cl):
		    l = []
		    for p1 in cl:
		        l.append([sum(rast(p1[0], p2[0], p1[1], p2[1]) for p2 in cl), p1])
		    return min(l)[1]

		a = open('27_A_18390(1).txt')
		R, K = [float(t) for t in a.readline().replace(',', '.').split()]
		data = [[float(t) for t in s.replace(',', '.').split()] for s in a]
		validPoints = [p1 for p1 in data if not all(rast(p1[0], p2[0], p1[1], p2[1]) > K for p2 in data if p1 != p2)]
		pointsCopy = validPoints.copy()

		clusts = []
		while validPoints:
		    clusts.append([validPoints.pop()])
		    for p1 in clusts[-1]:
		        nb = [p2 for p2 in validPoints if rast(p1[0], p2[0], p1[1], p2[1]) < R]
		        clusts[-1].extend(nb)
		        for p in nb: validPoints.remove(p)

		res = [center(t) for t in clusts]
		def center2(cl, cl2):
		    l = []
		    for p1 in cl:
		        l.append([sum(rast(p1[0], p2[0], p1[1], p2[1]) for p2 in cl2), p1])
		    return min(l)[1]

		x = center2(pointsCopy, res)
		print(int(x[0] * 10000), int(x[1] * 10000))

В лаборатории проводится эксперимент, состоящий из множества испытаний. Результат каждого испытания представляется в виде пары чисел. Для визуализации результатов эта пара рассматривается как координаты точки на плоскости, и на чертеже отмечаются точки, соответствующие всем испытаниям.
По результатам эксперимента проводится кластеризация полученных результатов: на плоскости выделяется несколько кластеров - прямоугольников размером 3×3 так, что каждая точка попадает ровно в один кластер.
Центроидом кластера называется та из входящих в него точек, для которой минимальна сумма расстояний до всех остальных точек кластера.
Обработка результатов эксперимента включает следующие шаги:
1) кластер, содержащий наибольшее число точек, исключается;
2) определяются центроиды всех оставшихся кластеров;
3) для найденных центроидов вычисляется средняя точка. Средней для группы точек называется точка (не обязательно входящая в группу), координаты которой определяются как средние арифметические значения координат всех точек группы.
В файле записан протокол проведения эксперимента. Каждая строка файла содержит два числа: координаты X и Y точки, соответствующей одному испытанию. По данному протоколу надо определить среднюю точку центроидов всех кластеров за исключением содержащего наибольшее число точек.
Вам даны два входных файла (A и B), каждый из которых имеет описанную выше структуру. По данным каждого из представленных файлов определите координаты средней точки по описанным выше правилам. 
В ответе запишите четыре числа: сначала (в первой строке) координаты X и Y средней точки для файла A, затем (во второй строке) координаты X и Y средней точки для файла B.
В качестве значения координаты указывайте целую часть от умножения числового значения координаты на 10 000.
Примечание. Расстояние вычисляется по формуле Евклида.

	Для файла А:

		def rast(x1, x2, y1, y2): return ((x2 - x1)**2 + (y2 - y1)**2)**0.5

		def center(cl):
		    l = []
		    for p1 in cl:
		        l.append([sum(rast(p1[0], p2[0], p1[1], p2[1]) for p2 in cl), p1])
		    return min(l)[1]

		def srPoint(l):
		    srX = sum(t[0] for t in l) / len(l)
		    srY = sum(t[1] for t in l) / len(l)
		    return [srX, srY]

		a = open('27A_18622.txt')
		data = [[float(t) for t in s.replace(',', '.').split()] for s in a]
		clusts = []
		while data:
		    clusts.append([data.pop()])
		    for p1 in clusts[-1]:
		        nb = [p2 for p2 in data if rast(p1[0], p2[0], p1[1], p2[1]) < 0.5]
		        clusts[-1].extend(nb)
		        for p in nb: data.remove(p)

		maxLen = max(len(t) for t in clusts)
		clusts = [t for t in clusts if len(t) < maxLen]

		res = [center(t) for t in clusts]
		srRes = srPoint(res)
		x = int(srRes[0] * 10000)
		y = int(srRes[1] * 10000)
		print(x, y)

	Для файла Б: аналогично

-------------------------------------

ПРАКТИКА:

В городе X тестируется проект по оптимизации размещения кранов на складах. Оптимальное местоположение для крана (или центроид) будет таким, при котором сумма расстояний Чебышева от этого места до всех других точек на складе была минимальной. Расстояние Чебышева между двумя точками A(x1,y1) и B(x2,y2) вычисляется по формуле Евклида.
В файле A хранятся данные о двух складских комплексах (кластерах). Каждый комплекс имеет форму прямоугольника размером H = 3 и W = 5. Каждая строка файла содержит координаты одной точки на складе: сначала x, затем y. Количество точек в каждом комплексе не превышает 1000. В файле Б той же структуры хранятся данные о трёх кластерах, каждый из которых имеет вид прямоугольника размером H = 6 и W = 8. Количество точек в каждом комплексе не превышает 10 000.
Для каждого файла определите координаты центра каждого кластера, затем вычислите два числа: Px – среднее арифметическое абсцисс центров кластеров, и Py – среднее арифметическое ординат центров кластеров. В ответе запишите четыре числа: в первой строке сначала целую часть абсолютного значения произведения Px×10000, затем целую часть абсолютного значения произведения Py×10000 для файла А, во второй строке – аналогичные данные для файла Б.

	Для файла А:

		def rast(x1, x2, y1, y2): return ((x2 - x1)**2 + (y2 - y1)**2)**0.5
		 
		def center(cl):
		    l = []
		    for p1 in cl:
		        l.append([sum(rast(p1[0], p2[0], p1[1], p2[1]) for p2 in cl), p1])
		    return min(l)[1]

		a = open('27_A_20911.txt')
		data = [[float(t) for t in s.replace(',', '.').split()] for s in a]
		clusts = []
		while data:
		    clusts.append([data.pop()])
		    for p1 in clusts[-1]:
		        nb = [p2 for p2 in data if rast(p1[0], p2[0], p1[1], p2[1]) < 1.5]
		        clusts[-1].extend(nb)
		        for p in nb: data.remove(p)

		res = [center(t) for t in clusts]
		px = sum(t[0] for t in res) / len(res)
		py = sum(t[1] for t in res) / len(res)
		print(int(abs(px * 10000)), int(abs(py * 10000)))

	Для файла Б: аналогично.

В городе X тестируется проект по оптимизации размещения кранов на складах. Оптимальное местоположение для крана (или центроид) будет таким, при котором сумма расстояний Чебышева от этого места до всех других точек на складе была минимальной. Расстояние Чебышева между двумя точками A(x1,y1) и B(x2,y2) вычисляется по формуле d(A,B)=max(∣x2−x1∣,∣y2−y1∣).d(A,B)=max(∣x2−x1∣,∣y2−y1∣).
В файле A хранятся данные о двух складских комплексах (кластерах). Каждый комплекс имеет форму прямоугольника размером H = 3 и W = 5. Каждая строка файла содержит координаты одной точки на складе: сначала x, затем y. Количество точек в каждом комплексе не превышает 1000. В файле Б той же структуры хранятся данные о трёх кластерах, каждый из которых имеет вид прямоугольника размером H = 6 и W = 8. Количество точек в каждом комплексе не превышает 10 000.
Для каждого файла определите координаты центра каждого кластера, затем вычислите два числа: Px – среднее арифметическое абсцисс центров кластеров, и Py – среднее арифметическое ординат центров кластеров. В ответе запишите четыре числа: в первой строке сначала целую часть абсолютного значения произведения Px×10000, затем целую часть абсолютного значения произведения Py×10000 для файла А, во второй строке – аналогичные данные для файла Б.

	Для файла А:

		from math import dist

		def rast(x1, x2, y1, y2): return max(abs(x2 - x1), abs(y2 - y1))

		def center(cl):
		    l = []
		    for p1 in cl:
		        l.append([sum(rast(p1[0], p2[0], p1[1], p2[1]) for p2 in cl), p1])
		    return min(l)[1]

		a = open('27A_18054.txt')
		data = [[float(t) for t in s.replace(',', '.').split()] for s in a]
		clusts = []
		while data:
		    clusts.append([data.pop()])
		    for p1 in clusts[-1]:
		        nb = [p2 for p2 in data if dist(p1, p2) < 1]
		        clusts[-1].extend(nb)
		        for p in nb: data.remove(p)

		res = [center(t) for t in clusts]
		px = sum(t[0] for t in res) / len(res)
		py = sum(t[1] for t in res) / len(res)
		print(int(abs(px * 10000)), int(abs(py * 10000)))

	Для файла Б: аналогично, но eps = 0.5

Фрагмент звёздного неба спроецирован на плоскость с декартовой системой координат. Учёный решил провести кластеризацию полученных точек, являющихся изображениями звёзд, то есть разбить их множество на N непересекающихся непустых подмножеств (кластеров), таких что точки каждого подмножества лежат внутри прямоугольника со сторонами длиной H и W, причём эти прямоугольники между собой не пересекаются. Стороны прямоугольников не обязательно параллельны координатным осям.
Гарантируется, что такое разбиение существует и единственно для заданных размеров прямоугольников.
Будем называть центром кластера точку этого кластера, сумма расстояний от которой до всех остальных точек кластера минимальна. Для каждого кластера гарантируется единственность его центра. Расстояние между двумя точками на плоскости A(x1,y1) и B(x2,y2) вычисляется по формуле Евклида.
В файле A хранятся данные о звёздах десяти кластеров, где H=2, W=2 для каждого кластера. В каждой строке записана информация о расположении на карте одной звезды: сначала координата x, затем координата y. Значения даны в условных единицах. Известно, что количество звёзд не превышает 1000. В файле B хранятся данные о звёздах ста кластеров, где H=2, W=2 для каждого кластера. Известно, что количество звёзд не превышает 10 000. Структура хранения информации о звездах в файле B аналогична файлу А. Для каждого файла определите координаты центра каждого кластера, затем вычислите два числа:  Px – среднее арифметическое абсцисс центров кластеров, и  Py – среднее арифметическое ординат центров кластеров. В ответе запишите четыре числа: в первой строке сначала целую часть произведения  Px×10000, затем целую часть произведения  Py×10000 для файла А, во второй строке – аналогичные данные для файла B.
Возможные данные одного из файлов иллюстрированы графиком.
Гарантируется, что расстояние между любыми двумя точками разных кластеров превышает 1.

	Для файла А:

		from math import dist

		def center(cl):
		    l = []
		    for p1 in cl:
		        l.append([sum(dist(p1, p2) for p2 in cl), p1])
		    return min(l)[1]

		a = open('27_A_19153.txt')
		data = [[float(t) for t in s.replace(',', '.').split()] for s in a]
		clusts = []
		while data:
		    clusts.append([data.pop()])
		    for p1 in clusts[-1]:
		        nb = [p2 for p2 in data if dist(p1, p2) < 1]
		        clusts[-1].extend(nb)
		        for p in nb: data.remove(p)

		res = [center(t) for t in clusts]
		px = sum([t[0] for t in res]) / len(res)
		py = sum([t[1] for t in res]) / len(res)
		print(int(px * 10000), int(py * 10000))

	Для файла Б: аналогично

Фрагмент звёздного неба спроецирован на плоскость с декартовой системой координат. Учёный решил провести кластеризацию полученных точек, являющихся изображениями звёзд, то есть разбить их множество на N непересекающихся непустых подмножеств (кластеров), таких что точки каждого подмножества лежат внутри прямоугольника со сторонами длиной H и W, причём эти прямоугольники между собой не пересекаются. Стороны прямоугольников не обязательно параллельны координатным осям. Гарантируется, что такое разбиение существует и единственно для заданных размеров прямоугольников.
Плотностью кластера назовём среднее арифметическое количества точек в единичной окрестности для каждой точки кластера (включая эту точку).  Расстояние между двумя точками на плоскости A(x1,y1) и B(x2,y2) вычисляется по формуле Евклида.
В файле A хранятся данные о звёздах четырёх кластеров, где H=3, W=3 для каждого кластера. В каждой строке записана информация о расположении на карте одной звезды: сначала координата x, затем координата y. Значения даны в условных единицах. Известно, что количество звёзд не превышает 1000.
В файле B хранятся данные о звёздах семи кластеров, где H=5, W=5 для каждого кластера. Известно, что количество звёзд не превышает 10 000. Структура хранения информации о звездах в файле B аналогична файлу А.
Для каждого файла определите плотность каждого кластера, затем вычислите два числа: Pmin – минимальная плотность кластера, и Pavg – среднее арифметическое плотности кластеров. В ответе запишите четыре числа: в первой строке сначала целую часть произведения Pmin×100000, затем целую часть произведения Pavg×100000 для файла А, во второй строке – аналогичные данные для файла Б.

	Для файла А:

		from math import dist

		def pl(cl):
		    l = []
		    for p1 in cl:
		        l.append(len([p2 for p2 in cl if dist(p1, p2) <= 1]))
		    return sum(l) / len(l)

		data = [[float(t) for t in s.replace(',', '.').split()] for s in open('27A_20295.txt')]
		clusts = []
		while data:
		    clusts.append([data.pop()])
		    for p1 in clusts[-1]:
		        nb = [p2 for p2 in data if dist(p1, p2) < 1]
		        clusts[-1].extend(nb)
		        for p in nb: data.remove(p)

		res = [pl(t) for t in clusts]
		pmin = min(res)
		pavg = sum(res) / len(res)
		print(int(pmin * 100000), int(pavg * 100000))

	Для файла Б: аналогично, но eps = 0.4

Учёный решил провести кластеризацию некоторого множества звёзд по их расположению на карте звёздного неба.  Каждая звезда обязательно принадлежит только одному из кластеров или является аномалией. Центр кластера, или центроид, – это одна из звёзд на графике, сумма расстояний от которой до всех остальных звёзд кластера минимальна. Расстояние между двумя точками A(x1,y1) и B(x2,y2) вычисляется по формуле Евклида.
 Назовём точками одного кластера такие точки, для которых выполняются оба условия:
    - Для любой пары точек одного кластера можно найти последовательность меньше 1, при этом в единичной окрестности точек одного кластера нет точек другого кластера или аномалий;
    - Количество точек в кластере не менее 30.
В файле A хранятся данные о звёздах двух кластеров. В каждой строке записана информация о расположении на карте одной звезды: сначала координата x, затем координата y (в условных единицах). Известно, что количество звёзд не превышает 1000. В файле Б хранятся данные о звёздах трёх кластеров. Известно, что количество звёзд не превышает 10 000. Структура хранения информации о звездах в файле Б аналогична файлу А. Возможные данные одного из файлов иллюстрированы графиком.
Для каждого файла определите координаты центра каждого кластера, затем вычислите два числа: Px – среднее арифметическое абсцисс центров кластеров, и Py – среднее арифметическое ординат центров кластеров. В ответе запишите четыре числа: в первой строке сначала целую часть произведения Px×100000, затем целую часть произведения Py×100000 для файла А, во второй строке – аналогичные данные для файла Б.

	Для файла А:

		from math import dist

		def center(cl):
		    l = []
		    for p1 in cl:
		        l.append([sum(dist(p1, p2) for p2 in cl), p1])
		    return min(l)[1]

		data = [[float(t) for t in s.replace(',', '.').split()] for s in open('27A_18629.txt')]
		clusts = []
		while data:
		    clusts.append([data.pop()])
		    for p1 in clusts[-1]:
		        nb = [p2 for p2 in data if dist(p1, p2) < 1]
		        clusts[-1].extend(nb)
		        for p in nb: data.remove(p)
		clusts = [t for t in clusts if len(t) >= 30]

		res = [center(t) for t in clusts]
		px = sum(t[0] for t in res) / len(res)
		py = sum(t[1] for t in res) / len(res)
		print(int(px * 100000), int(py * 100000))

	Для файла Б: аналогично