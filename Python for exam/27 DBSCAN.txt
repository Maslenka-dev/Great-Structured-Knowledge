Пример кластеризации:

	data = []
	for s in f:
	    x, y = [float(t) for t in s.replace(',', '.').split()]
	    data.append([x, y])
	clusts = []
	eps = 0.5 # эпсилон
	while data: # до тех пор, пока есть неизученные точки
	    clusts.append([data.pop()]) # мы собираем из них новые кластеры
	    for p1 in clusts[-1]: # перебираем точки из текущего кластера
	        nb = [p2 for p2 in data if rast(p1[0], p2[0], p1[1], p2[1]) <= eps] # создаем список соседних точек (по eps) 
	        clusts[-1].extend(nb) # добавляем в текущий кластер список соседних точек
	        for p in nb: data.remove(p) # удаляем все уже изученные точки из набора данных

Сокращённый вариант:

	data = [[float(t) for t in s.replace(',', '.').split()] for s in open('27B_20295.txt')]
	clusts = []
	while data:
	    clusts.append([data.pop()])
	    for p1 in clusts[-1]:
	        nb = [p2 for p2 in data if dist(p1, p2) < 0.4]
	        clusts[-1].extend(nb)
	        for p in nb: data.remove(p)

Учёный решил провести кластеризацию некоторого множества звёзд по их расположению на карте звёздного неба. Кластер звёзд – это набор звёзд (точек) на графике, лежащий внутри прямоугольника высотой H и шириной W. Каждая звезда обязательно принадлежит только одному из кластеров.
Истинный центр кластера, или центроид, – это одна из звёзд на графике, сумма расстояний от которой до всех остальных звёзд кластера минимальна.
Под расстоянием понимается расстояние Евклида между двумя точками A(x1,y1) и B(x2,y2) на плоскости, которое вычисляется по формуле Евклида о звёздах трёх кластеров, где H=5, W=5 для каждого кластера. В каждой строке записана информация о расположении на карте одной звезды: сначала координата x, затем координата y. Значения даны в условных единицах. Известно, что количество звёзд не превышает 1000.
В файле B хранятся данные о звёздах четырёх кластеров, где H=5, W=5 для каждого кластера. Известно, что количество звёзд не превышает 10 000. Структура хранения информации о звездах в файле B аналогична файлу А. 
Для каждого файла определите координаты центра каждого кластера, затем вычислите два числа:  Px – среднее арифметическое абсцисс центров кластеров, и  Py – среднее арифметическое ординат центров кластеров.
В ответе запишите четыре числа: в первой строке сначала целую часть произведения  Px×10000, затем целую часть произведения  Py×10000 для файла А, во второй строке – аналогичные данные для файла B.
Возможные данные одного из файлов иллюстрированы графиком. 

	Для файла А:

		def rast(x1, x2, y1, y2): return ((x2 - x1)**2 + (y2 - y1)**2)**0.5

		def center(cl):
		    l = []
		    for p1 in cl:
		        l.append([sum(rast(p1[0], p2[0], p1[1], p2[1]) for p2 in cl), p1])
		    return min(l)[1]

		f = open('27_A_17915.txt')
		data = []
		for s in f:
		    x, y = [float(t) for t in s.replace(',', '.').split()]
		    data.append([x, y])
		clusts = []
		eps = 0.5
		while data:
		    clusts.append([data.pop()])
		    for p1 in clusts[-1]:
		        nb = [p2 for p2 in data if rast(p1[0], p2[0], p1[1], p2[1]) <= eps]
		        clusts[-1].extend(nb)
		        for p in nb: data.remove(p)
		res = [center(t) for t in clusts]
		px = sum(t[0] for t in res) / len(res)
		py = sum(t[1] for t in res) / len(res)
		print(int(px * 10000), int(py * 10000))

	Для файла Б: аналогично.

На складе с автоматической системой управления работают роботы, которые собирают грузы, расположенные на разных участках склада. Склад представляет собой прямоугольную сетку высотой H и шириной W. Каждый робот может перемещаться только вдоль осей сетки (вверх, вниз, влево, вправо), поэтому для оценки расстояний между объектами используется манхэттенское расстояние.
Группа инженеров решила оптимизировать работу роботов, минимизировав общее время сбора грузов. Для этого необходимо определить координаты груза в каждом участке склада, для которой сумма расстояний от неё до всех грузов на участке будет минимальной. Эта точка называется центроидом. Робот, находящийся в центроиде, сможет быстрее собрать все грузы на своём участке.
Под расстоянием между двумя точками A(x1,y1) и B(x2,y2) понимается манхэттенское расстояние, которое вычисляется по формуле:
d(A,B)=∣x2−x1∣+∣y2−y1∣d(A,B)=∣x2−x1∣+∣y2−y1∣
В файле A хранятся данные о расположении грузов на двух участках склада, где каждый участок имеет размеры H=10 и W=20. В каждой строке записана информация о расположении одного груза: сначала координата xx, затем координата yy. Количество грузов в файле не превышает 1000.
В файле B хранятся данные о грузах на трёх участках склада, где каждый участок также имеет размеры H=10 и W=20. Количество грузов в файле не превышает 10 000. Структура хранения информации о грузах в файле B аналогична файлу A.
Для каждого файла определите координаты центра каждого участка (центроида), а затем вычислите два числа:
    Px — среднее арифметическое абсцисс центроидов участков,
    Py — среднее арифметическое ординат центроидов участков.
В ответе запишите четыре числа: в первой строке сначала целую часть абсолютного значения произведения Px∗1000 затем целую часть абсолютного значения произведения Py∗1000 для файла A; во второй строке — аналогичные данные для файла B.
Возможные данные одного из файлов иллюстрированы графиком. 

	Для файла А:

		def rast(x1, x2, y1, y2): return abs(x2 - x1) + abs(y2 - y1)

		def center(cl):
		    l = []
		    for p1 in cl:
		        l.append([sum(rast(p1[0], p2[0], p1[1], p2[1]) for p2 in cl), p1])
		    return min(l)[1]

		a = open('27_A_18314.txt')
		data = [[float(t) for t in s.replace(',', '.').split()] for s in a]
		clusts = []
		while data:
		    clusts.append([data.pop()])
		    for p1 in clusts[-1]:
		        nb = [p2 for p2 in data if rast(p1[0], p2[0], p1[1], p2[1]) <= 2]
		        clusts[-1].extend(nb)
		        for p in nb: data.remove(p)

		res = [center(t) for t in clusts]
		px = sum(t[0] for t in res) / len(res)
		py = sum(t[1] for t in res) / len(res)
		print(int(abs(px * 1000)), int(abs(py * 1000)))

	Для файла Б: аналогично.

Учёный решил провести кластеризацию некоторого множества звёзд по их расположению на карте звёздного неба.  Каждая звезда обязательно принадлежит только одному из кластеров или является аномалией. Центр кластера, или центроид, – это одна из звёзд на графике, сумма расстояний от которой до всех остальных звёзд кластера минимальна. Расстояние между двумя точками A(x1,y1) и B(x2,y2) вычисляется по формуле Евклида.
Назовём точками одного кластера такие точки, для которых выполняются оба условия:
Для любой пары точек одного кластера можно найти последовательность, где расстояние между соседними сигналами Pi и Pi+1 меньше 1, при этом в единичной окрестности точек одного кластера нет точек другого кластера или аномалий;
Количество точек в кластере не менее 30.
В файле A хранятся данные о звёздах двух кластеров. В каждой строке записана информация о расположении на карте одной звезды: сначала координата x, затем координата y (в условных единицах). Известно, что количество звёзд не превышает 1000. В файле Б хранятся данные о звёздах трёх кластеров. Известно, что количество звёзд не превышает 10 000. Структура хранения информации о звездах в файле Б аналогична файлу А. Возможные данные одного из файлов иллюстрированы графиком.
Для каждого файла определите координаты центра каждого кластера, затем вычислите два числа: Px – среднее арифметическое абсцисс центров кластеров, и Py – среднее арифметическое ординат центров кластеров. В ответе запишите четыре числа: в первой строке сначала целую часть произведения Px×100000, затем целую часть произведения Py×100000 для файла А, во второй строке – аналогичные данные для файла Б.

	Для файла А:

		def rast(x1, x2, y1, y2): return ((x2 - x1)**2 + (y2 - y1)**2)**0.5

		def center(cl):
		    l = []
		    for p1 in cl:
		        l.append([sum(rast(p1[0], p2[0], p1[1], p2[1]) for p2 in cl), p1])
		    return min(l)[1]

		a = open('27B_18630.txt')
		data = [[float(t) for t in s.replace(',', '.').split()] for s in a]
		clusts = []
		while data:
		    clusts.append([data.pop()])
		    for p1 in clusts[-1]:
		        nb = [p2 for p2 in data if rast(p1[0], p2[0], p1[1], p2[1]) < 1]
		        clusts[-1].extend(nb)
		        for p in nb: data.remove(p)

		clusts = [t for t in clusts if len(t) >= 30]
		res = [center(t) for t in clusts]
		px = sum(t[0] for t in res) / len(res)
		py = sum(t[1] for t in res) / len(res)
		print(int(px * 100000), int(py * 100000))

	Для файла Б: аналогично.

ОЧЕНЬ СЛОЖНАЯ!!
Популярная компания по доставке продуктов «Быстрокат» расширяется и хочет открыть новые филиалы в двух густонаселенных районах города. Для открытия отдела логистам необходимо выбрать самую подходящую геолокацию для оптимизации организации процессов по координации и доставке товаров,  для чего им нужно проанализировать множество жилых единиц (геопозиций). Каждый район состоит из нескольких микрорайонов, включающих в себя некоторое количество геопозиций. Известно, что каждый микрорайон характеризуется тем, что любая из его геопозиций удалена от любой геопозиции из других микрорайонов хотя бы на R у.е. (условных единиц). Для анализа данных используется предоставленный набор вещественных точек (геопозиций), размещенных на декартовой оси координат. Они характеризуют все геопозиции конкретного района, который представляет собой квадрат размером 10 у.е. (условных единиц). С целью определить оптимальную геолокацию для открытия филиала логисты вычисляют медоид (райцентр) каждого микрорайона, который определяется как такая геопозиция внутри одного микрорайона, суммарное расстояние от которой до всех других геопозиций этого же микрорайона минимально. Затем специалисты определяют конечный медоид, опираясь на данные о расположении ранее найденных медоидов, – такую геопозицию, суммарное расстояние от которой до всех медоидов минимально. Именно в этой геопозиции и будет затем открыт новый филиал. При проведении расчетов также исключаются аномальные геопозиции, случайно попавшие в представленный набор данных. Они определяются как точки, расстояние от которых до любой другой точки в наборе данных превышает K у.е. (условных единиц). Метрикой расстояния между двумя геопозициями (точками) A(x1,y1) и B(x2,y2) на плоскости является формула Евклида.
В файле A хранятся данные обо всех геопозициях первого района. В первой строке записаны значения R и K для этого района. В каждой из следующих строк записана информация о расположении в районе одной геопозиции:  сначала  координата  x,  затем  координата  y. Значения даны в условных единицах, которые представлены вещественными числами. Известно, что количество геопозиций не превышает 2000. В файле Б хранятся данные обо всех геопозициях второго района. В первой строке записаны значения R и K для этого района. Известно, что количество геопозиций не превышает 30 000. Структура хранения информации о звездах в файле Б аналогична файлу А. 
Для каждого файла определите геопозицию, в которой будет открыт филиал. В ответе запишите четыре числа: в первой строке сначала целую часть произведения координаты x этой геопозиции на 10000, затем целую часть произведения координаты y этой геопозиции на 10000 для файла А, во второй строке – аналогичные данные для файла Б.

	Для файла А:

		def rast(x1, x2, y1, y2): return ((x2 - x1)**2 + (y2 - y1)**2)**0.5

		def center(cl):
		    l = []
		    for p1 in cl:
		        l.append([sum(rast(p1[0], p2[0], p1[1], p2[1]) for p2 in cl), p1])
		    return min(l)[1]

		a = open('27_A_18390(1).txt')
		R, K = [float(t) for t in a.readline().replace(',', '.').split()]
		data = [[float(t) for t in s.replace(',', '.').split()] for s in a]
		validPoints = [p1 for p1 in data if not all(rast(p1[0], p2[0], p1[1], p2[1]) > K for p2 in data if p1 != p2)]
		pointsCopy = validPoints.copy()

		clusts = []
		while validPoints:
		    clusts.append([validPoints.pop()])
		    for p1 in clusts[-1]:
		        nb = [p2 for p2 in validPoints if rast(p1[0], p2[0], p1[1], p2[1]) < R]
		        clusts[-1].extend(nb)
		        for p in nb: validPoints.remove(p)

		res = [center(t) for t in clusts]
		def center2(cl, cl2):
		    l = []
		    for p1 in cl:
		        l.append([sum(rast(p1[0], p2[0], p1[1], p2[1]) for p2 in cl2), p1])
		    return min(l)[1]

		x = center2(pointsCopy, res)
		print(int(x[0] * 10000), int(x[1] * 10000))

В лаборатории проводится эксперимент, состоящий из множества испытаний. Результат каждого испытания представляется в виде пары чисел. Для визуализации результатов эта пара рассматривается как координаты точки на плоскости, и на чертеже отмечаются точки, соответствующие всем испытаниям.
По результатам эксперимента проводится кластеризация полученных результатов: на плоскости выделяется несколько кластеров - прямоугольников размером 3×3 так, что каждая точка попадает ровно в один кластер.
Центроидом кластера называется та из входящих в него точек, для которой минимальна сумма расстояний до всех остальных точек кластера.
Обработка результатов эксперимента включает следующие шаги:
1) кластер, содержащий наибольшее число точек, исключается;
2) определяются центроиды всех оставшихся кластеров;
3) для найденных центроидов вычисляется средняя точка. Средней для группы точек называется точка (не обязательно входящая в группу), координаты которой определяются как средние арифметические значения координат всех точек группы.
В файле записан протокол проведения эксперимента. Каждая строка файла содержит два числа: координаты X и Y точки, соответствующей одному испытанию. По данному протоколу надо определить среднюю точку центроидов всех кластеров за исключением содержащего наибольшее число точек.
Вам даны два входных файла (A и B), каждый из которых имеет описанную выше структуру. По данным каждого из представленных файлов определите координаты средней точки по описанным выше правилам. 
В ответе запишите четыре числа: сначала (в первой строке) координаты X и Y средней точки для файла A, затем (во второй строке) координаты X и Y средней точки для файла B.
В качестве значения координаты указывайте целую часть от умножения числового значения координаты на 10 000.
Примечание. Расстояние вычисляется по формуле Евклида.

	Для файла А:

		def rast(x1, x2, y1, y2): return ((x2 - x1)**2 + (y2 - y1)**2)**0.5

		def center(cl):
		    l = []
		    for p1 in cl:
		        l.append([sum(rast(p1[0], p2[0], p1[1], p2[1]) for p2 in cl), p1])
		    return min(l)[1]

		def srPoint(l):
		    srX = sum(t[0] for t in l) / len(l)
		    srY = sum(t[1] for t in l) / len(l)
		    return [srX, srY]

		a = open('27A_18622.txt')
		data = [[float(t) for t in s.replace(',', '.').split()] for s in a]
		clusts = []
		while data:
		    clusts.append([data.pop()])
		    for p1 in clusts[-1]:
		        nb = [p2 for p2 in data if rast(p1[0], p2[0], p1[1], p2[1]) < 0.5]
		        clusts[-1].extend(nb)
		        for p in nb: data.remove(p)

		maxLen = max(len(t) for t in clusts)
		clusts = [t for t in clusts if len(t) < maxLen]

		res = [center(t) for t in clusts]
		srRes = srPoint(res)
		x = int(srRes[0] * 10000)
		y = int(srRes[1] * 10000)
		print(x, y)

	Для файла Б: аналогично

-------------------------------------

ПРАКТИКА:

В городе X тестируется проект по оптимизации размещения кранов на складах. Оптимальное местоположение для крана (или центроид) будет таким, при котором сумма расстояний Чебышева от этого места до всех других точек на складе была минимальной. Расстояние Чебышева между двумя точками A(x1,y1) и B(x2,y2) вычисляется по формуле Евклида.
В файле A хранятся данные о двух складских комплексах (кластерах). Каждый комплекс имеет форму прямоугольника размером H = 3 и W = 5. Каждая строка файла содержит координаты одной точки на складе: сначала x, затем y. Количество точек в каждом комплексе не превышает 1000. В файле Б той же структуры хранятся данные о трёх кластерах, каждый из которых имеет вид прямоугольника размером H = 6 и W = 8. Количество точек в каждом комплексе не превышает 10 000.
Для каждого файла определите координаты центра каждого кластера, затем вычислите два числа: Px – среднее арифметическое абсцисс центров кластеров, и Py – среднее арифметическое ординат центров кластеров. В ответе запишите четыре числа: в первой строке сначала целую часть абсолютного значения произведения Px×10000, затем целую часть абсолютного значения произведения Py×10000 для файла А, во второй строке – аналогичные данные для файла Б.

	Для файла А:

		def rast(x1, x2, y1, y2): return ((x2 - x1)**2 + (y2 - y1)**2)**0.5
		 
		def center(cl):
		    l = []
		    for p1 in cl:
		        l.append([sum(rast(p1[0], p2[0], p1[1], p2[1]) for p2 in cl), p1])
		    return min(l)[1]

		a = open('27_A_20911.txt')
		data = [[float(t) for t in s.replace(',', '.').split()] for s in a]
		clusts = []
		while data:
		    clusts.append([data.pop()])
		    for p1 in clusts[-1]:
		        nb = [p2 for p2 in data if rast(p1[0], p2[0], p1[1], p2[1]) < 1.5]
		        clusts[-1].extend(nb)
		        for p in nb: data.remove(p)

		res = [center(t) for t in clusts]
		px = sum(t[0] for t in res) / len(res)
		py = sum(t[1] for t in res) / len(res)
		print(int(abs(px * 10000)), int(abs(py * 10000)))

	Для файла Б: аналогично.

В городе X тестируется проект по оптимизации размещения кранов на складах. Оптимальное местоположение для крана (или центроид) будет таким, при котором сумма расстояний Чебышева от этого места до всех других точек на складе была минимальной. Расстояние Чебышева между двумя точками A(x1,y1) и B(x2,y2) вычисляется по формуле d(A,B)=max(∣x2−x1∣,∣y2−y1∣).d(A,B)=max(∣x2−x1∣,∣y2−y1∣).
В файле A хранятся данные о двух складских комплексах (кластерах). Каждый комплекс имеет форму прямоугольника размером H = 3 и W = 5. Каждая строка файла содержит координаты одной точки на складе: сначала x, затем y. Количество точек в каждом комплексе не превышает 1000. В файле Б той же структуры хранятся данные о трёх кластерах, каждый из которых имеет вид прямоугольника размером H = 6 и W = 8. Количество точек в каждом комплексе не превышает 10 000.
Для каждого файла определите координаты центра каждого кластера, затем вычислите два числа: Px – среднее арифметическое абсцисс центров кластеров, и Py – среднее арифметическое ординат центров кластеров. В ответе запишите четыре числа: в первой строке сначала целую часть абсолютного значения произведения Px×10000, затем целую часть абсолютного значения произведения Py×10000 для файла А, во второй строке – аналогичные данные для файла Б.

	Для файла А:

		from math import dist

		def rast(x1, x2, y1, y2): return max(abs(x2 - x1), abs(y2 - y1))

		def center(cl):
		    l = []
		    for p1 in cl:
		        l.append([sum(rast(p1[0], p2[0], p1[1], p2[1]) for p2 in cl), p1])
		    return min(l)[1]

		a = open('27A_18054.txt')
		data = [[float(t) for t in s.replace(',', '.').split()] for s in a]
		clusts = []
		while data:
		    clusts.append([data.pop()])
		    for p1 in clusts[-1]:
		        nb = [p2 for p2 in data if dist(p1, p2) < 1]
		        clusts[-1].extend(nb)
		        for p in nb: data.remove(p)

		res = [center(t) for t in clusts]
		px = sum(t[0] for t in res) / len(res)
		py = sum(t[1] for t in res) / len(res)
		print(int(abs(px * 10000)), int(abs(py * 10000)))

	Для файла Б: аналогично, но eps = 0.5

Фрагмент звёздного неба спроецирован на плоскость с декартовой системой координат. Учёный решил провести кластеризацию полученных точек, являющихся изображениями звёзд, то есть разбить их множество на N непересекающихся непустых подмножеств (кластеров), таких что точки каждого подмножества лежат внутри прямоугольника со сторонами длиной H и W, причём эти прямоугольники между собой не пересекаются. Стороны прямоугольников не обязательно параллельны координатным осям.
Гарантируется, что такое разбиение существует и единственно для заданных размеров прямоугольников.
Будем называть центром кластера точку этого кластера, сумма расстояний от которой до всех остальных точек кластера минимальна. Для каждого кластера гарантируется единственность его центра. Расстояние между двумя точками на плоскости A(x1,y1) и B(x2,y2) вычисляется по формуле Евклида.
В файле A хранятся данные о звёздах десяти кластеров, где H=2, W=2 для каждого кластера. В каждой строке записана информация о расположении на карте одной звезды: сначала координата x, затем координата y. Значения даны в условных единицах. Известно, что количество звёзд не превышает 1000. В файле B хранятся данные о звёздах ста кластеров, где H=2, W=2 для каждого кластера. Известно, что количество звёзд не превышает 10 000. Структура хранения информации о звездах в файле B аналогична файлу А. Для каждого файла определите координаты центра каждого кластера, затем вычислите два числа:  Px – среднее арифметическое абсцисс центров кластеров, и  Py – среднее арифметическое ординат центров кластеров. В ответе запишите четыре числа: в первой строке сначала целую часть произведения  Px×10000, затем целую часть произведения  Py×10000 для файла А, во второй строке – аналогичные данные для файла B.
Возможные данные одного из файлов иллюстрированы графиком.
Гарантируется, что расстояние между любыми двумя точками разных кластеров превышает 1.

	Для файла А:

		from math import dist

		def center(cl):
		    l = []
		    for p1 in cl:
		        l.append([sum(dist(p1, p2) for p2 in cl), p1])
		    return min(l)[1]

		a = open('27_A_19153.txt')
		data = [[float(t) for t in s.replace(',', '.').split()] for s in a]
		clusts = []
		while data:
		    clusts.append([data.pop()])
		    for p1 in clusts[-1]:
		        nb = [p2 for p2 in data if dist(p1, p2) < 1]
		        clusts[-1].extend(nb)
		        for p in nb: data.remove(p)

		res = [center(t) for t in clusts]
		px = sum([t[0] for t in res]) / len(res)
		py = sum([t[1] for t in res]) / len(res)
		print(int(px * 10000), int(py * 10000))

	Для файла Б: аналогично

Фрагмент звёздного неба спроецирован на плоскость с декартовой системой координат. Учёный решил провести кластеризацию полученных точек, являющихся изображениями звёзд, то есть разбить их множество на N непересекающихся непустых подмножеств (кластеров), таких что точки каждого подмножества лежат внутри прямоугольника со сторонами длиной H и W, причём эти прямоугольники между собой не пересекаются. Стороны прямоугольников не обязательно параллельны координатным осям. Гарантируется, что такое разбиение существует и единственно для заданных размеров прямоугольников.
Плотностью кластера назовём среднее арифметическое количества точек в единичной окрестности для каждой точки кластера (включая эту точку).  Расстояние между двумя точками на плоскости A(x1,y1) и B(x2,y2) вычисляется по формуле Евклида.
В файле A хранятся данные о звёздах четырёх кластеров, где H=3, W=3 для каждого кластера. В каждой строке записана информация о расположении на карте одной звезды: сначала координата x, затем координата y. Значения даны в условных единицах. Известно, что количество звёзд не превышает 1000.
В файле B хранятся данные о звёздах семи кластеров, где H=5, W=5 для каждого кластера. Известно, что количество звёзд не превышает 10 000. Структура хранения информации о звездах в файле B аналогична файлу А.
Для каждого файла определите плотность каждого кластера, затем вычислите два числа: Pmin – минимальная плотность кластера, и Pavg – среднее арифметическое плотности кластеров. В ответе запишите четыре числа: в первой строке сначала целую часть произведения Pmin×100000, затем целую часть произведения Pavg×100000 для файла А, во второй строке – аналогичные данные для файла Б.

	Для файла А:

		from math import dist

		def pl(cl):
		    l = []
		    for p1 in cl:
		        l.append(len([p2 for p2 in cl if dist(p1, p2) <= 1]))
		    return sum(l) / len(l)

		data = [[float(t) for t in s.replace(',', '.').split()] for s in open('27A_20295.txt')]
		clusts = []
		while data:
		    clusts.append([data.pop()])
		    for p1 in clusts[-1]:
		        nb = [p2 for p2 in data if dist(p1, p2) < 1]
		        clusts[-1].extend(nb)
		        for p in nb: data.remove(p)

		res = [pl(t) for t in clusts]
		pmin = min(res)
		pavg = sum(res) / len(res)
		print(int(pmin * 100000), int(pavg * 100000))

	Для файла Б: аналогично, но eps = 0.4

Учёный решил провести кластеризацию некоторого множества звёзд по их расположению на карте звёздного неба.  Каждая звезда обязательно принадлежит только одному из кластеров или является аномалией. Центр кластера, или центроид, – это одна из звёзд на графике, сумма расстояний от которой до всех остальных звёзд кластера минимальна. Расстояние между двумя точками A(x1,y1) и B(x2,y2) вычисляется по формуле Евклида.
 Назовём точками одного кластера такие точки, для которых выполняются оба условия:
    - Для любой пары точек одного кластера можно найти последовательность меньше 1, при этом в единичной окрестности точек одного кластера нет точек другого кластера или аномалий;
    - Количество точек в кластере не менее 30.
В файле A хранятся данные о звёздах двух кластеров. В каждой строке записана информация о расположении на карте одной звезды: сначала координата x, затем координата y (в условных единицах). Известно, что количество звёзд не превышает 1000. В файле Б хранятся данные о звёздах трёх кластеров. Известно, что количество звёзд не превышает 10 000. Структура хранения информации о звездах в файле Б аналогична файлу А. Возможные данные одного из файлов иллюстрированы графиком.
Для каждого файла определите координаты центра каждого кластера, затем вычислите два числа: Px – среднее арифметическое абсцисс центров кластеров, и Py – среднее арифметическое ординат центров кластеров. В ответе запишите четыре числа: в первой строке сначала целую часть произведения Px×100000, затем целую часть произведения Py×100000 для файла А, во второй строке – аналогичные данные для файла Б.

	Для файла А:

		from math import dist

		def center(cl):
		    l = []
		    for p1 in cl:
		        l.append([sum(dist(p1, p2) for p2 in cl), p1])
		    return min(l)[1]

		data = [[float(t) for t in s.replace(',', '.').split()] for s in open('27A_18629.txt')]
		clusts = []
		while data:
		    clusts.append([data.pop()])
		    for p1 in clusts[-1]:
		        nb = [p2 for p2 in data if dist(p1, p2) < 1]
		        clusts[-1].extend(nb)
		        for p in nb: data.remove(p)
		clusts = [t for t in clusts if len(t) >= 30]

		res = [center(t) for t in clusts]
		px = sum(t[0] for t in res) / len(res)
		py = sum(t[1] for t in res) / len(res)
		print(int(px * 100000), int(py * 100000))

	Для файла Б: аналогично

ОЧЕНЬ СЛОЖНАЯ!!
Популярная компания по доставке продуктов «Быстрокат» расширяется и хочет открыть новые филиалы в двух густонаселенных районах города. Для открытия отдела логистам необходимо выбрать самую подходящую геолокацию для оптимизации организации процессов по координации и доставке товаров,  для чего им нужно проанализировать множество жилых единиц (геопозиций). Каждый район состоит из нескольких микрорайонов, включающих в себя некоторое количество геопозиций. Известно, что каждый микрорайон характеризуется тем, что он включает в себя более одной геопозиции, а любая из его геопозиций удалена от любой геопозиции из других микрорайонов более чем на R = 0.7 у.е. (условных единиц). Для анализа данных используется предоставленный набор вещественных точек (геопозиций), размещенных на декартовой оси координат. Они характеризуют все геопозиции конкретного района, который представляет собой квадрат размером 1000 у.е. (условных единиц). С целью определить оптимальную геолокацию для открытия филиала логисты вычисляют медоид (райцентр) каждого микрорайона, который определяется как такая геопозиция внутри одного микрорайона, суммарное расстояние от которой до всех других геопозиций этого же микрорайона минимально. Затем специалисты определяют конечный медоид, опираясь на данные о расположении ранее найденных медоидов, – такую геопозицию, суммарное расстояние от которой до всех медоидов минимально. Именно в этой геопозиции и будет затем открыт новый филиал. При проведении расчетов также исключаются аномальные геопозиции, случайно попавшие в представленный набор данных. Они определяются как одиночные точки, расстояние от которых до любой другой точки в наборе данных превышает R = 0.7 у.е. (условных единиц). Метрикой расстояния между двумя геопозициями (точками) A(x1,y1) и B(x2,y2) на плоскости является формула Евклида
В файле A хранятся данные обо всех геопозициях первого района. В каждой строке записана информация о расположении в районе одной геопозиции:  сначала  координата  x,  затем  координата  y. Значения даны в условных единицах, которые представлены вещественными числами. Известно, что количество геопозиций не превышает 1000. В файле Б хранятся данные обо всех геопозициях второго района.Известно, что количество геопозиций не превышает 10 000. Структура хранения информации о звездах в файле Б аналогична файлу А. 
Для каждого файла определите геопозицию, в которой будет открыт филиал. В ответе запишите четыре числа: в первой строке сначала целую часть произведения координаты x этой геопозиции на 10000, затем целую часть произведения координаты y этой геопозиции на 10000 для файла А, во второй строке – аналогичные данные для файла Б.

	Для файла А:

		from math import dist

		def cnt(cl):
		    l = []
		    for p1 in cl:
		        l.append([sum(dist(p1, p2) for p2 in cl), p1])
		    return min(l)[1]

		def ResCnt(pnts, cl):
		    l = []
		    for p1 in pnts:
		        l.append([sum(dist(p1, p2) for p2 in cl), p1])
		    return min(l)[1]

		d = [[float(t) for t in s.replace(',', '.').split()] for s in open('27A_23296.txt')]
		vl_p = [p1 for p1 in d if not all(dist(p1, p2) > 0.7 for p2 in d if p1 != p2)]
		p_copy = vl_p.copy()
		c = []
		while vl_p:
		    c.append([vl_p.pop()])
		    for p1 in c[-1]:
		        nb = [p2 for p2 in vl_p if dist(p1, p2) <= 0.7]
		        c[-1].extend(nb)
		        for p in nb: vl_p.remove(p)

		res = [cnt(t) for t in c]
		fnl = ResCnt(p_copy, res)
		print(int(fnl[0] * 10000), int(fnl[1] * 10000))

	Для файла Б: аналогично

Фрагмент звёздного неба спроецирован на плоскость с декартовой системой координат. Учёный решил провести кластеризацию полученных точек, являющихся изображениями звёзд, то есть разбить их множество на N непересекающихся непустых подмножеств (кластеров), таких что точки каждого подмножества лежат внутри прямоугольника со сторонами длиной H и W, причём эти прямоугольники между собой не пересекаются. Стороны прямоугольников не обязательно параллельны координатным осям.
Гарантируется, что такое разбиение существует и единственно для заданных размеров прямоугольников.
Будем называть центром кластера точку этого кластера, сумма расстояний от которой до всех остальных точек кластера минимальна. Для каждого кластера гарантируется единственность его центра. Расстояние между двумя точками на плоскости A(x1,y1) и B(x2,y2)вычисляется по формуле Евклида.
В файле A хранятся данные о звёздах двух кластеров, где H=6, W=4,5 для каждого кластера. В каждой строке записана информация о расположении на карте одной звезды: сначала координата x, затем координата y. Значения даны в условных единицах. Известно, что количество звёзд не превышает 1000.
В файле B хранятся данные о звёздах трёх кластеров, где H=5, W=6 для каждого кластера. Известно, что количество звёзд не превышает 1000. Также в файле B присутствуют точки, являющиеся аномалиями, возникшими в результате помех при передаче данных. Эти три точки не относятся ни к одному из кластеров, их учитывать не нужно. Структура хранения информации о звездах в файле B аналогична файлу А. 
Для файла А определите координаты центра каждого кластера, затем найдите два числа: Px - максимальную из абсцисс центров кластеров, и Py - максимальную из ординат центров кластеров. Для файла Б определите координаты центра каждого кластера, затем найдите два числа: Qx - разность абсцисс центров кластеров с минимальным и максимальным количеством точек, и Qy - разность ординат центров кластеров с минимальным и максимальным количеством точек. Гарантируется, что во всех кластерах количество точек различно.
В ответе запишите четыре числа: в первой строке - сначала целую часть абсолютного значения произведения Px × 10000, затем целую часть абсолютного значения произведения Py × 10 000; во второй строке - сначала целую часть абсолютного значения произведения Qx× 10 000, затем целую часть абсолютного значения произведения Qy × 10 000.

	Для файла А:

		from math import dist

		def cnt(cl):
		    l = []
		    for p1 in cl: l.append([sum(dist(p1, p2) for p2 in cl), p1])
		    return min(l)[1]

		d = [[float(t) for t in s.replace(',', '.').split()] for s in open('27_A_23209.txt')]
		c = []
		while d:
		    c.append([d.pop()])
		    for p1 in c[-1]:
		        nb = [p2 for p2 in d if dist(p1, p2) < 1]
		        c[-1].extend(nb)
		        for p in nb: d.remove(p)
		c = [t for t in c if len(t) > 1]

		res = [cnt(t) for t in c]
		px = max(t[0] for t in res)
		py = max(t[1] for t in res)
		print(int(abs(px * 10000)), int(abs(py * 10000)))

	Для файла Б:

		from math import dist

		def cnt(cl):
		    l = []
		    for p1 in cl: l.append([sum(dist(p1, p2) for p2 in cl), p1])
		    return min(l)[1]

		d = [[float(t) for t in s.replace(',', '.').split()] for s in open('27_B_23209.txt')]
		c = []
		while d:
		    c.append([d.pop()])
		    for p1 in c[-1]:
		        nb = [p2 for p2 in d if dist(p1, p2) < 1]
		        c[-1].extend(nb)
		        for p in nb: d.remove(p)
		c = [t for t in c if len(t) > 1]
		c = [c[-1], c[0]]

		res = [cnt(t) for t in c]
		qx = abs(res[0][0] - res[1][0])
		qy = abs(res[0][1] - res[1][1])
		print(int(abs(qx * 10000)), int(abs(qy * 10000)))

Компания-разработчик роботов проводит тестирование новой модели для работы на складе. Робот должен уметь определять скопления коробок на складе по их координатам, чтобы оптимально планировать маршруты для перевозки.
Каждое скопление коробок (кластер) — это группа из не менее чем 100 коробок, которые находятся на расстоянии не более 5 условных единиц друг от друга. Центр скопления, или центроид, — это одна из коробок внутри группы, сумма расстояний от которой до остальных в том же кластере минимальна. Расстояние между коробками  вычисляется по формуле Евкл.
Коробки, которые находятся на расстоянии более 5 условных единиц от любых кластеров, считаются ошибками размещения (аномалиями) и при вычислениях не учитываются.
В файле A содержатся координаты коробок, размещённых в зоне тестирования №1. Всего в ней находятся два кластера. В каждой строке файла указаны координаты одной коробки: сначала x, затем y. Всего в файле A не более 1000 коробок.
В файле B содержатся координаты коробок, размещённых в зоне тестирования №2. В этой зоне три кластера, а общее число коробок не превышает 10 000. Формат записи тот же, что и в файле A.
Для каждого файла определите координаты центра каждого кластера, затем вычислите два числа: PxPx — среднее арифметическое абсцисс центров кластеров, и PyPy — среднее арифметическое ординат центров кластеров
В ответе запишите четыре числа: в первой строке сначала целую часть произведения Px×10000Px×10000, затем целую часть произведения Py×10000 Py×10000 для файла A, во второй строке — аналогичные данные для файла B.
Возможные данные одного из файлов иллюстрированы графиком.

	Для файла А:

		from math import dist

		def cnt(cl):
		    l = []
		    for p1 in cl: l.append([sum(dist(p1, p2) for p2 in cl), p1])
		    return min(l)[1]

		d = [[float(t) for t in s.replace(',', '.').split()] for s in open('27_А.txt')]
		c = []
		while d:
		    c.append([d.pop()])
		    for p1 in c[-1]:
		        nb = [p2 for p2 in d if dist(p1, p2) < 1]
		        c[-1].extend(nb)
		        for p in nb: d.remove(p)

		res = [cnt(t) for t in c]
		px = sum(t[0] for t in res) / len(res)
		py = sum(t[1] for t in res) / len(res)
		print(int(abs(px * 10000)), int(abs(py * 10000)))

	Для файла Б: аналогично

Компания-разработчик роботов проводит тестирование новой модели для работы на складе. Робот должен уметь определять скопления коробок на складе по их координатам, чтобы оптимально планировать маршруты для перевозки.
Каждое скопление коробок (кластер) — это группа из не менее чем 100 коробок, которые находятся на расстоянии не более 5 условных единиц друг от друга. Центр скопления, или центроид, — это одна из коробок внутри группы, сумма расстояний от которой до остальных в том же кластере минимальна. Расстояние между коробками вычисляется по формуле Евклида.
Коробки, которые находятся на расстоянии более 5 условных единиц от любых кластеров, считаются ошибками размещения (аномалиями) и при вычислениях не учитываются.
В файле A содержатся координаты коробок, размещённых в зоне тестирования №1. Всего в ней находятся два кластера. В каждой строке файла указаны координаты одной коробки: сначала x, затем y. Всего в файле A не более 1000 коробок.
В файле B содержатся координаты коробок, размещённых в зоне тестирования №2. В этой зоне три кластера, а общее число коробок не превышает 10 000. Формат записи тот же, что и в файле A.
Для каждого файла определите координаты центра каждого кластера, затем вычислите два числа: PxPx — среднее арифметическое абсцисс центров кластеров, и PyPy — среднее арифметическое ординат центров кластеров.
В ответе запишите четыре числа: в первой строке сначала целую часть произведения Px×10000Px×10000, затем целую часть произведения Py×10000Py×10000 для файла A, во второй строке — аналогичные данные для файла B.
Возможные данные одного из файлов иллюстрированы графиком.

	Для файла А (Б аналогично):

		from math import dist

		def cnt(cl):
		    l = []
		    for p1 in cl: l.append([sum(dist(p1, p2) for p2 in cl), p1])
		    return min(l)[1]

		d = [[float(t) for t in s.replace(',', '.').split()] for s in open('27_А.txt')]
		vp = [p1 for p1 in d if not all(dist(p1, p2) > 5 for p2 in d if p1 != p2)]
		c = []
		while vp:
		    c.append([vp.pop()])
		    for p1 in c[-1]:
		        nb = [p2 for p2 in vp if dist(p1, p2) < 5]
		        c[-1].extend(nb)
		        for p in nb: vp.remove(p)
		c = [t for t in c if len(t) >= 100]

		res = [cnt(t) for t in c]
		px = sum(t[0] for t in res) / len(res)
		py = sum(t[1] for t in res) / len(res)
		print(int(px * 10000), int(py * 10000))

Фрагмент звёздного неба спроецирован на плоскость с декартовой системой координат. Учёный решил провести кластеризацию полученных точек, являющихся изображениями звёзд, то есть разбить их множество на N непересекающихся непустых подмножеств (кластеров), таких что точки каждого подмножества лежат внутри прямоугольника со сторонами длиной H и W, причём эти прямоугольники между собой не пересекаются. Стороны прямоугольников не обязательно параллельны координатным осям.
Гарантируется, что такое разбиение существует и единственно для заданных размеров прямоугольников.
Будем называть центром кластера точку этого кластера, сумма расстояний от которой до всех остальных точек кластера минимальна. Для каждого кластера гарантируется единственность его центра. Расстояние между двумя точками на плоскости A(x1,y1)A(x1,y1) и B(x2,y2)B(x2,y2) вычисляется по формуле Евклида.
В файле A хранятся данные о звёздах двух кластеров, где H=6,5, W=4,5 для каждого кластера. В каждой строке записана информация о расположении на карте одной звезды: сначала координата x, затем координата y. Значения даны в условных единицах. Известно, что количество звёзд не превышает 1000.
В файле B хранятся данные о звёздах трёх кластеров, где H=5, W=4,5 для каждого кластера. Известно, что количество звёзд не превышает 10 000. Структура хранения информации о звездах в файле B аналогична файлу А. 
Известно, что в файле A имеются координаты ровно двух, а в файле Б ровно трёх «лишних» точек, являющихся аномалиями, возникшими в результате помех при передаче данных. Эти точки не относятся ни к одному из кластеров, их учитывать не нужно.
Для файла А определите координаты центра каждого кластера, затем найдите два числа: PxPx - расстояние по оси абсцисс между центрами кластеров, и PyPy - расстояние по оси ординат между центрами кластеров. Для файла Б определите координаты центра каждого кластера, затем найдите два числа: Q1Q1 - среднее арифметическое расстояний от центра кластера с минимальным количеством точек до точек этого кластера, и Q2Q2 - среднее арифметическое расстояний от центра кластера с максимальным количеством точек до точек этого кластера. Нулевое расстояние от центра кластера до самого себя не учитывать.
В ответе запишите четыре числа: в первой строке - сначала абсолютную величину целой части произведения PxPx × 10000, затем абсолютную величину целой части произведения PyPy × 10 000; во второй строке - начала абсолютную величину целой части произведения Q1Q1 × 10000, затем абсолютную величину целой части произведения Q2Q2 × 10 000.

	Для файла А:

		from math import dist

		def cnt(cl):
		    l = []
		    for p1 in cl: l.append([sum(dist(p1, p2) for p2 in cl), p1])
		    return min(l)[1]

		d = [[float(t) for t in s.replace(',', '.').split()] for s in open('27A_25448.txt')]
		c = []
		while d:
		    c.append([d.pop()])
		    for p1 in c[-1]:
		        nb = [p2 for p2 in d if dist(p1, p2) < 1]
		        c[-1].extend(nb)
		        for p in nb: d.remove(p)
		c = [t for t in c if len(t) > 1]

		res = [cnt(t) for t in c]
		px = abs(res[0][0] - res[1][0])
		py = abs(res[0][1] - res[1][1])
		print(abs(int(px * 10000)), abs(int(py * 10000)))

	Для файла Б:

		from math import dist

		def cnt(cl):
		    l = []
		    for p1 in cl: l.append([sum(dist(p1, p2) for p2 in cl), p1])
		    return min(l)[1]

		d = [[float(t) for t in s.replace(',', '.').split()] for s in open('27B_25448.txt')]
		c = []
		while d:
		    c.append([d.pop()])
		    for p1 in c[-1]:
		        nb = [p2 for p2 in d if dist(p1, p2) < 1]
		        c[-1].extend(nb)
		        for p in nb: d.remove(p)
		c = [t for t in c if len(t) > 1]
		minCL = min([len(t), t] for t in c)[1]
		maxCL = max([len(t), t] for t in c)[1]

		def forQ(point, cl):
		    sr = sum(dist(point, p) for p in cl if p != point)
		    return sr / len([dist(point, p) for p in cl if p != point])
		minRes = cnt(minCL)
		maxRes = cnt(maxCL)
		q1 = forQ(minRes, minCL)
		q2 = forQ(maxRes, maxCL)
		print(abs(int(q1 * 10000)), abs(int(q2 * 10000)))	

Фрагмент звёздного неба спроецирован на плоскость с декартовой системой координат. Учёный решил провести кластеризацию полученных точек, являющихся изображениями звёзд, то есть разбить их множество на N непересекающихся непустых подмножеств (кластеров), таких что точки каждого подмножества лежат внутри прямоугольника со сторонами длиной H и W, причём эти прямоугольники между собой не пересекаются. Стороны прямоугольников не обязательно параллельны координатным осям.
Гарантируется, что такое разбиение существует и единственно для заданных размеров прямоугольников.
Будем называть центром кластера точку этого кластера, сумма расстояний от которой до всех остальных точек кластера минимальна. Для каждого кластера гарантируется единственность его центра. Расстояние между двумя точками на плоскости вычисляется по формуле Евклида.
В файле A хранятся данные о звёздах двух кластеров, где H=6,5, W=4,5 для каждого кластера. В каждой строке записана информация о расположении на карте одной звезды: сначала координата x, затем координата y. Значения даны в условных единицах. Известно, что количество звёзд не превышает 1000.
В файле B хранятся данные о звёздах трёх кластеров, где H=4,5, W=4 для каждого кластера. Известно, что количество звёзд не превышает 10 000. Структура хранения информации о звездах в файле B аналогична файлу А. 
Известно, что в файле A имеются координаты ровно двух, а в файле Б ровно трёх «лишних» точек, являющихся аномалиями, возникшими в результате помех при передаче данных. Эти точки не относятся ни к одному из кластеров, их учитывать не нужно.
Для файла А определите координаты центра каждого кластера, затем найдите два числа: PxPx - минимальная абсцисса центра кластера, и PyPy - минимальная ордината центра кластера. Для файла Б определите координаты центра каждого кластера, затем найдите два числа: Q1Q1 - среднее арифметическое расстояний от центра кластера с минимальным количеством точек до точек этого же кластера, и Q2Q2 - среднее арифметическое расстояний от центра кластера с максимальным количеством точек до точек этого же кластера. Нулевое расстояние от центра кластера до самого себя не учитывать.
В ответе запишите четыре числа: в первой строке - сначала абсолютную величину целой части произведения PxPx × 10000, затем абсолютную величину целой части произведения PyP × 10 000; во второй строке - начала абсолютную величину целой части произведения Q1Q1 × 10000, затем абсолютную величину целой части произведения Q2Q2 × 10 000.

	Для файла А:

		from math import dist

		def cnt(cl):
		    l = []
		    for p1 in cl:
		        l.append([sum(dist(p1, p2) for p2 in cl), p1])
		    return min(l)[1]

		d = [[float(t) for t in s.replace(',', '.').split()] for s in open('27A_25447.txt')]
		c = []
		while d:
		    c.append([d.pop()])
		    for p1 in c[-1]:
		        nb = [p2 for p2 in d if dist(p1, p2) < 1]
		        c[-1].extend(nb)
		        for p in nb: d.remove(p)
		c = [t for t in c if len(t) > 1]

		res = [cnt(t) for t in c]
		px = min(t[0] for t in res)
		py = min(t[1] for t in res)
		print(abs(int(px * 10000)), abs(int(py * 10000)))

	Для файла Б:

		from math import dist

		def cnt(cl):
		    l = []
		    for p1 in cl:
		        l.append([sum(dist(p1, p2) for p2 in cl), p1])
		    return min(l)[1]

		d = [[float(t) for t in s.replace(',', '.').split()] for s in open('27B_25447.txt')]
		c = []
		while d:
		    c.append([d.pop()])
		    for p1 in c[-1]:
		        nb = [p2 for p2 in d if dist(p1, p2) < 1]
		        c[-1].extend(nb)
		        for p in nb: d.remove(p)
		c = [t for t in c if len(t) > 1]

		minCL = c[1]
		maxCL = c[0]
		minRes = cnt(minCL)
		maxRes = cnt(maxCL)

		q1 = sum(dist(minRes, t) for t in minCL if minRes != t) / len([dist(minRes, t) for t in minCL if minRes != t])
		q2 = sum(dist(maxRes, t) for t in maxCL if maxRes != t) / len([dist(maxRes, t) for t in maxCL if maxRes != t])
		print(abs(int(q1 * 10000)), abs(int(q2 * 10000)))

Фрагмент звёздного неба спроецирован на плоскость с декартовой системой координат. Учёный решил провести кластеризацию полученных точек, являющихся изображениями звёзд, то есть разбить их множество на N непересекающихся непустых подмножеств (кластеров), таких что точки каждого подмножества лежат внутри прямоугольника со сторонами длиной H и W, причём эти прямоугольники между собой не пересекаются. Стороны прямоугольников не обязательно параллельны координатным осям.
Гарантируется, что такое разбиение существует и единственно для заданных размеров прямоугольников.
Будем называть центром кластера точку этого кластера, сумма расстояний от которой до всех остальных точек кластера минимальна. Для каждого кластера гарантируется единственность его центра. Расстояние между двумя точками на плоскости вычисляется по формуле Евклида.
В файле A хранятся данные о звёздах двух кластеров, где H=6,5, W=4,5 для каждого кластера. В каждой строке записана информация о расположении на карте одной звезды: сначала координата x, затем координата y. Значения даны в условных единицах. Известно, что количество звёзд не превышает 1000.
В файле B хранятся данные о звёздах трёх кластеров, где H=0,3, W=0,4 для каждого кластера. Известно, что количество звёзд не превышает 10 000. Структура хранения информации о звездах в файле B аналогична файлу А. 
Известно, что в файле A имеются координаты ровно двух, а в файле Б ровно трёх «лишних» точек, являющихся аномалиями, возникшими в результате помех при передаче данных. Эти точки не относятся ни к одному из кластеров, их учитывать не нужно. Для файла А определите координаты центра каждого кластера, затем найдите два числа: P1P1 - минимальное расстояние между центром одного кластера и точкой другого кластера, и P2P2 - максимальное расстояние между центром одного кластера и точкой другого кластера. Для файла Б определите координаты центра каждого кластера, затем найдите два числа: Q1Q1 - минимальное расстояние между центрами кластеров, и Q2Q2 - максимальное расстояние между центрами кластеров.
В ответе запишите четыре числа: в первой строке - сначала абсолютную величину целой части произведения P1P1 × 10000, затем абсолютную величину целой части произведения P2P2 × 10 000; во второй строке - начала абсолютную величину целой части произведения Q1Q1 × 10000, затем абсолютную величину целой части произведения Q2Q2 × 10 000.

	Для файла А:

		from math import dist

		def cn(cl):
		    l = []
		    for p1 in cl:
		        l.append([sum(dist(p1, p2) for p2 in cl), p1])
		    return min(l)[1]

		d = [[float(t) for t in s.replace(',', '.').split()] for s in open('27A_25444.txt')]
		c = []
		while d:
		    c.append([d.pop()])
		    for p1 in c[-1]:
		        nb = [p2 for p2 in d if dist(p1, p2) < 1]
		        c[-1].extend(nb)
		        for p in nb: d.remove(p)
		c = [t for t in c if len(t) > 1]

		res = [cn(t) for t in c]
		p1 = min(min(dist(res[0], p2) for p2 in c[1]), min(dist(res[1], p2) for p2 in c[0]))
		p2 = max(max(dist(res[0], p2) for p2 in c[1]), max(dist(res[1], p2) for p2 in c[0]))
		print(abs(int(p1 * 10000)), abs(int(p2 * 10000)))

	Для файла Б:

		from math import dist

		def cn(cl):
		    l = []
		    for p1 in cl:
		        l.append([sum(dist(p1, p2) for p2 in cl), p1])
		    return min(l)[1]

		d = [[float(t) for t in s.replace(',', '.').split()] for s in open('27B_25444.txt')]
		c = []
		while d:
		    c.append([d.pop()])
		    for p1 in c[-1]:
		        nb = [p2 for p2 in d if dist(p1, p2) < 0.2]
		        c[-1].extend(nb)
		        for p in nb: d.remove(p)
		c = [t for t in c if len(t) > 1]

		res = [cn(t) for t in c]
		q1 = min(dist(p1, p2) for p1 in res for p2 in res if p1 != p2)
		q2 = max(dist(p1, p2) for p1 in res for p2 in res if p1 != p2)
		print(abs(int(q1 * 10000)), abs(int(q2 * 10000)))

Фрагмент звёздного неба спроецирован на плоскость с декартовой системой координат. Учёный решил провести кластеризацию полученных точек, являющихся изображениями звёзд, то есть разбить их множество на N непересекающихся непустых подмножеств (кластеров), таких что точки каждого подмножества лежат внутри прямоугольника со сторонами длиной H и W, причём эти прямоугольники между собой не пересекаются. Стороны прямоугольников не обязательно параллельны координатным осям.
Гарантируется, что такое разбиение существует и единственно для заданных размеров прямоугольников.
Будем называть центром кластера точку этого кластера, сумма расстояний от которой до всех остальных точек кластера минимальна. Для каждого кластера гарантируется единственность его центра. Расстояние между двумя точками на плоскости вычисляется по формуле Евклида.
В файле A хранятся данные о звёздах двух кластеров, где H=6,5, W=4,5 для каждого кластера. В каждой строке записана информация о расположении на карте одной звезды: сначала координата x, затем координата y. Значения даны в условных единицах. Известно, что количество звёзд не превышает 1000.
В файле B хранятся данные о звёздах трёх кластеров, где H=6, W=5 для каждого кластера. Известно, что количество звёзд не превышает 10 000. Структура хранения информации о звездах в файле B аналогична файлу А. 
Известно, что в файле A имеются координаты ровно двух, а в файле Б ровно трёх «лишних» точек, являющихся аномалиями, возникшими в результате помех при передаче данных. Эти точки не относятся ни к одному из кластеров, их учитывать не нужно.
Для файла А определите координаты центра каждого кластера, затем найдите два числа: P1P1 - расстояние между центрами кластеров, и P2P2 - максимальное расстояние между центром каждого кластера и точкой этого же кластера. Для файла Б определите координаты центра каждого кластера, затем найдите два числа: QxQx - среднее арифметическое абсцисс центров кластеров, и QyQy - среднее арифметическое ординат центров кластеров.
В ответе запишите четыре числа: в первой строке - сначала абсолютную величину целой части произведения P1P1 × 10000, затем абсолютную величину целой части произведения P2P2 × 10 000; во второй строке - начала абсолютную величину целой части произведения QxQx × 10000, затем абсолютную величину целой части произведения QyQy × 10 000.

	Для файла А:

		from math import dist

		def cnt(cl):
		    l = []
		    for p1 in cl: l.append([sum(dist(p1, p2) for p2 in cl), p1])
		    return min(l)[1]

		d = [[float(t) for t in s.replace(',', '.').split()] for s in open('27A_25443.txt')]
		c = []
		while d:
		    c.append([d.pop()])
		    for p1 in c[-1]:
		        nb = [p2 for p2 in d if dist(p1, p2) < 1]
		        c[-1].extend(nb)
		        for p in nb: d.remove(p)
		c = [t for t in c if len(t) > 1]

		res = [cnt(t) for t in c]
		p1 = dist(res[0], res[1])
		p2 = max(max(dist(res[0], p) for p in c[0]), max(dist(res[1], p) for p in c[1]))
		print(abs(int(p1 * 10000)), abs(int(p2 * 10000)))

	Для файла Б:

		from math import dist

		def cnt(cl):
		    l = []
		    for p1 in cl: l.append([sum(dist(p1, p2) for p2 in cl), p1])
		    return min(l)[1]

		d = [[float(t) for t in s.replace(',', '.').split()] for s in open('27B_25443.txt')]
		c = []
		while d:
		    c.append([d.pop()])
		    for p1 in c[-1]:
		        nb = [p2 for p2 in d if dist(p1, p2) < 1]
		        c[-1].extend(nb)
		        for p in nb: d.remove(p)
		c = [t for t in c if len(t) > 1]

		res = [cnt(t) for t in c]
		Qx = sum(t[0] for t in res) / len(res)
		Qy = sum(t[1] for t in res) / len(res)
		print(abs(int(Qx * 10000)), abs(int(Qy * 10000)))

Фрагмент звёздного неба спроецирован на плоскость с декартовой системой координат. Учёный решил провести кластеризацию полученных точек, являющихся изображениями звёзд, то есть разбить их множество на N непересекающихся непустых подмножеств (кластеров), таких что точки каждого подмножества лежат внутри прямоугольника со сторонами длиной H и W, причём эти прямоугольники между собой не пересекаются. Стороны прямоугольников не обязательно параллельны координатным осям.
Гарантируется, что такое разбиение существует и единственно для заданных размеров прямоугольников.
Будем называть центром кластера точку этого кластера, сумма расстояний от которой до всех остальных точек кластера минимальна. Для каждого кластера гарантируется единственность его центра. Расстояние между двумя точками на плоскости вычисляется по формуле Евклида.
В файле A хранятся данные о звёздах двух кластеров, где H=6,5, W=4,5 для каждого кластера. В каждой строке записана информация о расположении на карте одной звезды: сначала координата x, затем координата y. Значения даны в условных единицах. Известно, что количество звёзд не превышает 1000.
В файле B хранятся данные о звёздах трёх кластеров, где H=6,5, W=5 для каждого кластера. Известно, что количество звёзд не превышает 1000. Структура хранения информации о звездах в файле B аналогична файлу А. 
Для файла А определите координаты центра каждого кластера, затем найдите два числа: P1P1 - минимальное расстояние от точки с координатами (1,0; 1,0) до центра кластера, и P2P2 - максимальное расстояние от этой же точки до центра кластера.
Для файла Б определите координаты центра каждого кластера, затем найдите два числа: Q1Q1 - в кластере с наибольшим количеством точек число таких точек, которые находятся на расстоянии не более 1,2 от центра кластера, и Q2Q2 - в кластере с наибольшим количеством точек число таких точек, которые находятся на расстоянии не более 0,75 от центра кластера.
Гарантируется, что во всех кластерах количество точек различно.
В ответе запишите четыре числа: в первой строке - сначала целую часть произведения P1P1 × 10000, затем целую часть произведения P2P2 × 10 000; во второй строке - сначала Q1Q1, затем Q2Q

	Для файла А:

		from math import dist

		def cnt(cl):
		    l = []
		    for p1 in cl: l.append([sum(dist(p1, p2) for p2 in cl), p1])
		    return min(l)[1]

		d = [[float(t) for t in s.replace(',', '.').split()] for s in open('27_A_25364.txt')]
		c = []
		while d:
		    c.append([d.pop()])
		    for p1 in c[-1]:
		        nb = [p2 for p2 in d if dist(p1, p2) < 1]
		        c[-1].extend(nb)
		        for p in nb: d.remove(p)

		res = [cnt(t) for t in c]
		point = [1.0, 1.0]
		p1 = min(dist(point, p) for p in res)
		p2 = max(dist(point, p) for p in res)
		print(int(p1 * 10000), int(p2 * 10000))

	Для файла Б:

		from math import dist

		def cnt(cl):
		    l = []
		    for p1 in cl: l.append([sum(dist(p1, p2) for p2 in cl), p1])
		    return min(l)[1]

		d = [[float(t) for t in s.replace(',', '.').split()] for s in open('27_B_25364.txt')]
		c = []
		while d:
		    c.append([d.pop()])
		    for p1 in c[-1]:
		        nb = [p2 for p2 in d if dist(p1, p2) < 1]
		        c[-1].extend(nb)
		        for p in nb: d.remove(p)

		maxCL = c[0]
		maxCLRes = cnt(maxCL)
		q1 = len([p for p in maxCL if dist(maxCLRes, p) <= 1.2])
		q2 = len([p for p in maxCL if dist(maxCLRes, p) <= 0.75])
		print(q1, q2)

Учёный наблюдает проекцию звёздного скопления на плоскость с декартовой системой координат. Полученные точки (звёзды) необходимо разбить на N непересекающихся непустых кластеров. Каждый кластер размещается внутри прямоугольника размером H x W, при этом прямоугольники не перекрываются. Стороны прямоугольников не обязаны быть параллельны осям координат. Гарантируется, что такое разбиение единственно для заданных размеров прямоугольников. Расстояние между двумя точками вычисляется по формуле Евклида.
Антицентром кластера будем называть точку кластера, сумма расстояний от которой до остальных точек этого кластера максимальна. 
В файле А храняться координаты точек двух кластеров, где H = 6,5 и W = 4,5 для каждого кластера. В каждой строке записана информация о расположении на карте одной звезды: сначало координата xx, затем координата yy. Известно, что количество точек не превышает 1000.
В файле Б хранятся координаты точек трёх кластеров, где H = 5, W = 4,5 для каждого кластера. Известно, что количество точек не превышает 10000. Структура хранения информации в файле Б аналогична структуре в файле А.
Известно, что в файле А имеются координаты ровно трёх, а в файле Б ровно четырёх "лишних" точек, представляющих аномалии, которые возникли в результате помех при передаче данных. Эти точки не относятся ни к одному из кластеров, их учитывать не нужно.
Для  файла А определите координаты антицентра каждого кластера, затем найдите два числа: PxPx - максимальную абсциссу антицентра  кластера и PyPy - максимальную ординату антицентра кластера.
Для файла Б определите координаты антицентра каждого кластера, затем найдите два числа: Q1Q1 - расстояние между антицентрами кластеров с минимальным и максимальным количеством точек и Q2Q2 - максимальное расстояние от антицентра кластера до точки этого же кластера среди всех кластеров. Гарантируется, что во всех кластерах количество точек различно.
В ответе запишите 4 числа: а первой строке - сначала целую часть абсолютной величины произведения PxPx ×10000×10000, затем целую часть абсолютной величины произведения PyPy ×10000×10000; во второй строке  - сначала целую часть произведения Q1Q1×10000×10000, затем целую часть произведения Q2Q2×10000×10000.

	Для файла А:

		from math import dist

		def acnt(cl):
		    l = []
		    for p1 in cl: l.append([sum(dist(p1, p2) for p2 in cl), p1])
		    return max(l)[1]

		d = [[float(t) for t in s.replace(',', '.').split()] for s in open('27A_24985.txt')]
		c = []
		while d:
		    c.append([d.pop()])
		    for p1 in c[-1]:
		        nb = [p2 for p2 in d if dist(p1, p2) < 1]
		        c[-1].extend(nb)
		        for p in nb: d.remove(p)
		c = [t for t in c if len(t) > 1]

		res = [acnt(t) for t in c]
		px = max(t[0] for t in res)
		py = max(t[1] for t in res)
		print(int(abs(px * 10000)), int(abs(py * 10000)))

	Для файла Б:

		from math import dist

		def acnt(cl):
		    l = []
		    for p1 in cl: l.append([sum(dist(p1, p2) for p2 in cl), p1])
		    return max(l)[1]

		d = [[float(t) for t in s.replace(',', '.').split()] for s in open('27B_24985.txt')]
		c = []
		while d:
		    c.append([d.pop()])
		    for p1 in c[-1]:
		        nb = [p2 for p2 in d if dist(p1, p2) < 1]
		        c[-1].extend(nb)
		        for p in nb: d.remove(p)
		c = [t for t in c if len(t) > 1]

		minCL = c[2]
		maxCL = c[1]
		q1 = dist(acnt(minCL), acnt(maxCL))
		q2 = max(max(dist(acnt(c[0]), pnt) for pnt in c[0]), max(dist(acnt(c[1]), pnt) for pnt in c[1]), max(dist(acnt(c[2]), pnt) for pnt in c[2]))
		print(int(q1 * 10000), int(q2 * 10000))

Фрагмент звёздного неба спроецирован на плоскость с декартовой системой координат. Учёный решил провести кластеризацию полученных точек, являющихся изображениями звёзд, то есть разбить их множество на N непересекающихся непустых подмножеств (кластеров), таких что точки каждого подмножества лежат внутри прямоугольника со сторонами длиной H и W, причём эти прямоугольники между собой не пересекаются. Стороны прямоугольников не обязательно параллельны координатным осям.
Гарантируется, что такое разбиение существует и единственно для заданных размеров прямоугольников.
Будем называть центром кластера точку этого кластера, сумма расстояний от которой до всех остальных точек кластера минимальна. Для каждого кластера гарантируется единственность его центра. Расстояние между двумя точками на плоскости) вычисляется по формуле Евклида.
В файле A хранятся данные о звёздах двух кластеров, где H=8, W=4 для каждого кластера. В каждой строке записана информация о расположении на карте одной звезды: сначала координата x, затем координата y. Значения даны в условных единицах. Известно, что количество звёзд не превышает 1000.
В файле B хранятся данные о звёздах трёх кластеров, где H=6, W=7 для каждого кластера. Известно, что количество звёзд не превышает 1000. Структура хранения информации о звездах в файле B аналогична файлу А. 
Известно, что в файле Б имеются координаты ровно трёх «лишних» точек, являющихся аномалиями, возникшими в результате помех при передаче данных. Эти три точки не относятся ни к одному из кластеров, их учитывать не нужно.
Для файла А определите координаты центра каждого кластера, затем вычислите два числа: P1P1 – сумма абсциссы и ординаты центра кластера с наименьшим количеством точек, и P2P2 – сумма абсциссы и ординаты центра кластера с наибольшим количеством точек. Гарантируется, что во всех кластерах количество точек различно.
Для файла Б определите координаты центра каждого кластера, затем вычислите два числа: QxQx – абсциссу наиболее отдалённого центра кластера от начала координат, и QyQy – ординату ближайшего центра кластера к началу координат.
В ответе запишите четыре числа: в первой строке - сначала абсолютную величину целой части произведения P1P1 × 10000, затем абсолютную величину целой части произведения P2P2 × 10 000; во второй строке - сначала целую часть произведения QxQx× 10 000, затем целую часть произведения QyQy × 10 000.
Возможные данные одного из файлов иллюстрированы графиком. 

	Для файла А:

		from math import dist

		def cnt(cl):
		    l = []
		    for p1 in cl: l.append([sum(dist(p1, p2) for p2 in cl), p1])
		    return min(l)[1]

		d = [[float(t) for t in s.replace(',', '.').split()] for s in open('27_A_24898.txt')]
		c = []
		while d:
		    c.append([d.pop()])
		    for p1 in c[-1]:
		        nb = [p2 for p2 in d if dist(p1, p2) < 1]
		        c[-1].extend(nb)
		        for p in nb: d.remove(p)
		c = [t for t in c if len(t) > 1]

		print([len(t) for t in c])
		minCL = c[0]
		maxCL = c[1]
		minCLcnt = cnt(minCL)
		maxCLcnt = cnt(maxCL)
		p1 = minCLcnt[0] + minCLcnt[1]
		p2 = maxCLcnt[0] + maxCLcnt[1]
		print(abs(int(p1 * 10000)), abs(int(p2 * 10000)))

	Для файла Б:

		from math import dist

		def cnt(cl):
		    l = []
		    for p1 in cl: l.append([sum(dist(p1, p2) for p2 in cl), p1])
		    return min(l)[1]

		d = [[float(t) for t in s.replace(',', '.').split()] for s in open('27_B_24898.txt')]
		c = []
		while d:
		    c.append([d.pop()])
		    for p1 in c[-1]:
		        nb = [p2 for p2 in d if dist(p1, p2) < 1]
		        c[-1].extend(nb)
		        for p in nb: d.remove(p)
		c = [t for t in c if len(t) > 1]

		res = [cnt(t) for t in c]
		qx = max([dist([0, 0], t), t[0]] for t in res)[1]
		qy = min([dist([0, 0], t), t[1]] for t in res)[1]
		print(int(qx * 10000), int(qy * 10000))

Фрагмент звёздного неба спроецирован на плоскость с декартовой системой координат. Учёный решил провести кластеризацию полученных точек, являющихся изображениями звёзд, то есть разбить их множество на N непересекающихся непустых подмножеств (кластеров) так, что они будут лежать внутри сектора окружности радиуса R = 50 с центральным углом 20°. Гарантируется, что такое разбиение существует и единственно.
Будем называть центром кластера точку этого кластера, сумма расстояний от которой до всех остальных точек кластера минимальна. Для каждого кластера гарантируется единственность его центра. Расстояние между двумя точками на плоскости вычисляется по формуле Евклида.
В файле А хранятся данные о звёздах трёх кластеров, для которых центром окружности является точка C (5, –9). В каждой строке записана информация о расположении на карте одной звезды: сначала координата х, затем координата у. Значения даны в условных единицах. Известно, что количество звёзд не превышает 1000
В файле Б хранятся данные о звёздах шести кластеров, для которых центром окружности является точка C (–10, –7). Известно, что количество звёзд не превышает 10 0 Структура хранения информации о звёздах в файле Б аналогична файлу А.
Для каждого файла определите координаты центра каждого кластера, затем вычислите два числа:  Px Px – среднее арифметическое абсцисс центров кластеров, и  Py Py – среднее арифметическое ординат центров кластеров.
В ответе запишите четыре числа: в первой строке сначала целая часть абсолютного значения произведения Px×10000Px×10000, затем целая часть абсолютного значения произведения Py×10000Py×10000 для файла А, во второй строке – аналогичные данные для файла B.
Возможные данные одного из файлов иллюстрированы графиком. 

	Для файла А:

		from math import dist

		def f(x1, y1, x2, y2):
		    k = (y2 - y1) / (x2 - x1)
		    b = y1 - k * x1
		    return [k, b]
		print(f(11, 0, 12, 1))

		def cnt(cl):
		    l = []
		    for p1 in cl: l.append([sum(dist(p1, p2) for p2 in cl), p1])
		    return min(l)[1]

		c = [[], [], []]
		for s in open('27_A_21599.txt'):
		    x, y = [float(t) for t in s.replace(',', '.').split()]
		    if y < -7: c[0].append([x, y])
		    elif y < (x - 10): c[1].append([x, y])
		    else: c[2].append([x, y])

		res = [cnt(t) for t in c]
		print(res)
		px = sum(t[0] for t in res) / len(res)
		py = sum(t[1] for t in res) / len(res)
		print(int(abs(px * 10000)), int(abs(py * 10000)))

	Для файла Б: 

		from math import dist

		def cnt(cl):
		    l = []
		    for p1 in cl: l.append([sum(dist(p1, p2) for p2 in cl), p1])
		    return min(l)[1]

		d = [[float(t) for t in s.replace(',', '.').split()] for s in open('27_B_21599.txt')]
		c = []
		while d:
		    c.append([d.pop()])
		    for p1 in c[-1]:
		        nb = [p2 for p2 in d if dist(p1, p2) < 1.5]
		        c[-1].extend(nb)
		        for p in nb: d.remove(p)

		res = [cnt(t) for t in c]
		print(res)
		px = sum(t[0] for t in res) / len(res)
		py = sum(t[1] for t in res) / len(res)
		print(int(abs(px * 10000)), int(abs(py * 10000)))