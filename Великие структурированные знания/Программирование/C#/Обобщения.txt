	Кроме обычных типов фреймворк .NET также поддерживает обобщенные типы (generics), а также создание обобщенных методов. Чтобы разобраться в особенности данного явления, сначала посмотрим на проблему, которая могла возникнуть до появления обобщенных типов. Посмотрим на примере. Допустим, мы определяем класс для хранения данных пользователя:

		class Person
		{
		    public int ID { get;}
		    public string Name { get;}
		    public Person(int ID, string Name)
		    {
		        this.ID = ID;
		        this.Name = Name;
		    }
		}

	Класс Person определяет два свойства: Id - уникальный идентификатор пользователя и Name - имя пользователя.

	Здесь идентификатор пользователя задан как числовое значение, то есть это будут значения 1, 2, 3, 4 и так далее.

	Однако также нередко для идентификатора используются и строковые значения. И у числовых, и у строковых значений есть свои плюсы и минусы. И на момент написания класса мы можем точно не знать, что лучше выбрать для хранения идентификатора - строки или числа. Либо, возможно, этот класс будет использоваться другими разработчиками, которые могут иметь свое мнение по данной проблеме, например, они могут для представления идентификатора создать специальный класс.

	И на первый взгляд, чтобы выйти из подобной ситуации, мы можем определить свойство Id как свойство типа object. Так как тип object является универсальным типом, от которого наследуется все типы, соответственно в свойствах подобного типа мы можем сохранить и строки, и числа:

		class Person
	    {
	        public object ID { get; }
	        public string Name { get; }
	        public Person(object ID, string Name)
	        {
	            this.ID = ID;
	            this.Name = Name;
	        }
	    }

	Затем этот класс можно было использовать для создания пользователей в программе:

		Person pers = new Person(1703, "Tom"); // Упаковка значения int в тип Object
		Person pers2 = new Person("NTA", "Bob"); // Упаковка значения string в тип Object

	    int persID = (int)pers.ID; // Распаковка в тип int
        string pers2ID = (string)pers2.ID; // Распаковка в тип string

	    Console.WriteLine(persID);
		Console.WriteLine(pers2ID);	

	Все вроде замечательно работает, но такое решение является не очень оптимальным. Дело в том, что в данном случае мы сталкиваемся с такими явлениями как упаковка (boxing) и распаковка (unboxing).

	Упаковка (boxing) предполагает преобразование объекта значимого типа (например, типа int) к типу object. При упаковке общеязыковая среда CLR обертывает значение в объект типа System.Object и сохраняет его в управляемой куче (хипе). Распаковка (unboxing), наоборот, предполагает преобразование объекта типа object к значимому типу. Упаковка и распаковка ведут к снижению производительности, так как системе надо осуществить необходимые преобразования.

	Кроме того, существует другая проблема - проблема безопасности типов. Так, мы получим ошибку во время выполнения программы, если напишем следующим образом:

		Person pers = new Person(1703, "Tom");
		string persID = (string)pers.ID; // Ошибочка
	    Console.WriteLine(persID);

	Мы можем не знать, какой именно объект представляет Id, и при попытке получить число в данном случае мы столкнемся с исключением InvalidCastException. Причем с исключением мы столкнемся на этапе выполнения программы.
	 
	Для решения этих проблем в язык C# была добавлена поддержка обобщенных типов (также часто называют универсальными типами). Обобщенные типы позволяют указать конкретный тип, который будет использоваться. Поэтому определим класс Person как обощенный:

		class Person<T>
	    {
	        public T ID { get; set; }
	        public string Name { get; set; }
	        public Person(T ID, string Name, int Age)
	        {
	            this.ID = ID;
	            this.Name = Name;
	        }
	    }

	Угловые скобки в описании class Person<T> указывают, что класс является обобщенным, а тип T, заключенный в угловые скобки, будет использоваться этим классом. Необязательно использовать именно букву T, это может быть и любая другая буква или набор символов. Причем сейчас на этапе написания кода нам неизвестно, что это будет за тип, это может быть любой тип. Поэтому параметр T в угловых скобках еще называется универсальным параметром, так как вместо него можно подставить любой тип.

	Например, вместо параметра T можно использовать объект int, то есть число, представляющее номер пользователя. Это также может быть объект string, либо или любой другой класс или структура(важно).

	Поскольку класс Person является обобщенным, то при определении переменной после названия типа в угловых скобках необходимо указать тот тип, который будет использоваться вместо универсального параметра T. В данном случае объекты Person типизируются типами int и string:

		Person<int> person1 = new Person<int>(5467, "James");
        Person<string> person2 = new Person<string>("Alex4124superPuper", "Alex");

    Поэтому у первого объекта person1 свойство Id будет иметь тип int, а у объекта person2 - тип string.

    Таким образом, используя обобщенный вариант класса, мы снижаем время на выполнение и количество потенциальных ошибок.

    При этом универсальный параметр также может представлять обобщенный тип:

	    class Company<C>
	    {
	        public C CEO { get; set; }
	        public Company(C CEO) { this.CEO = CEO; }
	    }
	    class Person<T>
	    {
	        public T ID { get; set; }
	        public string Name { get; set; }
	        public Person(T ID, string Name)
	        {
	            this.ID = ID;
	            this.Name = Name;
	        }
	    }

	Здесь класс компании определяет свойство CEO, которое хранит президента компании. И мы можем передать для этого свойства значение типа Person, типизированного каким-нибудь типом:

		Person<int> person = new Person<int>(2145, "Adam");
        Company<Person<int>> company = new Company<Person<int>>(person);
        Console.WriteLine($"{company.CEO.ID} | {company.CEO.Name}"); // 2145 | Adam

Статические поля обобщенных классов

	При типизации обобщенного класса определенным типом будет создаваться свой набор статических членов. Например, в классе Person определено следующее статическое поле:

		class Person<T>
	    {
	        public static T? code { get; set; }
	        public T ID { get; set; }
	        public string Name { get; set; }
	        public Person(T ID, string Name)
	        {
	            this.ID = ID;
	            this.Name = Name;
	        }
	    }

	Теперь типизируем класс двумя типами int и string:

	 	Person<int> person1 = new Person<int>(51235, "Eblan");
        Person<string> person2 = new Person<string>("abracadabra", "Mag");
        Person<int>.code = 25098;
        Person<string>.code = "ohio";
        Console.WriteLine($"{Person<int>.code} | {Person<string>.code}"); // 25098 | ohio

Использование нескольких универсальных параметров

	Обобщения могут использовать несколько универсальных параметров одновременно, которые могут представлять одинаковые или различные типы:

		class Person<T, K>
	    {
	        public T ID { get; set; }
	        public K Password { get; set; }
	        public string Name { get; set; }
	        public Person(T ID, K Password, string Name)
	        {
	            this.ID = ID;
	            this.Password = Password;
	            this.Name = Name;
	        }
	    }

	Здесь класс Person использует два универсальных параметра: один параметр для идентификатора, другой параметр - для свойства-пароля. Применим данный класс:

	 	Person<int, long> person1 = new Person<int, long>(78569, 7777765432190, "IVAN");
        Person<string, string> person2 = new Person<string, string>("nukeKID", "qwerty12345", "Perun");
        Console.WriteLine($"{person1.ID} | {person1.Password} | {person1.Name}"); // 78569 | 7777765432190 | IVAN
		Console.WriteLine($"{person2.ID} | {person2.Password} | {person2.Name}"); // nukeKID | qwerty12345 | Perun

	Здесь объект Person типизируется типами int и string. То есть в качестве универсального параметра T используется тип int, а для параметра K - тип string.










