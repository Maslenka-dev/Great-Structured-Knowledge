2 

	print ('x y z w')
	for x in 0,1:
	    for y in 0,1:
	        for z in 0,1:
	            for w in 0,1:
	                if (x or (not y)) and (not(x == z) and (not w)) == 1:
	                    print(x, y, z, w)

    x y z w
	0 0 1 0
	1 0 0 0
	1 1 0 0	


	print ('x y z w')
	for x in 0,1:
	    for y in 0,1:
	        for z in 0,1:
	            for w in 0,1:
	                if (((x and w) or (w and z)) == ((z <= y) and (y <= x))) == 1:
	                    print(x, y, z, w)

	x y z w
	0 0 1 0
	0 1 0 0
	0 1 0 1
	0 1 1 0
	1 0 0 1
	1 0 1 0
	1 1 0 1
	1 1 1 1   


	print ('x y z w')
	for x in 0,1:
	    for y in 0,1:
	        for z in 0,1:
	            for w in 0,1:
	                if ((y <= w) == (x <= (not z)) and (x or w)) == 1:
	                    print(x, y, z, w)      

	print ('x y z w')
	for x in 0,1:
	    for y in 0,1:
	        for z in 0,1:
	            for w in 0,1:
	                if ((y <= w) == (x <= (not z)) and (x or w)) == 0:
	                    print(x, y, z, w)          
    
	x y z w     0
	0 0 0 0
	0 0 1 0
	0 1 0 0
	0 1 1 0 
	1 0 1 0
	1 0 1 1
	1 1 0 0
	1 1 1 1

	x y z w     1
	0 0 0 1
	0 0 1 1
	0 1 0 1
	0 1 1 1
	1 0 0 0
	1 0 0 1
	1 1 0 1
	1 1 1 0

23 
	
	Условие: 3 - 15 - 50. траектория не содержит 55

		def f(x, y):
	    if x > y or x == 33:
	        return 0
	    if x == y:
	        return 1
	    else:
	        return f(x + 1, y) + f(x * 2, y) + f(x * 3, y)
		print(f(3, 15) * f(15, 50))

		Отв: 121

13 (сложный вариант)

		import itertools
		count = 0
		s = itertools.product([0, 1], repeat = 20)
		for i in s:
		    if (5 + sum(i)) % 5 != 0:
		        count += 1
		print(count)

	количество единиц в двоичной записи IP-адреса не кратно 5

	Использование функции itertools.product() с параметром repeat=20 для списка [0, 1] создаст все возможные комбинации длиной 20, состоящие из элементов 0 и 1. Это эквивалентно генерации всех двоичных чисел от 00000000000000000000 до 11111111111111111111.


		import itertools
		count = 0
		s = itertools.product([0, 1], repeat = 13)
		for i in s:
		    if i[12] == 1 and i[11] == 1:
		        if(10 + sum(i)) % 3 == 0:
		            count += 1
		print(count)

	количество единиц в двоичной записи IP-адреса кратно 3, а сама двоичная запись оканчивается на 11

16

	Условие: F(1) = 1 | F(2) = 1 | если n > 2, то F(n-1) * n - 2 * F(n-2)

		def F(n):
	    if n == 1:
	        return 1
	    if n == 2:
	        return 1
	    if n > 2:
	        return F(n-1) * n - 2 * F(n-2)
		print(F(6))


	Условие: F(n) = 1 если n = 1 | F(n) = n + F(n - 1) если n нечетно | F(n) = 2 * F(n - 2) если n > 1 и n нечетно

		def F(n):
	    if n == 1:
	        return 1
	    if n % 2 == 0:
	        return n + F(n - 1)
	    if n > 1 and n % 2 != 0:
	        return 2 * F(n - 2)
		print(F(26)) 


	F(n div 10) + (n mod 10) - функция, расчитывающая сумму цифр числа n.


	Условие: F(0) = 0 | F(n) = F(n div 10) + (n mod 10) | Укажите количество таких чисел n из интервала 765432019 <= n <= 1542613239 для которых F(n) > F(n + 1).

	Решение: Данная функция считает сумму цифр числа n. Необходимо определить в каких случаях сумма цифр в числе больше у меньшего числа. Это возможно только в одном случае, когда число оканчивается на цифру 9. В таком случае разряд увеличивается и сумма цифр следующего числа будет меньше суммы чисел предыдущего (Пример: число 239, сумма цифр 14, следующее число 240, сумма цифр 6). Первое такое число в данном интервале 765432019, далее можно посчитать все остальные числа с шагом 10. Таких чисел будет:

		s = 0
		for i in range(765432019, 1542613239 + 1, 10):
		    s += 1
		print(s) # 77718123


	Условие: F(n) = 1 если n <= 5 | F(n) = n + F(n - 2) если n > 5.

		import sys
		sys.setrecursionlimit(10**8)
		def f(n):
		    if n <= 5: return 1
		    if n > 5: return n + f(n - 2)
		print(f(2126) - f(2122))

	Альтернативный вариант решения 16 задания:

		

14

	Условие: 4 * 343 ** 5 + 6 * 49 ** 8 - 50 | Система счисления: 7. Сколько цифр 6 содержится в записи?

		x = 4 * 343 ** 5 + 6 * 49 ** 8 - 50
		s = ''
		while x != 0: 
		    s += str(x % 7) // остаток от деления на 7 прибавляется к s (перевод x в семеричную систему)
		    x //= 7 // целочисленное деление на 7 (перевод x в семеричную систему)
		s = s[::-1] // разворот строки 
		print(s.count('6')) // подсчет цифр 6

    Операции в одной СС

		Условие: 98x79641 + 25x49 + 63x5 | основание системы - 22 | ! наименьшее x если 98x79641 + 25x49 + 63x5 кратно 21 | основание системы для x - 15

			for x in '0123456789abcde':
		    x1 = '98' + str(x) + '79641'
		    x2 = '25' + str(x) + '49'
		    x3 = '63' + str(x) + '5'
		    res = int(x1, 22) + int(x2, 22) + int(x3, 22)
		    if res % 21 == 0:
		        res = res // 21
		        print(res)
		        break


	    Условие 98x79641 + 36x14 + 73x4 | основание системы - 19 | ! наибольшее x если 98x79641 + 36x14 + 73x4 кратно 18 | основание системы для x - 10 

		    for x in '0123456789abcdefghi':
		    x1 = '98' + str(x) + '79641'
		    x2 = '36' + str(x) + '14'
		    x3 = '73' + str(x) + '4'
		    res = int(x1, 19) + int(x2, 19) + int(x3, 19)
		    if res % 18 == 0:
		        print(res // 18) // 470402599   	


	    Условие: 123xAB3 + 3CEx321 | основание системы - 31 | ! наибольшее x если 123xAB3 + 3CEx321 кратно 17 | основание системы для x - 10

		    for x in range(31):
		    x1 = 1*31**6+2*31**5+3*31**4+x*31**3+10*31**2+11*31**1+3*31**0 // перевод из 31-чной в 10-чную
		    x2 = 3*31**6+12*31**5+14*31**4+x*31**3+3*31**2+2*31**1+1*31**0
		    res = x1 + x2
		    if (res) % 17 == 0:
		        print(res // 17)


	    Условие: F29x8EAD637 * BAxDE0C1B37  | основание системы - 37 | ! наибольшее x если 123xAB3 + 3CEx321 кратно 17 | основание системы для x - 10

		    for x in range(37, 0, -1):
		    x1 = 15*37**8 + 2*37**7 + 9*37**6 + x*37**5 + 8*37**4 + 14*37**3 + 10*37**2 + 13*37 + 6
		    x2 = 11*37**8 + 10*37**7 + x*37**6 + 13*37**5 + 14*37**4 + 0*37**3 + 12*37**2 + 1*37 + 11
		    if (x1 * x2) % 36 == 0:
		        print(1*37**2 + x*37 + 2)

		    	или

		    for x in range(37):
		    x1 = 15*37**8 + 2*37**7 + 9*37**6 + x*37**5 + 8*37**4 + 14*37**3 + 10*37**2 + 13*37 + 6
		    x2 = 11*37**8 + 10*37**7 + x*37**6 + 13*37**5 + 14*37**4 + 0*37**3 + 12*37**2 + 1*37 + 11
		    if (x1 * x2) % 36 == 0:
		        print(1*37**2 + x*37 + 2)


	   	Условие: AB267D1 + F024A89 | основание системы - p | ! наименьшее p при котором AB267D1 + F024A89 будет делиться на p - 1 | основание системы для x - 10

		    for p in range(16, 1000):		// Так как F - 15, p > 15
		    x1 = 10*p**6 + 11*p**5 + 2*p**4 + 6*p**3 + 7*p**2 + 13*p**1 + 1
		    x2 = 15*p**6 + 0*p**5 + 2*p**4 + 4*p**3 + 10*p**2 + 8*p**1 + 9
		    if(x1 + x2) % (p - 1) == 0:
		        print(p) 


	    Условие: zxyx4 + xy658 = wzx73 | основание системы - p | ! Определить значение xyzw в десятичной системе

			for p in range(9, 100):			// Так как в выражении xy658 есть цифра 8, p > 8
			    for x in range(1, p):
			        for y in range(1, p):
			            for z in range(1, p):
			                for w in range(1, p):
			                    x1 = z*p**4+x*p**3+y*p**2+x*p**1+4
			                    x2 = x*p**4+y*p**3+6*p**2+5*p**1+8
			                    x3 = w*p**4+z*p**3+x*p**2+7*p**1+3
			                    if (x1 + x2) == x3:
			                        print(x*p**3 + y*p**2 + z*p**1 + w)  

	Операции в одной СС с разными переменными

		Условие: В числе 57x692y1940 x и y обозначают некоторые цифры из алфавита системы счисления с основанием 40. Определите такие значения x и y, при которых приведённое число кратно 39, а число yx40 является полным квадратом. В ответе запишите значение числа yx40 в десятичной системе счисления.
	
			for x in range(40):
			    for y in range(40):
			        s = 5*40**8 + 7*40**7 + x*40**6 + 6*40**5 + 9*40**4 + 2*40**3 + y*40**2 + 1*40**1 + 9
			        if s % 39 == 0 and (y*40**1 + x) ** 0.5 == round((y*40**1 + x) ** 0.5): print(y*40**1 + x)

	Операции в разных СС с одной переменной

		Условие: 2x84(19) + 2B3x(16) | ! Определить наименьшее значение x при котором значение 2x8419(19) + 2B3x16(16) кратно 88 | Для найденного x вычислите частное от деления на 88 в десятичной системе

			for x in range(16):
			    x1 = 2*19**3 + x*19**2 + 8*19**1 + 4
			    x2 = 2*16**3 + 11*16**2 + 3*16**1 + x
			    if (x1 + x2) % 88 == 0:
			        print((x1 + x2) // 88)		


		Условие: 8x71(13) + 3xDF(17) | ! Определить наименьшее значение x при котором значение 8x71(13) + 3xDF(17) кратно 197 | Для найденного x вычислите частное от деления на 197 в десятичной системе

			for x in range(10):
			    x1 = 8*13**3 + x*13**2 + 7*13 + 1
			    x2 = 3*17**3 + x*17**2 + 13*17 + 15
			    if (x1 + x2) % 197 == 0:
			        print((x1 + x2) // 197)


    Операции в разных СС с двумя переменными

    	Условие: x231y(12) + 78x98y(14) | ! Определить наименьшее значение x и y при котором значение x231y(12) + 78x98y(14) кратно 99 | Для найденного x и y вычислите частное от деления на 99 в десятичной системе

	    	for x in range(12):
			    for y in range(12):
			        x1 = x*12**4 + 2*12**3 + 3*12**2 + 1*12 + y  
			        x2 = 7*14**5 + 8*14**4 + x*14**3 + 9*14**2 + 8*14 + y
			        if (x1 + x2) % 99 == 0:
			            print((x1 + x2) // 99)

6

	ось ординат:

		import turtle - добавление библиотеки, предназначенной для создания графики с использованием черепахи
		t = turtle.Turtle() - создание объекта черепахи
		t.left(90) - поворот черепахи на лево для направления по оси ординат
		k = 40 - коэффициент масштабирования
		t.pendown() - ручка опущена
		turtle.tracer(0) - отключение анимации
		for i in range(7): 
		    t.forward(10*k) - вперед
		    t.right(120) - вправо, градус
		t.penup() - ручка поднята
		for x in range(-10, 10): - построение пространства точек по x 
		    for y in range(-10, 10): - построение пространства точек по y
		        t.setpos(x * k, y * k) - перемещение черепахи в точку в данный момент
		        t.dot(5, 'red') - отрисовка точки
		turtle.done() - завершение программы


	ось абсцисс:

		import turtle
		t = turtle.Turtle()
		k = 40
		t.pendown()
		turtle.tracer(0)
		for i in range(7):
		    t.forward(10*k)
		    t.right(120)
		t.penup()
		for x in range(-10, 10):
		    for y in range(-10, 10):
		        t.setpos(x * k, y * k)
		        t.dot(5, 'red')
		turtle.done()


	Пример решения +- сложного варика с осью ординат:

	Условие: 

	Повтори 9 [Вперёд 29 Направо 90 Вперёд 17 Направо 90]
	Поднять хвост
	Вперёд 5 Направо 90 Вперёд 1 Налево 90
	Опустить хвост
	Повтори 9 [Вперёд 64 Направо 90 Вперёд 48 Направо 90]
	Определите площадь пересечения фигур, нарисованных при помощи алгоритма.

		import turtle
		t = turtle.Turtle()
		t.left(90)
		k = 11
		t.pendown()
		turtle.tracer(0)
		for i in range(9):
		    t.forward(29 * k)
		    t.right(90)
		    t.forward(17 * k)
		    t.right(90)
		t.penup()
		t.forward(5 * k)
		t.right(90)
		t.forward(1 * k)
		t.left(90)
		t.pendown()
		for i in range(9):
		    t.forward(64 * k)
		    t.right(90)
		    t.forward(48 * k)
		    t.right(90)
		t.penup()
		for x in range (-50, 50):
		    for y in range(-50, 50):
		        t.setpos(x * k, y * k)
		        t.dot(5, 'red')
		turtle.done()

	24 * 16 = 384

7

	Условие: Книгу объёмом 1 Мбайт записали как аудиокнигу. Запись велась в формате стерео (2 канала) с частотой 48 кГц и разрешением 24 бит. За одну минуту записывалось в среднем 1,5 Кбайт текста. Сжатие данных позволило сократить размер полученного звукового файла на 84%. Для удобства использования запись разделили на фрагменты со средним размером 15 Мбайт. Определите количество полученных фрагментов.

		x = 1 * 1024 * 1024 * 8
		x2 = 1.5 * 1024 * 8
		i = 2
		f = 48 * 1000
		l = 24
		m = (x / x2) * 60
		res = m * l * f * i
		res2 = res * 0.16
		print(res2 / (15 * 1024 * 1024 * 8))	// 120

12

	Условие: На вход этой программе подаётся строка длины 94, состоящая из цифры 3, за которой следуют 93 идущих подряд цифр 9. Условие: '3' + '9' * 93

		s = '3' + '9' * 93
		while ('19' in s or '29' in s or '3999' in s):
		    s = s.replace('19', '2', 1)
		    s = s.replace('299', '3', 1)
		    s = s.replace('3999', '1', 1)
		print(s)


	Условие: Какая строка получится в результате применения приведённой ниже программы к строке вида 1…12…2 (39 единиц и 39 двоек)? Условие: '1' * 39 + '2' * 39

		s = '1' * 39 + '2' * 39
		while ('111' in s):
		    s = s.replace('111', '2', 1)
		    s = s.replace('222', '1', 1)
		print(s)


	Условие: Какая строка получится в результате применения приведённой ниже программы к строке, состоящей из 70 идущих подряд цифр 8? Условие: '8' * 70

		s = '8' * 70
		while ('2222' in s or '8888' in s):
		    if('2222' in s):
		        s = s.replace('2222', '88', 1)
		    else:
		        s = s.replace('8888', '22', 1)
		print(s)


	Условие: На вход приведённой ниже программе поступает строка, начинающаяся с символа ">", а затем содержащая 11 цифр 1, 12 цифр 2 и 30 цифр 3, расположенных в произвольном порядке. Определите сумму числовых значений цифр строки, получившейся в результате выполнения программы. Так, например, если результат работы программы представлял бы собой строку, состоящую из 50 цифр 4, то верным ответом было бы число 200.

		s = '>' + '1' * 11 + '2' * 12 + '3' * 30
		while '>1' in s or '>2' in s or '>3' in s:
		    if '>1' in s:
		        s = s.replace('>1', '22>', 1)
		    if '>2' in s:
		        s = s.replace('>2', '2>', 1)
		    if '>3' in s:
		        s = s.replace('>3', '1>', 1)
		print(s.count('1') + s.count('2')*2 + s.count('3')*3)


	Условие: Известно, что исходная строка A содержала ровно два нуля - на первом и на последнем месте, а также по 10 единиц и двоек. После выполнения данной программы получилась строка B, содержащая 6 единиц и 5 двоек. Какое наибольшее количество четвёрок может быть в строке B?

		from itertools import product
		for i in product('12', repeat = 20): // генерация всех возможных строк длины 20, с символами 																				  либо'1', либо '2'.
	    s = '0' + ''.join(i) + '0' // объединение сгенерированной последовательности с двумя '0'
	    if s.count('1') == 10 and s.count('2') == 10: // условие для A
	        while not '00' in s:
	            s = s.replace('012', '30')
	            if '011' in s:
	                s = s.replace('011', '20')
	                s = s.replace('022', '40')
	            else:
	                s = s.replace('01', '10')
	                s = s.replace('02', '101')
	        if s.count('1') == 6 and s.count('2') == 5: // условие для B
	            print(s.count('4'))

	Условие: Известно, что исходная строка начиналась с нуля и заканчивалась нулём, а между ними содержала только единицы, двойки и тройки. После выполнения данной программы получилась строка, содержащая 61 единицу, 50 двоек и 18 троек. Сколько цифр было в исходной строке?

		for i1 in range(61):
		    for i2 in range(61):
		        for i3 in range(61):
		            srcS = '0' + i1 * '1' + i2 * '2' + i3 * '3' + '0'
		            s = srcS
		            while '01' in s or '02' in s or '03' in s:
		                s = s.replace('01', '210', 1)
		                s = s.replace('02', '3101', 1)
		                s = s.replace('03', '2012', 1)
		            if s.count('1') == 61 and s.count('2') == 50 and s.count('3') == 18: 
		                print(len(srcS)) // 38
		                quit()	

19, 20, 21

	!!Строчка [s for s in range(1, 57) if f(s, 2)] - эта конструкция называется "генератор". Это способ в одну строку создать список (массив), наполненный значениями. Двоеточия нет именно потому, что это не цикл for, а генератор.

	ЗАПОМНИТЬ! Поменять all(moves) на any(moves) в случае если в 19 задании спрашивают (после неудачного хода пети), но для 20 и 21 меняем обратно на all(moves).




	19) Условие: одна куча | stop 56 | + 1 | +2 | *2| петя даун. Ваня выиграл своим первым ходом после неудачного первого хода Пети

		def f(x, h):
		    if x >= 56:
		        return h % 2 == 0
		    if h == 0:
		        return False 
		    moves = [f(x + 1, h - 1), f(x + 2, h - 1), f(x * 2, h - 1)]
		    if h % 2 != 0:
		        return any(moves)  
		    else:
		        return any(moves)  

		print([s for s in range(1, 57) if f(s, 2)]) // [14]

		Если в 19 задании спрашивается победа Вани или Пети после НЕУДАЧНОГО ХОДА противника, необходимо в 10 строчке поменять all на any. В 20 и 21 заданиях не трогаем эту строку.


	55815) Условие: одна куча | stop 78 | + 1 | +4 | * 4 |  

		def f(x, h): 
		    if x >= 78: 
		        return h % 2 == 0 
		    if h == 0: 
		        return 0 
		    moves = [f(x + 1, h - 1), f(x + 4, h - 1), f(x * 4, h - 1)] 
		    if h % 2 != 0: 
		        return any (moves) 
		    if h % 2 == 0: 
		        return all(moves) 
		print([s for s in range(1, 79) if f(s, 2)]) 
		print([s for s in range(1, 79) if not f(s, 1) and f(s, 3)]) 
		print([s for s in range(1, 79) if (f(s, 2) or f(s, 4)) and not f(s, 2)]) 

		// [19, 78]
		   [15, 18]
		   [14, 17]


	27780) Условие: две кучи | stop 74 | 1 <= s <= 61 | + 1 | * 2 | 

		def f(x, y, h):
		    if x + y >= 74:
		        return h % 2 == 0
		    if h == 0:
		        return 0
		    moves = [f(x + 1, y, h - 1), f(x * 2, y, h - 1), f(x, y + 1, h - 1), f(x, y * 2, h - 1)]
		    if h % 2 != 0:
		        return any(moves)
		    else:
		        return all(moves) // с заменой
		print([s for s in range(1, 62) if f(12, s, 2)])
		print([s for s in range(1, 62) if not f(12, s, 1) and f(12, s, 3)])
		print([s for s in range(1, 62) if (f(12, s, 2) or f(12, s, 4)) and not f(12, s, 2)])

		// [16] // с заменой all(moves) на any(moves)
		   [24, 30]
		   [29]

	Если есть условие добавления камней в МЕНЬШУЮ кучу:

		def f(x, y, h):
			if x + y >= 61: return h % 2 == 0
			if h == 0: return 0
			if y > x: // если x - меньшая куча
				moves = [
				f(x + 1, y, h - 1),
				f(x + 2, y, h - 1),
				f(x * 2, y, h - 1)
				]
			else: moves = [ // соответственно, если y - меньшая куча 
				f(x, y + 1, h - 1),
		        f(x, y + 2, h - 1),
				f(x, y * 2, h - 1)
		        ]
			if h % 2 != 0: return any(moves)
			else: return all(moves) 

		print([s for s in range(1, 53) if not f(8, s, 1) and f(8, s, 2)])
		print([s for s in range(1, 53) if not f(8, s, 1) and f(8, s, 3)])
		print([s for s in range(1, 53) if (f(8, s, 2) or f(8, s, 4)) and not f(8, s, 2)])	

	Условие: За один ход игрок может добавить в большую кучу любое количество камней от одного до трёх или удвоить количество камней в меньшей куче. Если кучи содержат равное количество камней, можно добавить в любую из них от одного до трёх камней, удвоение в этой ситуации запрещено.

		def f(x, y, h):
			if x + y >= 41: return h % 2 == 0
			if h == 0: return 0
			if y > x:
				moves = [
		 		f(x, y + 1, h - 1),
				f(x, y + 2, h - 1),
				f(x, y + 3, h - 1),
				f(x * 2, y, h - 1)
					]
			else: moves = [
				f(x + 1, y, h - 1),
		        f(x + 2, y, h - 1),
				f(x + 3, y, h - 1),
				f(x, y * 2, h - 1),
		        ]
			if x == y: moves = [
				f(x + 1, y, h - 1),
		        f(x + 2, y, h - 1),
				f(x + 3, y, h - 1),
		        ]
			if h % 2 != 0: return any(moves)
			else: return all(moves) 

		print([s for s in range(1, 24) if f(17, s, 4) and not f(17, s, 2)])				 

	Условие: Известно, что Петя смог выиграть первым ходом. Какое наименьшее число камней могло быть суммарно в двух кучах?

		a = []
		for x in range(1, 20):
			for y in range(1, 20):
				if f(x, y, 1) == 1: a.append(x + y)
		print(min(a))

	Условие: За один ход игрок может: убрать из кучи два камня или убрать из кучи пять камней или уменьшить количество камней в куче в три раза (количество камней, полученное при делении, округляется до меньшего). Игра завершается, когда количество камней в куче становится не более 19. Победителем считается игрок, сделавший последний ход, то есть первым получивший кучу, в которой будет 19 или меньше камней. Петя не может выиграть за один ход, но при любом ходе Пети Ваня может выиграть своим первым ходом.

		import math
		def f(x, h):
		    if x <= 19: return h % 2 == 0
		    if h == 0: return False
		    moves = [f(x - 2, h - 1), f(x - 5, h - 1), f(math.floor(x // 3), h - 1)]
		    if h % 2 != 0: return any(moves)
		    else: return any(moves)

		print([s for s in range(20, 100) if not f(s, 1) and f(s, 2)]) // 60
