2 

	print ('x y z w')
	for x in 0,1:
	    for y in 0,1:
	        for z in 0,1:
	            for w in 0,1:
	                if (x or (not y)) and (not(x == z) and (not w)) == 1:
	                    print(x, y, z, w)

    x y z w
	0 0 1 0
	1 0 0 0
	1 1 0 0	


	print ('x y z w')
	for x in 0,1:
	    for y in 0,1:
	        for z in 0,1:
	            for w in 0,1:
	                if (((x and w) or (w and z)) == ((z <= y) and (y <= x))) == 1:
	                    print(x, y, z, w)

	x y z w
	0 0 1 0
	0 1 0 0
	0 1 0 1
	0 1 1 0
	1 0 0 1
	1 0 1 0
	1 1 0 1
	1 1 1 1   


	print ('x y z w')
	for x in 0,1:
	    for y in 0,1:
	        for z in 0,1:
	            for w in 0,1:
	                if ((y <= w) == (x <= (not z)) and (x or w)) == 1:
	                    print(x, y, z, w)      

	print ('x y z w')
	for x in 0,1:
	    for y in 0,1:
	        for z in 0,1:
	            for w in 0,1:
	                if ((y <= w) == (x <= (not z)) and (x or w)) == 0:
	                    print(x, y, z, w)          
    
	x y z w     0
	0 0 0 0
	0 0 1 0
	0 1 0 0
	0 1 1 0 
	1 0 1 0
	1 0 1 1
	1 1 0 0
	1 1 1 1

	x y z w     1
	0 0 0 1
	0 0 1 1
	0 1 0 1
	0 1 1 1
	1 0 0 0
	1 0 0 1
	1 1 0 1
	1 1 1 0

23 
	
	Условие: 3 - 15 - 50. траектория не содержит 55

		def f(x, y):
	    if x > y or x == 33:
	        return 0
	    if x == y:
	        return 1
	    else:
	        return f(x + 1, y) + f(x * 2, y) + f(x * 3, y)
		print(f(3, 15) * f(15, 50))

		Отв: 121

5

	Двоичная система:

		На вход алгоритма подается натуральное число N. Алгоритм строит по нему новое число R следующим образом.
		1. Строится двоичная запись числа N
		2. К этой записи дописывается разряд по следующему правилу: если два младших (правых) разряда одинаковые, справа дописывается 0, иначе справа дописывается 1.
		3. К полученной записи дописывается еще один бит по правилу в пункте 2.
		Полученная таким образом запись является двоичной записью искомого числа R.
		Укажите минимальное число N, при вводе которого получится значение R больше, чем 93. В ответе полученное число запишите в десятичной системе.

			def f(N):
			    res = bin(N)[2:]
			    for i in range(2):
			        if res[-1] == res[-2]: res += '0'
			        else: res += '1'
			    return int(res, 2)
			print(min(N for N in range(5, 100) if f(N) > 93))		

			[-1] - срез указывает на последнее число.
			[-2] - срез указывает на предпоследнее число.		

		На вход алгоритма подаётся натуральное число N. Алгоритм строит по нему новое число R следующим образом. 
		1. Строится двоичная запись числа N.
		2. Полученная запись переворачивается (записывается слева направо).
		3. К полученной записи справа дописывается правый бит.
		Полученная таким образом запись (в ней на один разряд больше, чем в записи исходного числа N) является двоичной записью искомого числа R. Укажите минимальное число N в результате обработки которого получится число, большее 99. В ответе это число запишите в десятичной системе.

			def f(N):
			    res = bin(N)[2:]
			    res = res[::-1]
			    res += res[-1]
			    return int(res, 2)
			print(min([N for N in range(0, 100) if f(N) > 99]))

		На вход алгоритма подаётся натуральное число N. Алгоритм строит по нему новое число R следующим образом. 
		1. Строится двоичная запись числа N.
		2. К этой записи дописываются справа и слева ещё по одному или два разряда по следующему правилу: если N чётное, то в конец числа (справа) дописывается нуль, а в начало числа (слева) дописывается единица; если N нечётное, то в конец числа (справа) и в начало числа (слева) дописываются по две единицы. 
		Укажите наименьшее число R, превышающее 225, которое может являться результатом работы данного алгоритма. В ответе это число запишите в десятичной системе счисления.

			def f(N):
			    res = bin(N)[2:]
			    r = ''
			    if N % 2 == 0: 
			        r += '1' + res + '0'
			    else: 
			        r += '11' + res + '11'
			    return int(r, 2)
			R = []
			for i in range(0, 1000):
			    R.append(f(i))
			print(sorted(R)) 

			Находим минимальное число, превышающее 225 в списке чисел.

		На вход алгоритма подаётся натуральное число N. Алгоритм строит по нему новое число R следующим образом.
		1. Строится двоичная запись числа N.
		2. Все разряды полученного числа инвертируются.
		3. К полученному результату справа дописывается бит четности.
		Бит чётности это остаток от деления на 2 суммы цифр двоичной записи числа.
		Укажите максимальное число R, меньшее 170, которое может быть получено в результате работы этого алгоритма. В ответе это число запишите в десятичной системе.

			def f(N):
			    res = bin(N)[2:]
			    r = ''
			    for i in res:
			        if i == '1': r += '0'
			        else: r += '1'
			    l = res.count('1')
			    r += str(l % 2)
			    return int(r, 2)
			R = []
			for i in range(0, 1000):
			    R.append(f(i))
			print(sorted(R))

			Находим максимальное число, меньше 170 в списке чисел.

		На вход алгоритма подаётся натуральное число N. Алгоритм строит по нему новое число R следующим образом.
		1. Строится двоичная запись числа N.
		2. Далее эта запись обрабатывается по следующему правилу: если число N делится на 3, то к этой записи дописываются три последние двоичные цифры; если число N на 3 не делится, то остаток от деления умножается на 3, переводится в двоичную запись и дописывается в конец числа.
		3. Результат переводится в десятичную систему и выводится на экран.
		Укажите максимальное число N, после обработки которого с помощью этого алгоритма получается число R, меньшее чем 76.

			def f(N):
			    res = bin(N)[2:]
			    r = ''
			    if N % 3 == 0: r += res + res[-3] + res[-2] + res[-1]
			    else: r += res + (bin((N % 3) * 3)[2:])
			    return int(r, 2)
			print(max([N for N in range(4, 1000) if f(N) < 76]))

		Автомат обрабатывает натуральное число N по следующему алгоритму:
		1. Строится двоичная запись числа N.
		2. Из записи удаляются все нули.
		3. Полученное число переводится в десятичную запись и выводится на экран.
		Сколько разных значений будет показано на экране автомата при последовательном вводе всех натуральных чисел от 10 до 2500.

			def f(N):
			    res = bin(N)[2:]
			    r = ''
			    l = res.count('1')
			    r += '1' * l
			    return int(r, 2)
			r = set()
			for i in range(10, 2501):
			    r.add(f(i))
			print(len(r))

	Десятичная система

		Автомат получает на вход пятизначное число. По этому числу строится новое число по следующим правилам.
		1. Вычисляется квадрат суммы наибольшей и наименьшей цифр исходного числа.
		2. Вычисляется произведение всех чётных цифр исходного числа.
		3. Полученные два числа записываются друг за другом в порядке невозрастания (без разделителей).
		Укажите наименьшее число, при обработке которого автомат выдаст число 12116.

			def f(n):
			    digits = sorted(map(int, str(n)))
			    res1 = (digits[0] + digits[-1])**2
			    res2 = 1
			    for i in digits:
			        if i % 2 == 0: res2 *= i
			    if res1 > res2: return str(res1) + str(res2)
			    else: return str(res2) + str(res1)
			print(min([n for n in range(10000, 100000) if int(f(n)) == 12116]))		

		Автомат получает на вход натуральное четырёхзначное число N. По этому числу строится новое число по следующим правилам:
    	1. Цифры числа сортируются по возрастанию.
    	2. Для полученного числа складываются 1 и 4 цифры и перемножаются 2 и 3 цифры.
    	3. Результаты сложения и умножения записываются друг за другом: сначала результат сложения, затем умножения.
		Сколько существует чисел N, в результате применения к которым данного алгоритма получается число 1128?

			def f(n):
			    digits = sorted(map(int, str(n)))
			    res1 = digits[0] + digits[3]
			    res2 = digits[1] * digits[2]
			    resAll = str(res1) + str(res2) 
			    return int(resAll)
			r = 0
			for i in range(1000, 10000):
			    if f(i) == 1128: r += 1
			print(r)

		На вход алгоритма подаётся натуральное четырёхзначное число NN, в котором все цифры различны. Алгоритм строит по нему новое число RR следующим образом:
		1. Максимальная и минимальная цифры числа складываются.
		2. Остальные две цифры перемножаются.
		3. Полученные два числа записываются друг за другом в порядке неубывания (без разделителей).
		Полученное на шаге 3 число и является искомым R.
		Укажите минимальное число N, после обработки которого с помощью этого алгоритма получается число R, большее 85. В ответе запишите это число в десятичной системе счисления.		

			def f(n):
			    digits = sorted(map(int, str(n)))
			    res1 = digits[3] + digits[0]
			    res2 = digits[1] * digits[2]
			    if res1 > res2: return int(str(res2) + str(res1))
			    else: return int(str(res1) + str(res2))
			print([N for N in range(1000, 10000) if f(N) > 85])

			Очень важна строка "в котором все цифры различны" - поэтому найдем такое число в большом списке!

		Автомат получает на вход натуральное четырёхзначное число N. По этому числу строится новое число по следующим правилам:
		1. Складываются 1 и 2 цифры числа.
		2. Складываются 3 и 4 цифры числа.
		3. Полученные суммы записываются в порядке неубывания.
		4. Из наибольшей цифры полученного числа вычитается наименьшая, и результат вычитания записывается в конец числа.
		Каково наименьшее N, в результате применения к которому данного алгоритма, получается число 17176?		

			def f(n):
			    digits = list(map(int, str(n)))
			    res1 = digits[0] + digits[1]
			    res2 = digits[2] + digits[3]
			    res = ''
			    if res1 > res2: res = str(res2) + str(res1)
			    else: res = str(res1) + str(res2)
			    x = sorted(map(int, res))
			    y = x[-1] - x[0]
			    res = res + str(y)
			    return int(res)
			print(min([N for N in range(1000, 10000) if f(N) == 17176]))

		У Деда Мороза есть специальная машина для кодирования подарков, которая преобразует четырёхзначные числа по алгоритму:
		1. Вычисляет квадрат суммы чётных цифр
		2. Разность максимальной и минимальной цифры возводит в куб
		3. Полученные два числа записывает друг за другом в порядке неубывания
		Укажите наименьшее число, при обработке которого автомат выдаст число 4343.

			def f(n):
			    digits = sorted(map(int, str(n)))
			    res = []
			    for i in digits:
			        if i % 2 == 0: res.append(i)
			    res1 = sum(res)**2
			    res2 = (digits[-1] - digits[0])**3
			    r = ''
			    if res1 > res2: r = str(res2) + str(res1)
			    else: r = str(res1) + str(res2)
			    return int(r)
			print(min(N for N in range(1000, 10000) if f(N) == 4343))

		Дано натуральное четырёхзначное число N. К нему применяется алгоритм.
		1. Перемножаются первая и вторая, вторая и третья, третья и четвёртая цифры числа.
		2. Полученные произведения записываются друг за другом в порядке неубывания.
		3. Незначащие нули в начале числа отбрасываются.
		Какое максимальное четырёхзначное число можно получить?

			def f(n):
			    digits = list(map(int, str(n)))
			    res1 = digits[0] * digits[1]
			    res2 = digits[1] * digits[2]
			    res3 = digits[2] * digits[3]
			    r = sorted([res1, res2, res3])
			    res = ''
			    for i in r:
			        if i != 0: res += str(i)
			        else: res += '0'
			    return int(res)
			m = []
			for i in range(1000, 10000):
			    m.append(f(i))
			print(sorted(m))

		Автомат получает на вход четырёхзначное число. По этому числу строится новое число по следующим правилам.
		1. Складываются отдельно первая и вторая цифры, вторая и третья цифры, а также третья и четвёртая цифры.
		2. Из полученных трёх чисел выбираются два наибольших и записываются друг за другом в порядке неубывания без разделителей.
		Укажите наименьшее число, при обработке которого автомат выдаёт результат 1418.		

			def f(n):
			    digits = list(map(int, str(n)))
			    res1 = digits[0] + digits[1]
			    res2 = digits[1] + digits[2]
			    res3 = digits[2] + digits[3]
			    res = sorted([res1, res2, res3])
			    resAll = str(res[-2]) + str(res[-1])
			    return int(resAll)
			print(min([N for N in range(1000, 10000) if f(N) == 1418]))

		Автомат получает на вход четырёхзначное десятичное число, в котором все цифры нечётные. По этому числу строится новое число по следующим правилам.
		1. Складываются первая и вторая, а также третья и четвёртая цифры.
		2. Полученные два числа записываются друг за другом в порядке неубывания (без разделителей).
		Сколько существует чисел, в результате обработки которых автомат выдаст число 414.

			def f(n):
			    digits = list(map(int, str(n)))
			    res1 = digits[0] + digits[1]
			    res2 = digits[2] + digits[3]
			    res = sorted([res1, res2])
			    resAll = int(str(res[0]) + str(res[1]))
			    return resAll
			l = 0
			for i in range(1000, 10000):
			    I = list(map(int, str(i)))
			    if I[0] % 2 != 0 and I[1] % 2 != 0 and I[2] % 2 != 0 and I[3] % 2 != 0:
			        if f(i) == 414: l += 1
			print(l)

			Очень важна запись о числе, в котором все цифры нечетные.		

13 (сложный вариант)

		import itertools
		count = 0
		s = itertools.product([0, 1], repeat = 20)
		for i in s:
		    if (5 + sum(i)) % 5 != 0:
		        count += 1
		print(count)

	количество единиц в двоичной записи IP-адреса не кратно 5

	Использование функции itertools.product() с параметром repeat=20 для списка [0, 1] создаст все возможные комбинации длиной 20, состоящие из элементов 0 и 1. Это эквивалентно генерации всех двоичных чисел от 00000000000000000000 до 11111111111111111111.


		import itertools
		count = 0
		s = itertools.product([0, 1], repeat = 13)
		for i in s:
		    if i[12] == 1 and i[11] == 1:
		        if(10 + sum(i)) % 3 == 0:
		            count += 1
		print(count)

	количество единиц в двоичной записи IP-адреса кратно 3, а сама двоичная запись оканчивается на 11

16

	Условие: F(1) = 1 | F(2) = 1 | если n > 2, то F(n-1) * n - 2 * F(n-2)

		def F(n):
	    if n == 1:
	        return 1
	    if n == 2:
	        return 1
	    if n > 2:
	        return F(n-1) * n - 2 * F(n-2)
		print(F(6))

	Условие: F(n) = 1 если n = 1 | F(n) = n + F(n - 1) если n нечетно | F(n) = 2 * F(n - 2) если n > 1 и n нечетно

		def F(n):
	    if n == 1:
	        return 1
	    if n % 2 == 0:
	        return n + F(n - 1)
	    if n > 1 and n % 2 != 0:
	        return 2 * F(n - 2)
		print(F(26)) 


	F(n div 10) + (n mod 10) - функция, расчитывающая сумму цифр числа n.

	Условие: F(0) = 0 | F(n) = F(n div 10) + (n mod 10) | Укажите количество таких чисел n из интервала 765432019 <= n <= 1542613239 для которых F(n) > F(n + 1).

		Решение: Данная функция считает сумму цифр числа n. Необходимо определить в каких случаях сумма цифр в числе больше у меньшего числа. Это возможно только в одном случае, когда число оканчивается на цифру 9. В таком случае разряд увеличивается и сумма цифр следующего числа будет меньше суммы чисел предыдущего (Пример: число 239, сумма цифр 14, следующее число 240, сумма цифр 6). Первое такое число в данном интервале 765432019, далее можно посчитать все остальные числа с шагом 10. Таких чисел будет:

			s = 0
			for i in range(765432019, 1542613239 + 1, 10):
			    s += 1
			print(s) # 77718123

	Условие: 

		F(0) = 0;
		F(n) = F(n / 2), если n > 0 и при этом n чётно; 
		F(n) = 1 + F(n − 1), если n нечётно.
		Назовите минимальное значение n, для которого F(n) = 12.

			def f(n):
			    if n == 0: return 0
			    if n % 2 == 0 and n > 0: return f(n / 2)
			    if n % 2 != 0: return 1 + f(n - 1)
			i = 0
			while f(i) != 12: i += 1
			print(i)		

	Условие:

		F(0) = 0;
		F(n) = F(n / 2), если n > 0 и при этом чётно;
		F(n) = 1 + F(n − 1), если n нечётно.

		Сколько существует таких чисел n, что 1 <= n <= 1000 и F(n) = 3?

			def f(n):
			    if n == 0: return 0
			    if n > 0 and n % 2 == 0: return f(n / 2)
			    if n % 2 != 0: return 1 + f(n - 1)
			k = 0
			for n in range(1, 1001):
			    if f(n) == 3: k += 1
			print(k)		

	Условие: F(n) = 1 если n <= 5 | F(n) = n + F(n - 2) если n > 5.

		import sys
		sys.setrecursionlimit(10**8)
		def f(n):
		    if n <= 5: return 1
		    if n > 5: return n + f(n - 2)
		print(f(2126) - f(2122))  // 4250

	Альтернативный вариант решения 16 задания:

		Условие: F(n) = 1 если n <= 5 | F(n) = n + F(n - 2) если n > 5.

			f = {}
			for n in range(1, 2200, 1):
			    if n <= 5: f[n] = 1
			    if n > 5: f[n] = n + f[n - 2]
			print(f[2126] - f[2122])  // 4250		

14

	Условие: 4 * 343 ** 5 + 6 * 49 ** 8 - 50 | Система счисления: 7. Сколько цифр 6 содержится в записи?

		x = 4 * 343 ** 5 + 6 * 49 ** 8 - 50
		s = ''
		while x != 0: 
		    s += str(x % 7) // остаток от деления на 7 прибавляется к s (перевод x в семеричную систему)
		    x //= 7 // целочисленное деление на 7 (перевод x в семеричную систему)
		s = s[::-1] // разворот строки 
		print(s.count('6')) // подсчет цифр 6

    Операции в одной СС

		Условие: 98x79641 + 25x49 + 63x5 | основание системы - 22 | ! наименьшее x если 98x79641 + 25x49 + 63x5 кратно 21 | основание системы для x - 15

			for x in '0123456789abcde':
		    x1 = '98' + str(x) + '79641'
		    x2 = '25' + str(x) + '49'
		    x3 = '63' + str(x) + '5'
		    res = int(x1, 22) + int(x2, 22) + int(x3, 22)
		    if res % 21 == 0:
		        res = res // 21
		        print(res)
		        break

	    Условие 98x79641 + 36x14 + 73x4 | основание системы - 19 | ! наибольшее x если 98x79641 + 36x14 + 73x4 кратно 18 | основание системы для x - 10 

		    for x in '0123456789abcdefghi':
		    x1 = '98' + str(x) + '79641'
		    x2 = '36' + str(x) + '14'
		    x3 = '73' + str(x) + '4'
		    res = int(x1, 19) + int(x2, 19) + int(x3, 19)
		    if res % 18 == 0:
		        print(res // 18) // 470402599   	

	    Условие: 123xAB3 + 3CEx321 | основание системы - 31 | ! наибольшее x если 123xAB3 + 3CEx321 кратно 17 | основание системы для x - 10

		    for x in range(31):
		    x1 = 1*31**6+2*31**5+3*31**4+x*31**3+10*31**2+11*31**1+3*31**0 // перевод из 31-чной в 10-чную
		    x2 = 3*31**6+12*31**5+14*31**4+x*31**3+3*31**2+2*31**1+1*31**0
		    res = x1 + x2
		    if (res) % 17 == 0:
		        print(res // 17)

	    Условие: F29x8EAD637 * BAxDE0C1B37  | основание системы - 37 | ! наибольшее x если 123xAB3 + 3CEx321 кратно 17 | основание системы для x - 10

		    for x in range(37, 0, -1):
		    x1 = 15*37**8 + 2*37**7 + 9*37**6 + x*37**5 + 8*37**4 + 14*37**3 + 10*37**2 + 13*37 + 6
		    x2 = 11*37**8 + 10*37**7 + x*37**6 + 13*37**5 + 14*37**4 + 0*37**3 + 12*37**2 + 1*37 + 11
		    if (x1 * x2) % 36 == 0:
		        print(1*37**2 + x*37 + 2)

		    	или

		    for x in range(37):
		    x1 = 15*37**8 + 2*37**7 + 9*37**6 + x*37**5 + 8*37**4 + 14*37**3 + 10*37**2 + 13*37 + 6
		    x2 = 11*37**8 + 10*37**7 + x*37**6 + 13*37**5 + 14*37**4 + 0*37**3 + 12*37**2 + 1*37 + 11
		    if (x1 * x2) % 36 == 0:
		        print(1*37**2 + x*37 + 2)

	   	Условие: AB267D1 + F024A89 | основание системы - p | ! наименьшее p при котором AB267D1 + F024A89 будет делиться на p - 1 | основание системы для x - 10

		    for p in range(16, 1000):		// Так как F - 15, p > 15
		    x1 = 10*p**6 + 11*p**5 + 2*p**4 + 6*p**3 + 7*p**2 + 13*p**1 + 1
		    x2 = 15*p**6 + 0*p**5 + 2*p**4 + 4*p**3 + 10*p**2 + 8*p**1 + 9
		    if(x1 + x2) % (p - 1) == 0:
		        print(p) 

	    Условие: zxyx4 + xy658 = wzx73 | основание системы - p | ! Определить значение xyzw в десятичной системе

			for p in range(9, 100):			// Так как в выражении xy658 есть цифра 8, p > 8
			    for x in range(1, p):
			        for y in range(1, p):
			            for z in range(1, p):
			                for w in range(1, p):
			                    x1 = z*p**4+x*p**3+y*p**2+x*p**1+4
			                    x2 = x*p**4+y*p**3+6*p**2+5*p**1+8
			                    x3 = w*p**4+z*p**3+x*p**2+7*p**1+3
			                    if (x1 + x2) == x3:
			                        print(x*p**3 + y*p**2 + z*p**1 + w)  

	Операции в одной СС с разными переменными

		Условие: В числе 57x692y1940 x и y обозначают некоторые цифры из алфавита системы счисления с основанием 40. Определите такие значения x и y, при которых приведённое число кратно 39, а число yx40 является полным квадратом. В ответе запишите значение числа yx40 в десятичной системе счисления.
	
			for x in range(40):
			    for y in range(40):
			        s = 5*40**8 + 7*40**7 + x*40**6 + 6*40**5 + 9*40**4 + 2*40**3 + y*40**2 + 1*40**1 + 9
			        if s % 39 == 0 and (y*40**1 + x) ** 0.5 == round((y*40**1 + x) ** 0.5): print(y*40**1 + x)

	Операции в разных СС с одной переменной

		Условие: 2x84(19) + 2B3x(16) | ! Определить наименьшее значение x при котором значение 2x8419(19) + 2B3x16(16) кратно 88 | Для найденного x вычислите частное от деления на 88 в десятичной системе

			for x in range(16):
			    x1 = 2*19**3 + x*19**2 + 8*19**1 + 4
			    x2 = 2*16**3 + 11*16**2 + 3*16**1 + x
			    if (x1 + x2) % 88 == 0:
			        print((x1 + x2) // 88)		

		Условие: 8x71(13) + 3xDF(17) | ! Определить наименьшее значение x при котором значение 8x71(13) + 3xDF(17) кратно 197 | Для найденного x вычислите частное от деления на 197 в десятичной системе

			for x in range(10):
			    x1 = 8*13**3 + x*13**2 + 7*13 + 1
			    x2 = 3*17**3 + x*17**2 + 13*17 + 15
			    if (x1 + x2) % 197 == 0:
			        print((x1 + x2) // 197)

    Операции в разных СС с двумя переменными

    	Условие: x231y(12) + 78x98y(14) | ! Определить наименьшее значение x и y при котором значение x231y(12) + 78x98y(14) кратно 99 | Для найденного x и y вычислите частное от деления на 99 в десятичной системе

	    	for x in range(12):
			    for y in range(12):
			        x1 = x*12**4 + 2*12**3 + 3*12**2 + 1*12 + y  
			        x2 = 7*14**5 + 8*14**4 + x*14**3 + 9*14**2 + 8*14 + y
			        if (x1 + x2) % 99 == 0:
			            print((x1 + x2) // 99)

6

	ось ординат:

		import turtle - добавление библиотеки, предназначенной для создания графики с использованием черепахи
		t = turtle.Turtle() - создание объекта черепахи
		t.left(90) - поворот черепахи на лево для направления по оси ординат
		k = 40 - коэффициент масштабирования
		t.pendown() - ручка опущена
		turtle.tracer(0) - отключение анимации
		for i in range(7): 
		    t.forward(10*k) - вперед
		    t.right(120) - вправо, градус
		t.penup() - ручка поднята
		for x in range(-10, 10): - построение пространства точек по x 
		    for y in range(-10, 10): - построение пространства точек по y
		        t.setpos(x * k, y * k) - перемещение черепахи в точку в данный момент
		        t.dot(5, 'red') - отрисовка точки
		turtle.done() - завершение программы

	ось абсцисс:

		import turtle
		t = turtle.Turtle()
		k = 40
		t.pendown()
		turtle.tracer(0)
		for i in range(7):
		    t.forward(10*k)
		    t.right(120)
		t.penup()
		for x in range(-10, 10):
		    for y in range(-10, 10):
		        t.setpos(x * k, y * k)
		        t.dot(5, 'red')
		turtle.done()

	Пример решения +- сложного варика с осью ординат:

	Условие: 

		Повтори 9 [Вперёд 29 Направо 90 Вперёд 17 Направо 90]
		Поднять хвост
		Вперёд 5 Направо 90 Вперёд 1 Налево 90
		Опустить хвост
		Повтори 9 [Вперёд 64 Направо 90 Вперёд 48 Направо 90]
		Определите площадь пересечения фигур, нарисованных при помощи алгоритма.

			import turtle
			t = turtle.Turtle()
			t.left(90)
			k = 11
			t.pendown()
			turtle.tracer(0)
			for i in range(9):
			    t.forward(29 * k)
			    t.right(90)
			    t.forward(17 * k)
			    t.right(90)
			t.penup()
			t.forward(5 * k)
			t.right(90)
			t.forward(1 * k)
			t.left(90)
			t.pendown()
			for i in range(9):
			    t.forward(64 * k)
			    t.right(90)
			    t.forward(48 * k)
			    t.right(90)
			t.penup()
			for x in range (-50, 50):
			    for y in range(-50, 50):
			        t.setpos(x * k, y * k)
			        t.dot(5, 'red')
			turtle.done()

7

	Условие: Книгу объёмом 1 Мбайт записали как аудиокнигу. Запись велась в формате стерео (2 канала) с частотой 48 кГц и разрешением 24 бит. За одну минуту записывалось в среднем 1,5 Кбайт текста. Сжатие данных позволило сократить размер полученного звукового файла на 84%. Для удобства использования запись разделили на фрагменты со средним размером 15 Мбайт. Определите количество полученных фрагментов.

		x = 1 * 1024 * 1024 * 8
		x2 = 1.5 * 1024 * 8
		i = 2
		f = 48 * 1000
		l = 24
		m = (x / x2) * 60
		res = m * l * f * i
		res2 = res * 0.16
		print(res2 / (15 * 1024 * 1024 * 8))	// 120

12

	Условие: На вход этой программе подаётся строка длины 94, состоящая из цифры 3, за которой следуют 93 идущих подряд цифр 9. Условие: '3' + '9' * 93

		s = '3' + '9' * 93
		while ('19' in s or '29' in s or '3999' in s):
		    s = s.replace('19', '2', 1)
		    s = s.replace('299', '3', 1)
		    s = s.replace('3999', '1', 1)
		print(s)

	Условие: Какая строка получится в результате применения приведённой ниже программы к строке вида 1…12…2 (39 единиц и 39 двоек)? Условие: '1' * 39 + '2' * 39

		s = '1' * 39 + '2' * 39
		while ('111' in s):
		    s = s.replace('111', '2', 1)
		    s = s.replace('222', '1', 1)
		print(s)

	Условие: Какая строка получится в результате применения приведённой ниже программы к строке, состоящей из 70 идущих подряд цифр 8? Условие: '8' * 70

		s = '8' * 70
		while ('2222' in s or '8888' in s):
		    if('2222' in s):
		        s = s.replace('2222', '88', 1)
		    else:
		        s = s.replace('8888', '22', 1)
		print(s)

	Условие: На вход приведённой ниже программе поступает строка, начинающаяся с символа ">", а затем содержащая 11 цифр 1, 12 цифр 2 и 30 цифр 3, расположенных в произвольном порядке. Определите сумму числовых значений цифр строки, получившейся в результате выполнения программы. Так, например, если результат работы программы представлял бы собой строку, состоящую из 50 цифр 4, то верным ответом было бы число 200.

		s = '>' + '1' * 11 + '2' * 12 + '3' * 30
		while '>1' in s or '>2' in s or '>3' in s:
		    if '>1' in s:
		        s = s.replace('>1', '22>', 1)
		    if '>2' in s:
		        s = s.replace('>2', '2>', 1)
		    if '>3' in s:
		        s = s.replace('>3', '1>', 1)
		print(s.count('1') + s.count('2')*2 + s.count('3')*3)

	Условие: Известно, что исходная строка A содержала ровно два нуля - на первом и на последнем месте, а также по 10 единиц и двоек. После выполнения данной программы получилась строка B, содержащая 6 единиц и 5 двоек. Какое наибольшее количество четвёрок может быть в строке B?

		from itertools import product
		for i in product('12', repeat = 20): // генерация всех возможных строк длины 20, с символами 																				  либо'1', либо '2'.
	    s = '0' + ''.join(i) + '0' // объединение сгенерированной последовательности с двумя '0'
	    if s.count('1') == 10 and s.count('2') == 10: // условие для A
	        while not '00' in s:
	            s = s.replace('012', '30')
	            if '011' in s:
	                s = s.replace('011', '20')
	                s = s.replace('022', '40')
	            else:
	                s = s.replace('01', '10')
	                s = s.replace('02', '101')
	        if s.count('1') == 6 and s.count('2') == 5: // условие для B
	            print(s.count('4'))

	Условие: Известно, что исходная строка начиналась с нуля и заканчивалась нулём, а между ними содержала только единицы, двойки и тройки. После выполнения данной программы получилась строка, содержащая 61 единицу, 50 двоек и 18 троек. Сколько цифр было в исходной строке?

		for i1 in range(61):
		    for i2 in range(61):
		        for i3 in range(61):
		            src = '0' + i1 * '1' + i2 * '2' + i3 * '3' + '0'
		            s = src
		            while '01' in s or '02' in s or '03' in s:
		                s = s.replace('01', '210', 1)
		                s = s.replace('02', '3101', 1)
		                s = s.replace('03', '2012', 1)
		            if s.count('1') == 61 and s.count('2') == 50 and s.count('3') == 18: 
		                print(len(src)) // 38
		                quit()	

15  

	Отрезки:

		Условие: На числовой прямой даны два отрезка: D = [17;58] и C = [29;80]. Укажите наименьшую возможную длину такого отрезка A, для которого логическое выражение - (x ∈ D) → ((¬(x ∈ C) ∧ ¬(x ∈ A)) → ¬(x ∈ D)) истинно (то есть принимает значение 1) при любом значении переменной х.

			def f(x):
			    D = 17 <= x <= 58
			    C = 29 <= x <= 80
			    A = a1 <= x <= a2
			    return D <= (((not C) and (not A)) <= (not D))
			r = []
			d = [y for x in (17, 58, 29, 80) for y in (x, x + 0.1, x - 0.1)]
			for a1 in d:
			    for a2 in d:
			        if a2 >= a1 and all(f(x) == 1 for x in d):
			            r += [a2 - a1]
			print(min(r))		

			Строчку r += [a2 - a1] можно заменить r.extend([a2 - a1]) или r.append(a2 - a1).

			D, C, A - булевые значения.
			D = 17 <= x <= 58 - если x входит в диапазон, то D равно True.

			Если x ∈ A, то A.
			Если x ∉ A, то (not A).

		Условие: На числовой прямой даны три отрезка: P = [10,15], Q = [10,20] и R = [5,15]. Какова наименьшая возможная длина интервала A, что формулы (x ∈ A) → (x ∈ P) и (x ∈ Q) → (x ∈ R) тождественно равны, то есть принимают равные значения при любом значении переменной х (за исключением, возможно, конечного числа точек).

			def f(x):
			    P = 10 <= x <= 15
			    A = a1 <= x <= a2
			    return A <= P
			def g(x):
			    Q = 10 <= x <= 20
			    R = 5 <= x <= 15
			    return Q <= R
			r = []
			d = [y for x in (10, 15, 10, 20, 5, 15) for y in (x, x + 0.1, x - 0.1)]
			for a1 in d:
			    for a2 in d:
			        if a2 >= a1 and all(f(x) == g(x) for x in d): r.extend([a2 - a1])
			print(min(r))

		Условие: На числовой прямой даны два отрезка: P = [52;105] и  Q = [0;53]. Укажите наименьшую возможную длину такого отрезка A, для которого логическое выражение ((x∉P)∧(x∉Q)∧(x∉A))→(x2>303601) истинно (т.е. принимает значение 1) при любом неотрицательном значении переменной x.

			def f(x):
			    P = 52 <= x <= 105
			    Q = 0 <= x <= 53
			    A = a1 <= x <= a2
			    return ((not P) and (not Q) and (not A)) <= (x**2 > 551**2)
			r = []
			d = [y for x in (-551, 52, 105, 0, 53, 551) for y in (x, x + 0.1, x - 0.1)]
			for a1 in d:
			    for a2 in d:
			        if a2 >= a1 and all(f(x) == 1 for x in d if x >= 0): r.extend([a2 - a1]) 
			print(min(r))		

			303601 - 551 ** 2 или -551 ** 2: они тоже точки отрезка.
			f(x) == 1 for x in d if x >= 0 !! при любом неотрицательном значении переменной x.

	Конъюнкция:

		Условие: Для какого наименьшего неотрицательного целого числа А формула x&17 = 0 → (x&29 ≠ 0 → x&А ≠ 0) тождественно истинна (т.е. принимает значение 1 при любом неотрицательном целом значении переменной х)?

			def f(x, A):
			    return (x & 17 == 0) <= ((x & 29 != 0) <= (x & A != 0))
			print(min([A for A in range(0, 1000) if all(f(x, A) == 1 for x in range(0, 1000))]))

		Условие: Для какого наименьшего неотрицательного целого числа А формула (x&6280 > 0 ∨ x&3394 > 0) → (x&10828 = 0 → x&A > 0) тождественно истинна (т.е. принимает значение 1 при любом неотрицательном целом значении переменной х)?	 	

			def f(x, A):
			    return ((x & 6280 > 0) or (x & 3394 > 0)) <= ((x & 10828 == 0) <= (x & A > 0))
			print(min([A for A in range(0, 20000) if all(f(x, A) == 1 for x in range(0, 20000))]))	

			Для подобных задач расширяем диапазон перебора A и x в зависимости от формулы.

	Делители:

		Условие: Для какого наибольшего натурального числа А логическое выражение ¬ДЕЛ(x, А) → (ДЕЛ(x, 14) → ¬ДЕЛ(x, 4)) истинно (т.е. принимает значение 1) при любом целом положительном значении переменной х?

			def DEL(x, y): return x % y == 0
			def f(x, A):
			    return (not(DEL(x, A))) <= (DEL(x, 14) <= (not(DEL(x, 4))))
			print(max([A for A in range(1, 1000) if all(f(x, A) == 1 for x in range(1, 1000))]))

			или

			def f(x, A):
			    return (not(x % A == 0)) <= ((x % 14 == 0) <= (not(x % 4 == 0)))
			print(max([A for A in range(1, 1000) if all(f(x, A) == 1 for x in range(1, 1000))]))

		Условие: Для какого наибольшего натурального числа А логическое выражение тождественно истинна (то есть принимает значение 1 при любом натуральном значении переменной x), если B=[70,90]? ДЕЛ(x, A) ∨ ((x ∈ B) → ¬(ДЕЛ(x, 22))).

			def DEL(x, y): return x % y == 0
			def f(x, A): 
			    B = 70 <= x <= 90
			    return DEL(x, A) or (B <= (not(DEL(x, 22))))
			print(max([A for A in range(1, 1000) if all(f(x, A) == 1 for x in range(1, 1000))]))

		Условие: Укажите наименьшее целое значение A, для которого формула (ДЕЛ(144,x)→¬ДЕЛ(x,y))∨ (x+y>100)∨(A−x>y) тождественно истинна при любых натураль ных значениях переменных x и y.

			def DEL(x, y): return x % y == 0
			def f(x, y, A): return (DEL(144, x) <= (not(DEL(x, y)))) or (x + y > 100) or (A - x > y)
			print(min([A for A in range(0, 200) if all(f(x, y, A) == 1 for x in range(1, 200) for y in range(1, 200))]))

		Условие: Обозначим через ТРЕУГ(n,m,k) утверждение «существует невырожденный треугольник с длинами сторон n, m, k». Для какого наибольшего натурального числа A формула ((ТРЕУГ(x,10,20) → (¬(МАКС(x, 8) > 24))) = ¬(ТРЕУГ(3,A,x))) тождественно истинна (то есть принимает значение 1) при любом натуральном значении переменной х? 

			def TRIANGLE(n, m, k): 
			    if n + m > k and n + k > m and k + m > n: return True
			    else: return False
			def f(x, A): return ((TRIANGLE(x, 10, 20) <= (not(max(x, 8) > 24))) == (not(TRIANGLE(3, A, x))))
			print(max([A for A in range(1, 2000) if all(f(x, A) == 1 for x in range(1, 2000))]))

			или (более короткая запись функции TRIANGLE)

			def TRIANGLE(n, m, k): return True if n + m > k and n + k > m and k + m > n else False
			def f(x, A): return ((TRIANGLE(x, 10, 20) <= (not(max(x, 8) > 24))) == (not(TRIANGLE(3, A, x))))
			print(max([A for A in range(1, 2000) if all(f(x, A) == 1 for x in range(1, 2000))]))

		Условие: Обозначим через ТРЕУГ(n,m,k) утверждение «существует треугольник с длинами сторон n, m, k». Для какого наибольшего натурального числа A формула ¬((ТРЕУГ (х, 11, 16) ≡ (¬(МАКС(x, 5) > 10))) ∧ ТРЕУГ(4, A, x)) тождественно истинна (то есть принимает значение 1) при любом натуральном значении переменной х? 

			def triangle(n, m, k): return True if n + m > k and n + k > m and k + m > n else False
			def f(x, A): return (not((triangle(x, 11, 16) == ((not(max(x, 5) > 10)))) and triangle(4, A, x)))
			print(max([A for A in range(1, 1000) if all(f(x, A) == 1 for x in range(1, 1000))]))

	Неравенства

		Для какого наименьшего целого неотрицательного числа А выражение (3x + 7y < A) ∨ (x ≥ y) ∨ (y > 6) тождественно истинно, то есть принимает значение 1 при любых целых неотрицательных x и y? 

			def f(x, y, A): return (3 * x + 7 * y < A) or (x >= y) or (y > 6)
			print(min([A for A in range(0, 100) if all(f(x, y, A) == 1 for x in range(0, 100) for y in range(0, 100))]))
 
19, 20, 21

	!!Строчка [s for s in range(1, 57) if f(s, 2)] - эта конструкция называется "генератор". Это способ в одну строку создать список (массив), наполненный значениями. Двоеточия нет именно потому, что это не цикл for, а генератор.

	ЗАПОМНИТЬ! Поменять all(moves) на any(moves) в случае если в 19 задании спрашивают (после неудачного хода пети), но для 20 и 21 меняем обратно на all(moves).




	19) Условие: одна куча | stop 56 | + 1 | +2 | *2| петя даун. Ваня выиграл своим первым ходом после неудачного первого хода Пети

		def f(x, h):
		    if x >= 56:
		        return h % 2 == 0
		    if h == 0:
		        return False 
		    moves = [f(x + 1, h - 1), f(x + 2, h - 1), f(x * 2, h - 1)]
		    if h % 2 != 0:
		        return any(moves)  
		    else:
		        return any(moves)  

		print([s for s in range(1, 57) if f(s, 2)]) // [14]

		Если в 19 задании спрашивается победа Вани или Пети после НЕУДАЧНОГО ХОДА противника, необходимо в 10 строчке поменять all на any. В 20 и 21 заданиях не трогаем эту строку.

	55815) Условие: одна куча | stop 78 | + 1 | +4 | * 4 |  

		def f(x, h): 
		    if x >= 78: 
		        return h % 2 == 0 
		    if h == 0: 
		        return 0 
		    moves = [f(x + 1, h - 1), f(x + 4, h - 1), f(x * 4, h - 1)] 
		    if h % 2 != 0: 
		        return any (moves) 
		    if h % 2 == 0: 
		        return all(moves) 
		print([s for s in range(1, 79) if f(s, 2)]) 
		print([s for s in range(1, 79) if not f(s, 1) and f(s, 3)]) 
		print([s for s in range(1, 79) if (f(s, 2) or f(s, 4)) and not f(s, 2)]) 

		// [19, 78]
		   [15, 18]
		   [14, 17]

	27780) Условие: две кучи | stop 74 | 1 <= s <= 61 | + 1 | * 2 | 

		def f(x, y, h):
		    if x + y >= 74:
		        return h % 2 == 0
		    if h == 0:
		        return 0
		    moves = [f(x + 1, y, h - 1), f(x * 2, y, h - 1), f(x, y + 1, h - 1), f(x, y * 2, h - 1)]
		    if h % 2 != 0:
		        return any(moves)
		    else:
		        return all(moves) // с заменой
		print([s for s in range(1, 62) if f(12, s, 2)])
		print([s for s in range(1, 62) if not f(12, s, 1) and f(12, s, 3)])
		print([s for s in range(1, 62) if (f(12, s, 2) or f(12, s, 4)) and not f(12, s, 2)])

		// [16] // с заменой all(moves) на any(moves)
		   [24, 30]
		   [29]

	Если есть условие добавления камней в МЕНЬШУЮ кучу:

		def f(x, y, h):
			if x + y >= 61: return h % 2 == 0
			if h == 0: return 0
			if y > x: // если x - меньшая куча
				moves = [
				f(x + 1, y, h - 1),
				f(x + 2, y, h - 1),
				f(x * 2, y, h - 1)
				]
			else: moves = [ // соответственно, если y - меньшая куча 
				f(x, y + 1, h - 1),
		        f(x, y + 2, h - 1),
				f(x, y * 2, h - 1)
		        ]
			if h % 2 != 0: return any(moves)
			else: return all(moves) 

		print([s for s in range(1, 53) if not f(8, s, 1) and f(8, s, 2)])
		print([s for s in range(1, 53) if not f(8, s, 1) and f(8, s, 3)])
		print([s for s in range(1, 53) if (f(8, s, 2) or f(8, s, 4)) and not f(8, s, 2)])	

	Условие: За один ход игрок может добавить в большую кучу любое количество камней от одного до трёх или удвоить количество камней в меньшей куче. Если кучи содержат равное количество камней, можно добавить в любую из них от одного до трёх камней, удвоение в этой ситуации запрещено.

		def f(x, y, h):
			if x + y >= 41: return h % 2 == 0
			if h == 0: return 0
			if y > x:
				moves = [
		 		f(x, y + 1, h - 1),
				f(x, y + 2, h - 1),
				f(x, y + 3, h - 1),
				f(x * 2, y, h - 1)
					]
			else: moves = [
				f(x + 1, y, h - 1),
		        f(x + 2, y, h - 1),
				f(x + 3, y, h - 1),
				f(x, y * 2, h - 1),
		        ]
			if x == y: moves = [
				f(x + 1, y, h - 1),
		        f(x + 2, y, h - 1),
				f(x + 3, y, h - 1),
		        ]
			if h % 2 != 0: return any(moves)
			else: return all(moves) 

		print([s for s in range(1, 24) if f(17, s, 4) and not f(17, s, 2)])				 

	Условие: Известно, что Петя смог выиграть первым ходом. Какое наименьшее число камней могло быть суммарно в двух кучах?

		a = []
		for x in range(1, 20):
			for y in range(1, 20):
				if f(x, y, 1) == 1: a.append(x + y)
		print(min(a))

	Условие: За один ход игрок может: убрать из кучи два камня или убрать из кучи пять камней или уменьшить количество камней в куче в три раза (количество камней, полученное при делении, округляется до меньшего). Игра завершается, когда количество камней в куче становится не более 19. Победителем считается игрок, сделавший последний ход, то есть первым получивший кучу, в которой будет 19 или меньше камней. Петя не может выиграть за один ход, но при любом ходе Пети Ваня может выиграть своим первым ходом.

		import math
		def f(x, h):
		    if x <= 19: return h % 2 == 0
		    if h == 0: return False
		    moves = [f(x - 2, h - 1), f(x - 5, h - 1), f(math.floor(x // 3), h - 1)]
		    if h % 2 != 0: return any(moves)
		    else: return any(moves)

		print([s for s in range(20, 100) if not f(s, 1) and f(s, 2)]) // 60